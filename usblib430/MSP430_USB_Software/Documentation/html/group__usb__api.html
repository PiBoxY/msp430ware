<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MSP430USBDevelopersPackage_5_20_06_02: Usb_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <img alt="Logo" width=25% src="ti_hz_2c_pos_rgb_png.png"/>
    <table cellspacing="0" cellpadding="0">
        <tbody>
        <tr style="height: 56px;">
            <td style="padding-left: 0.5em;">
                <div id="projectname">MSP430USBDevelopersPackage_5_20_06_02
                </div>
            </td>
        </tr>
        </tbody>
    </table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__usb__api.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Usb_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3cffb725fc7ab389006f59edabf1271c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga3cffb725fc7ab389006f59edabf1271c">USB_init</a> (void)</td></tr>
<tr class="separator:ga3cffb725fc7ab389006f59edabf1271c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033508453c85c43e7bfca01d358b8396"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga033508453c85c43e7bfca01d358b8396">USB_setup</a> (uint8_t connectEnable, uint8_t eventsEnable)</td></tr>
<tr class="separator:ga033508453c85c43e7bfca01d358b8396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ffd9c3457c34629eab6a735e735f956"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga0ffd9c3457c34629eab6a735e735f956">USB_enable</a> ()</td></tr>
<tr class="separator:ga0ffd9c3457c34629eab6a735e735f956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680e03643ad44bd7b34cecef16edbb8f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga680e03643ad44bd7b34cecef16edbb8f">USB_disable</a> (void)</td></tr>
<tr class="separator:ga680e03643ad44bd7b34cecef16edbb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4a5b2a9dfa5fd1f2220cd44d6377590"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#gaa4a5b2a9dfa5fd1f2220cd44d6377590">USB_setEnabledEvents</a> (uint16_t events)</td></tr>
<tr class="separator:gaa4a5b2a9dfa5fd1f2220cd44d6377590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4594efa7c0946ea7e7c456b75a3e030b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga4594efa7c0946ea7e7c456b75a3e030b">USB_getEnabledEvents</a> ()</td></tr>
<tr class="separator:ga4594efa7c0946ea7e7c456b75a3e030b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e696d6c7aebf67e80d516bb15540758"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga7e696d6c7aebf67e80d516bb15540758">USB_connect</a> ()</td></tr>
<tr class="separator:ga7e696d6c7aebf67e80d516bb15540758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8022c23568072f4740108c20b544b3e1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga8022c23568072f4740108c20b544b3e1">USB_disconnect</a> ()</td></tr>
<tr class="separator:ga8022c23568072f4740108c20b544b3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbd15fd1ebc2151234bc547e077c328"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga3dbd15fd1ebc2151234bc547e077c328">USB_reset</a> ()</td></tr>
<tr class="separator:ga3dbd15fd1ebc2151234bc547e077c328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a8fcfe91b2ccc4ed6376bcfede2eaf"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga63a8fcfe91b2ccc4ed6376bcfede2eaf">USB_suspend</a> (void)</td></tr>
<tr class="separator:ga63a8fcfe91b2ccc4ed6376bcfede2eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bbc9d18b98daa76ebb4f76db748b6e1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga3bbc9d18b98daa76ebb4f76db748b6e1">USB_resume</a> (void)</td></tr>
<tr class="separator:ga3bbc9d18b98daa76ebb4f76db748b6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1567f66939d7545ad93363b4328396cb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga1567f66939d7545ad93363b4328396cb">USB_forceRemoteWakeup</a> ()</td></tr>
<tr class="separator:ga1567f66939d7545ad93363b4328396cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d88a354fb27704a0c48e89fa8a598ea"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga7d88a354fb27704a0c48e89fa8a598ea">USB_getConnectionInformation</a> ()</td></tr>
<tr class="separator:ga7d88a354fb27704a0c48e89fa8a598ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdff93c1ac6b8e3ea2f6c4c1fd5fe40f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#gacdff93c1ac6b8e3ea2f6c4c1fd5fe40f">USB_getConnectionState</a> ()</td></tr>
<tr class="separator:gacdff93c1ac6b8e3ea2f6c4c1fd5fe40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a08a1a448fa33c15b9aa5b7b737b000"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga4a08a1a448fa33c15b9aa5b7b737b000">USBHID_sendDataAndWaitTillDone</a> (uint8_t *dataBuf, uint16_t size, uint8_t intfNum, uint32_t ulTimeout)</td></tr>
<tr class="separator:ga4a08a1a448fa33c15b9aa5b7b737b000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef92f60053448b5c50f6dccca13534ac"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#gaef92f60053448b5c50f6dccca13534ac">USBHID_sendDataInBackground</a> (uint8_t *dataBuf, uint16_t size, uint8_t intfNum, uint32_t ulTimeout)</td></tr>
<tr class="separator:gaef92f60053448b5c50f6dccca13534ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78b76eb5ea08e2ae235ef3a3196b691a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga78b76eb5ea08e2ae235ef3a3196b691a">USBHID_receiveDataInBuffer</a> (uint8_t *, uint16_t, uint8_t)</td></tr>
<tr class="separator:ga78b76eb5ea08e2ae235ef3a3196b691a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1e8fb53737e116b7d79d7aaff55727"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga1e1e8fb53737e116b7d79d7aaff55727">USBCDC_sendDataAndWaitTillDone</a> (uint8_t *dataBuf, uint16_t size, uint8_t intfNum, uint32_t ulTimeout)</td></tr>
<tr class="separator:ga1e1e8fb53737e116b7d79d7aaff55727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga368e1d92ce4965eca3dbd8d2fcc6a86a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#ga368e1d92ce4965eca3dbd8d2fcc6a86a">USBCDC_sendDataInBackground</a> (uint8_t *dataBuf, uint16_t size, uint8_t intfNum, uint32_t ulTimeout)</td></tr>
<tr class="separator:ga368e1d92ce4965eca3dbd8d2fcc6a86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa918350020f71ce5e1007d10ffbb4f94"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usb__api.html#gaa918350020f71ce5e1007d10ffbb4f94">USBCDC_receiveDataInBuffer</a> (uint8_t *, uint16_t, uint8_t)</td></tr>
<tr class="separator:gaa918350020f71ce5e1007d10ffbb4f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7e696d6c7aebf67e80d516bb15540758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes USB Module Available to Host for Connection.</p>
<p>Instructs the USB module to make itself available to the host for connection, by pulling the D+ signal high using the PUR pin. This call should only be made after a call to <a class="el" href="group__usb__api.html#ga0ffd9c3457c34629eab6a735e735f956">USB_enable()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ga680e03643ad44bd7b34cecef16edbb8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the USB Module and PLL.</p>
<p>Disables the USB module and PLL. If USB is not enabled when this call is made, no error is returned - the call simply exits with success.</p>
<p>If a handleVbusOffEvent() occurs, or if <a class="el" href="group__usb__api.html#gacdff93c1ac6b8e3ea2f6c4c1fd5fe40f">USB_getConnectionState()</a> begins returning ST_USB_DISCONNECTED, this function should be called (following a call to <a class="el" href="group__usb__api.html#ga8022c23568072f4740108c20b544b3e1">USB_disconnect()</a>), in order to avoid unnecessary current draw.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8022c23568072f4740108c20b544b3e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forces a Disconnect From the USB Host.</p>
<p>Forces a logical disconnect from the USB host by pulling the PUR pin low, removing the pullup on the D+ signal. The USB module and PLL remain enabled. If the USB is not connected when this call is made, no error is returned - the call simply exits with success after ensuring PUR is low.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ffd9c3457c34629eab6a735e735f956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_enable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the USB Module.</p>
<p>Enables the USB module, which includes activating the PLL and setting the USB_EN bit. Power consumption increases as a result of this operation (see device datasheet for specifics). This call should only be made after an earlier call to <a class="el" href="group__usb__api.html#ga3cffb725fc7ab389006f59edabf1271c">USB_init()</a>, and prior to any other call except than <a class="el" href="group__usb__api.html#gaa4a5b2a9dfa5fd1f2220cd44d6377590">USB_setEnabledEvents()</a>, or <a class="el" href="group__usb__api.html#ga4594efa7c0946ea7e7c456b75a3e030b">USB_getEnabledEvents()</a>. It is usually called just prior to attempting to connect with a host after a bus connection has already been detected.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1567f66939d7545ad93363b4328396cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_forceRemoteWakeup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remote Wakeup of USB Host.</p>
<p>Prompts a remote wakeup of the USB host. The user must ensure that the USB descriptors had indicated remote wakeup capability (using the Descriptor Tool); otherwise the host will ignore the request.</p>
<p>If the function returns <b>USB_GENERAL_ERROR</b>, it means that the host did not grant the device the ability to perform a remote wakeup, when it enumerated the device.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b>, <b>kUSBgeneralError</b> or <b>kUSB_notSuspended</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d88a354fb27704a0c48e89fa8a598ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_getConnectionInformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets Connection Info.</p>
<p>Returns low-level status information about the USB connection.</p>
<p>Because multiple flags can be returned, the possible values can be masked together - for example, <b>USB_VBUS_PRESENT</b> + <b>USB_SUSPENDED</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>A single mask that is the all the statuses together and may consist of the following:<ul>
<li><b>USB_PUR_HIGH</b> </li>
<li><b>USB_SUSPENDED</b> </li>
<li><b>USB_NOT_SUSPENDED</b> </li>
<li><b>USB_ENUMERATED</b> </li>
<li><b>USB_VBUS_PRESENT</b> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gacdff93c1ac6b8e3ea2f6c4c1fd5fe40f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_getConnectionState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets State of the USB Connection.</p>
<p>Returns the state of the USB connection, according to the state diagram in Sec. 6 of <em>"Programmer's Guide: MSP430 USB API Stack for CDC/PHDC/HID/MSC"</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Any of the following:<ul>
<li><b>ST_USB_DISCONNECTED</b> </li>
<li><b>ST_USB_CONNECTED_NO_ENUM</b> </li>
<li><b>ST_ENUM_IN_PROGRESS</b> </li>
<li><b>ST_ENUM_ACTIVE</b> </li>
<li><b>ST_ENUM_SUSPENDED</b> </li>
<li><b>ST_NOENUM_SUSPENDED</b>,</li>
<li><b>ST_ERROR</b>. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4594efa7c0946ea7e7c456b75a3e030b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t USB_getEnabledEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns Which Events are Enabled/Disabled.</p>
<p>Returns which events are enabled and which are disabled. The definition of events is the same as for USB_enableEvents() above.</p>
<p>If the bit is set, the event is enabled. If cleared, the event is disabled. By default (that is, prior to calling <a class="el" href="group__usb__api.html#gaa4a5b2a9dfa5fd1f2220cd44d6377590">USB_setEnabledEvents()</a> ), all events are disabled. This call can be made at any time after a call to <a class="el" href="group__usb__api.html#ga3cffb725fc7ab389006f59edabf1271c">USB_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><b>Events</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3cffb725fc7ab389006f59edabf1271c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the USB Module.</p>
<p>Initializes the USB module by configuring power and clocks, and configures pins that are critical for USB. This should be called very soon after the beginning of program execution.</p>
<p>Note that this does not enable the USB module (that is, does not set USB_EN bit). Rather, it prepares the USB module to detect the application of power to VBUS, after which the application may choose to enable the module and connect to USB. Calling this function is necessary to achieve expected LPM3 current consumption into DVCC.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dbd15fd1ebc2151234bc547e077c328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the USB Module and the Internal State of the API.</p>
<p>Resets the USB module and also the internal state of the API. The interrupt register is cleared to make sure no interrupts are pending. If the device had been enumerated, the enumeration is now lost. All open send/receive operations are aborted.</p>
<p>This function is most often called immediately before a call to <a class="el" href="group__usb__api.html#ga7e696d6c7aebf67e80d516bb15540758">USB_connect()</a>. It should not be called prior to <a class="el" href="group__usb__api.html#ga0ffd9c3457c34629eab6a735e735f956">USB_enable()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3bbc9d18b98daa76ebb4f76db748b6e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_resume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resume USB. </p>

</div>
</div>
<a class="anchor" id="gaa4a5b2a9dfa5fd1f2220cd44d6377590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_setEnabledEvents </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables/Disables the Various USB Events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>is the mask for what is to be enabled/disabled.<ul>
<li>Valid values are:<ul>
<li><b>USB_CLOCK_FAULT_EVENT</b> </li>
<li><b>USB_VBUS_ON_EVENT</b> </li>
<li><b>USB_VBUS_OFF_EVENT</b> </li>
<li><b>USB_RESET_EVENT</b> </li>
<li><b>USB_SUSPENDED_EVENT</b> </li>
<li><b>USB_RESUME_EVENT</b> </li>
<li><b>USB_DATA_RECEIVED_EVENT</b> </li>
<li><b>USB_SEND_COMPLETED_EVENT</b> </li>
<li><b>USB_RECEIVED_COMPLETED_EVENT</b> </li>
<li><b>USB_ALL_USB_EVENTS</b> </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Enables/disables various USB events. Within the events byte, all bits with '1' values will be enabled, and all bits with '0' values will be disabled. (There are no bit-wise operations). By default (that is, prior to any call to this function), all events are disabled.</p>
<p>The status of event enabling can be read with the <a class="el" href="group__usb__api.html#ga4594efa7c0946ea7e7c456b75a3e030b">USB_getEnabledEvents()</a> function. This call can be made at any time after a call to <a class="el" href="group__usb__api.html#ga3cffb725fc7ab389006f59edabf1271c">USB_init()</a>.</p>
<p><a class="el" href="group__usb__api.html#gaa4a5b2a9dfa5fd1f2220cd44d6377590">USB_setEnabledEvents()</a> can be thought of in a similar fashion to setting/clearing interrupt enable bits. The only benefit in keeping an event disabled is to save the unnecessary execution cycles incurred from running an "empty" event handler.</p>
<p>The mask constant <b>USB_ALL_USB_EVENTS</b> is used to enable/disable all events pertaining to core USB functions; in other words, it enables all those with a <b>kUSB_</b> prefix.</p>
<p>See Sec. 10 of <em>"Programmer's Guide: MSP430 USB API Stack for CDC/PHDC/HID/MSC"</em> for more information about events.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ga033508453c85c43e7bfca01d358b8396"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_setup </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>connectEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>eventsEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the USB Module. Also enables events and connects.</p>
<p>Initializes the USB module by configuring power and clocks, and configures pins that are critical for USB. This should be called very soon after the beginning of program execution.</p>
<p>If connectEnable is TRUE, then this API then enables the USB module, which includes activating the PLL and setting the USB_EN bit. AFter enabling the USB module, this API will connect to the host if VBUS is present.</p>
<p>If eventsEnable is set to TRUE then all USB events are enabled by this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connectEnable</td><td>If TRUE, Connect to host if VBUS is present by pulling the D+ signal high using the PUR pin. </td></tr>
    <tr><td class="paramname">eventsEnable</td><td>If TRUE, all USB events handlers are enabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ga63a8fcfe91b2ccc4ed6376bcfede2eaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_suspend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspend USB. </p>

</div>
</div>
<a class="anchor" id="gaa918350020f71ce5e1007d10ffbb4f94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t USBCDC_receiveDataInBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a Receive Operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which CDC interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>Opens a brief receive operation for any data that has already been received into the USB buffer over interface <b>intfNum</b>. This call only retrieves data that is already waiting in the USB buffer &ndash; that is, data that has already been received by the MCU. It assumes a previous, open receive operation (began by a direct call to USBxxx_receiveData()) is NOT underway on this interface; and no receive operation remains open after this call returns. It doesn't check for kUSBxxx_busNotAvailable, because it doesn't matter if it's not. The data in the USB buffer is copied into <b>dataBuf</b>, and the function returns the number of bytes received.</p>
<p><b>size</b> is the maximum that is allowed to be received before exiting; i.e., it is the size allotted to <b>dataBuf</b>. If <b>size</b> bytes are received, the function ends, returning <b>size</b>. In this case, it???s possible that more bytes are still in the USB buffer; it might be a good idea to open another receive operation to retrieve them. For this reason, operation is simplified by using large <b>size</b> values, since it helps ensure all the data is retrieved at one time.</p>
<p>This function is usually called when a <a class="el" href="group__event__handling__api.html#ga98dc93c9b8ff601d1b3f940c4c3430db">USBCDC_handleDataReceived()</a> event flags the application that data has been received into the USB buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received into <b>dataBuf</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e1e8fb53737e116b7d79d7aaff55727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBCDC_sendDataAndWaitTillDone </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completely Sends the Data in dataBuf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which interface is being used. </td></tr>
    <tr><td class="paramname">ulTimeout</td><td>is the (32-bit) number of polls to <a class="el" href="group__cdc__api.html#gaa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends the data in <b>dataBuf</b>, of size <b>size</b>, using the post-call polling method. It does so over interface <b>intfNum</b>. The function doesn???t return until the send has completed. Because of this, the user buffer can be edited immediately after the function returns, without consequence. The function assumes that size is non-zero. It assumes no previous send operation is underway.</p>
<p>The 32-bit number <b>ulTimeout</b> selects how many times <a class="el" href="group__cdc__api.html#gaa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a> will be polled while waiting for the operation to complete. If the value is zero, then no timeout is employed; it will wait indefinitely. When choosing a number, it is advised to consider MCLK speed, as a faster CPU will cycle through the calls more quickly. The function provides the simplest coding, at the expense of wasted cycles and potentially allowing MCU execution to become "locked" to the host, a disadvantage if the host (or bus) is slow.</p>
<p>The function also checks all valid return codes, and returns non-zero if an error occurred. In many applications, the return value can simply be evaluated as zero or non-zero, where nonzero means the call failed for reasons of host or bus non-availability. Therefore, it may desirable for the application to break from execution. Other applications may wish to handle return values 1 and 2 in different ways.</p>
<p>It???s recommended not to call this function from within an event handler. This is because if an interface currently has an open send operation, the operation will never complete during the event handler; rather, only after the ISR that spawned the event returns. Thus the <a class="el" href="group__cdc__api.html#gaa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a> polling would loop indefinitely (or timeout). It???s better to set a flag from within the event handler, and use this flag to trigger the calling of this function from within main().</p>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the call succeeded; all data has been sent. </dd>
<dd>
<b>1</b> if the call timed out, either because the host is unavailable or a COM port with an active application on the host wasn't opened. </dd>
<dd>
<b>2</b> if the bus is unavailable. </dd></dl>

</div>
</div>
<a class="anchor" id="ga368e1d92ce4965eca3dbd8d2fcc6a86a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBCDC_sendDataInBackground </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completely Sends the Data in dataBuf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which interface is being used. </td></tr>
    <tr><td class="paramname">ulTimeout</td><td>is the (32-bit) number of polls to <a class="el" href="group__cdc__api.html#gaa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends the data in <b>dataBuf</b>, of size <b>size</b>, using the pre-call polling method. It does so over interface <b>intfNum</b>. The send operation may still be active after the function returns, and <b>dataBuf</b> should not be edited until it can be verified that the operation has completed. The function assumes that size is non-zero. This call assumes a previous send operation might be underway.</p>
<p>The 32-bit number <b>ulTimeout</b> selects how many times <a class="el" href="group__cdc__api.html#gaa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a> will be polled while waiting for the previous operation to complete. If the value is zero, then no timeout is employed; it will wait indefinitely. When choosing a number, it is advised to consider MCLK speed, as a faster CPU will cycle through the calls more quickly. The function provides simple coding while also taking advantage of the efficiencies of background processing. If a previous send operation is underway, this function does waste cycles polling, like xxxsendDataWaitTilDone(); however it's less likely to do so since much of the sending presumably took place in the background since the last call to xxxsendDataInBackground().</p>
<p>The function also checks all valid return codes, and returns non-zero if an error occurred. In many applications, the return value can simply be evaluated as zero or non-zero, where nonzero means the call failed for reasons of host or bus non-availability. Therefore, it may desirable for the application to break from execution. Other applications may wish to handle return values 1 and 2 in different ways.</p>
<p>It???s recommended not to call this function from within an event handler. This is because if an interface currently has an open send operation, the operation will never complete during the event handler; rather, only after the ISR that spawned the event returns. Thus the <a class="el" href="group__cdc__api.html#gaa9ca9bf6dd62bafcdc5cdbe40de4f5d6">USBCDC_getInterfaceStatus()</a> polling would loop indefinitely (or timeout). It???s better to set a flag from within the event handler, and use this flag to trigger the calling of this function from within main().</p>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the call succeeded; all data has been sent. </dd>
<dd>
<b>1</b> if the call timed out, either because the host is unavailable or a COM port with an active application on the host wasn't opened. </dd>
<dd>
<b>2</b> if the bus is unavailable. </dd></dl>

</div>
</div>
<a class="anchor" id="ga78b76eb5ea08e2ae235ef3a3196b691a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t USBHID_receiveDataInBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a Receive Operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which HID interface is being used.</td></tr>
  </table>
  </dd>
</dl>
<p>Opens a brief receive operation for any data that has already been received into the USB buffer over interface <b>intfNum</b>. This call only retrieves data that is already waiting in the USB buffer &ndash; that is, data that has already been received by the MCU. It assumes a previous, open receive operation (began by a direct call to USBxxx_receiveData()) is NOT underway on this interface; and no receive operation remains open after this call returns. It doesn't check for kUSBxxx_busNotAvailable, because it doesn't matter if it's not. The data in the USB buffer is copied into <b>dataBuf</b>, and the function returns the number of bytes received.</p>
<p><b>size</b> is the maximum that is allowed to be received before exiting; i.e., it is the size allotted to <b>dataBuf</b>. If <b>size</b> bytes are received, the function ends, returning <b>size</b>. In this case, it???s possible that more bytes are still in the USB buffer; it might be a good idea to open another receive operation to retrieve them. For this reason, operation is simplified by using large <b>size</b> values, since it helps ensure all the data is retrieved at one time.</p>
<p>This function is usually called when a <a class="el" href="group__event__handling__api.html#ga68e55a31a4d5f2988a84f422697a4275">USBHID_handleDataReceived()</a> event flags the application that data has been received into the USB buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received into <b>dataBuf</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a08a1a448fa33c15b9aa5b7b737b000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHID_sendDataAndWaitTillDone </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completely Sends the Data in dataBuf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which HID interface is being used. </td></tr>
    <tr><td class="paramname">ulTimeout</td><td>is the (32-bit) number of polls to <a class="el" href="group__hid__api.html#ga519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends the data in <b>dataBuf</b>, of size <b>size</b>, using the post-call polling method. It does so over interface <b>intfNum</b>. The function doesn???t return until the send has completed. Because of this, the user buffer can be edited immediately after the function returns, without consequence. The function assumes that size is non-zero. It assumes no previous send operation is underway.</p>
<p>The 32-bit number <b>ulTimeout</b> selects how many times <a class="el" href="group__hid__api.html#ga519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a> will be polled while waiting for the operation to complete. If the value is zero, then no timeout is employed; it will wait indefinitely. When choosing a number, it is advised to consider MCLK speed, as a faster CPU will cycle through the calls more quickly. The function provides the simplest coding, at the expense of wasted cycles and potentially allowing MCU execution to become "locked" to the host, a disadvantage if the host (or bus) is slow.</p>
<p>The function also checks all valid return codes, and returns non-zero if an error occurred. In many applications, the return value can simply be evaluated as zero or non-zero, where nonzero means the call failed for reasons of host or bus non-availability. Therefore, it may desirable for the application to break from execution. Other applications may wish to handle return values 1 and 2 in different ways.</p>
<p>It's recommended not to call this function from within an event handler. This is because if an interface currently has an open send operation, the operation will never complete during the event handler; rather, only after the ISR that spawned the event returns. Thus the <a class="el" href="group__hid__api.html#ga519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a> polling would loop indefinitely (or timeout). It???s better to set a flag from within the event handler, and use this flag to trigger the calling of this function from within main().</p>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the call succeeded; all data has been sent. </dd>
<dd>
<b>1</b> if the call timed out, either because the host is unavailable or a COM port with an active application on the host wasn't opened. </dd>
<dd>
<b>2</b> if the bus is unavailable. </dd></dl>

</div>
</div>
<a class="anchor" id="gaef92f60053448b5c50f6dccca13534ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHID_sendDataInBackground </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completely Sends the Data in dataBuf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dataBuf</td><td>is the address of the data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data. </td></tr>
    <tr><td class="paramname">intfnum</td><td>intfNum is which HID interface is being used. </td></tr>
    <tr><td class="paramname">ulTimeout</td><td>is the (32-bit) number of polls to <a class="el" href="group__hid__api.html#ga519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends the data in <b>dataBuf</b>, of size <b>size</b>, using the pre-call polling method. It does so over interface <b>intfNum</b>. The send operation may still be active after the function returns, and <b>dataBuf</b> should not be edited until it can be verified that the operation has completed. The function assumes that size is non-zero. This call assumes a previous send operation might be underway.</p>
<p>The 32-bit number <b>ulTimeout</b> selects how many times <a class="el" href="group__hid__api.html#ga519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a> will be polled while waiting for the previous operation to complete. If the value is zero, then no timeout is employed; it will wait indefinitely. When choosing a number, it is advised to consider MCLK speed, as a faster CPU will cycle through the calls more quickly. The function provides simple coding while also taking advantage of the efficiencies of background processing. If a previous send operation is underway, this function does waste cycles polling, like xxxsendDataWaitTilDone(); however it's less likely to do so since much of the sending presumably took place in the background since the last call to xxxsendDataInBackground().</p>
<p>The function also checks all valid return codes, and returns non-zero if an error occurred. In many applications, the return value can simply be evaluated as zero or non-zero, where nonzero means the call failed for reasons of host or bus non-availability. Therefore, it may desirable for the application to break from execution. Other applications may wish to handle return values 1 and 2 in different ways.</p>
<p>It???s recommended not to call this function from within an event handler. This is because if an interface currently has an open send operation, the operation will never complete during the event handler; rather, only after the ISR that spawned the event returns. Thus the <a class="el" href="group__hid__api.html#ga519bd4bb60161b1a75574a7d3808d5c7">USBHID_getInterfaceStatus()</a> polling would loop indefinitely (or timeout). It???s better to set a flag from within the event handler, and use this flag to trigger the calling of this function from within main().</p>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the call succeeded; all data has been sent. </dd>
<dd>
<b>1</b> if the call timed out, either because the host is unavailable or a COM port with an active application on the host wasn't opened. </dd>
<dd>
<b>2</b> if the bus is unavailable. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
	<p>Copyright &#169; 2015, Texas Instruments Incorporated</p>	
    </li>
  </ul>
</div>
</body>
</html>
