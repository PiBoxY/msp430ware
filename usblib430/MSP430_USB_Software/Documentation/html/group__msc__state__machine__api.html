<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>MSP430USBDevelopersPackage_5_20_06_02: Msc_state_machine_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <img alt="Logo" width=25% src="ti_hz_2c_pos_rgb_png.png"/>
    <table cellspacing="0" cellpadding="0">
        <tbody>
        <tr style="height: 56px;">
            <td style="padding-left: 0.5em;">
                <div id="projectname">MSP430USBDevelopersPackage_5_20_06_02
                </div>
            </td>
        </tr>
        </tbody>
    </table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__msc__state__machine__api.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Msc_state_machine_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga29347df89b4f51072c3a857200370932"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msc__state__machine__api.html#ga29347df89b4f51072c3a857200370932">USBMSC_pollCommand</a> (void)</td></tr>
<tr class="separator:ga29347df89b4f51072c3a857200370932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f8641b3f646be16736c3229c5e4aca4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f8641b3f646be16736c3229c5e4aca4"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MSCToHostFromBuffer</b> ()</td></tr>
<tr class="separator:ga6f8641b3f646be16736c3229c5e4aca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf631270a83ea349b8956a47f40b9dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3cf631270a83ea349b8956a47f40b9dd"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>MSCFromHostToBuffer</b> ()</td></tr>
<tr class="separator:ga3cf631270a83ea349b8956a47f40b9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9073b4bdac1b9f9d5914db8ea73e9eef"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msc__state__machine__api.html#ga9073b4bdac1b9f9d5914db8ea73e9eef">USBMSC_processBuffer</a> (void)</td></tr>
<tr class="separator:ga9073b4bdac1b9f9d5914db8ea73e9eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb80b22430bd75cf1f37b5affdef45ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb80b22430bd75cf1f37b5affdef45ca"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>USBMSC_getState</b> ()</td></tr>
<tr class="separator:gadb80b22430bd75cf1f37b5affdef45ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf66debff3e4f3f3c3af3ed382ada2b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msc__state__machine__api.html#gafcf66debff3e4f3f3c3af3ed382ada2b">USBMSC_updateMediaInformation</a> (uint8_t lun, struct <a class="el" href="structUSBMSC__mediaInfoStr.html">USBMSC_mediaInfoStr</a> *info)</td></tr>
<tr class="separator:gafcf66debff3e4f3f3c3af3ed382ada2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2d592b1c20619da3a8732c1ed67f98"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msc__state__machine__api.html#gabb2d592b1c20619da3a8732c1ed67f98">USBMSC_registerBufferInformation</a> (uint8_t lun, uint8_t *RWbuf_x, uint8_t *RWbuf_y, uint16_t size)</td></tr>
<tr class="separator:gabb2d592b1c20619da3a8732c1ed67f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ed0c4cfc1444f8f68228d6963b8d8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga93ed0c4cfc1444f8f68228d6963b8d8b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>Scsi_Cmd_Parser</b> (uint8_t opcode)</td></tr>
<tr class="separator:ga93ed0c4cfc1444f8f68228d6963b8d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c8e7b35f9eae59538de12d2a3620bcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5c8e7b35f9eae59538de12d2a3620bcc"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>Scsi_Send_CSW</b> (uint8_t intfNum)</td></tr>
<tr class="separator:ga5c8e7b35f9eae59538de12d2a3620bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3369e7af08ae2106c22b4f8195493b14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3369e7af08ae2106c22b4f8195493b14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Msc_ResetStateMachine</b> (void)</td></tr>
<tr class="separator:ga3369e7af08ae2106c22b4f8195493b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a145349c0ecdf5ffebd38bdfff29e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab3a145349c0ecdf5ffebd38bdfff29e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Msc_ResetFlags</b> (void)</td></tr>
<tr class="separator:gab3a145349c0ecdf5ffebd38bdfff29e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0331424064e682feab84956549a76d24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0331424064e682feab84956549a76d24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Msc_ResetStruct</b> (void)</td></tr>
<tr class="separator:ga0331424064e682feab84956549a76d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3205e6264bf18fd9a49c7ce7f9088030"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3205e6264bf18fd9a49c7ce7f9088030"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SET_RequestsenseNotReady</b> (void)</td></tr>
<tr class="separator:ga3205e6264bf18fd9a49c7ce7f9088030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b615fb6fb4fa5ad003fd3e96bec1bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga44b615fb6fb4fa5ad003fd3e96bec1bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SET_RequestsenseMediaNotPresent</b> (void)</td></tr>
<tr class="separator:ga44b615fb6fb4fa5ad003fd3e96bec1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ac820a5ef88517bd256501f49d8048"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae0ac820a5ef88517bd256501f49d8048"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MscResetCtrlLun</b> (void)</td></tr>
<tr class="separator:gae0ac820a5ef88517bd256501f49d8048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52c5e8c280065396de50e904fc27c8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUSBMSC__RWbuf__Info.html">USBMSC_RWbuf_Info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msc__state__machine__api.html#gad52c5e8c280065396de50e904fc27c8b">USBMSC_fetchInformationStructure</a> (void)</td></tr>
<tr class="separator:gad52c5e8c280065396de50e904fc27c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad52c5e8c280065396de50e904fc27c8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUSBMSC__RWbuf__Info.html">USBMSC_RWbuf_Info</a>* USBMSC_fetchInformationStructure </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the <b>USBMSC_Rwbuf_Info</b> structure instance maintained within the API.</p>
<p>Returns a pointer to the <b>USBMSC_Rwbuf_Info</b> structure instance maintained within the API. See Sec. 8.3.6 of <em>"Programmer's Guide: MSP430 USB API Stack for CDC/PHDC/HID/MSC"</em> for information on using this structure. This function should be called prior to USB enumeration; that is, prior to calling <a class="el" href="group__usb__api.html#ga7e696d6c7aebf67e80d516bb15540758">USB_connect()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an application-allocated instance of <b>USBMSC_RWBuf_Info</b>, which will be used to exchange information related to buffer requests from the API to the application. </dd></dl>

</div>
</div>
<a class="anchor" id="ga29347df89b4f51072c3a857200370932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBMSC_pollCommand </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to See if a SCSI Command has Been Received.</p>
<p>Checks to see if a SCSI command has been received. If so, it handles it. If not, it returns having taken no action. The return values of this function are intended to be used with entry of low-power modes. If the function returns <b>USBMSC_OK_TO_SLEEP</b>, then no further application action is required; that is, either no SCSI command was received; one was received but immediately handled; or one was received but the handling will be completed in the background by the API as it automatically services USB interrupts. If instead the function returns <b>USBMSC_PROCESS_BUFFER</b>, then the API is currently servicing a SCSI READ or WRITE command, and the API requires the application to process a buffer. (See Sec. 8.3.6 of <em>"Programmer's Guide: MSP430 USB API Stack for CDC/PHDC/HID/MSC"</em> for a discussion of buffer processing.) Note that even if the function returns these values, the values could potentially be outdated by the time the application evaluates them. For this reason, it's important to disable interrupts prior to calling this function. See Sec. 8.3.5 of <em>"Programmer's Guide: MSP430 USB API Stack for CDC/PHDC/HID/MSC"</em> for more information.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USBMSC_OK_TO_SLEEP</b> or <b>USBMSC_PROCESS_BUFFER</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9073b4bdac1b9f9d5914db8ea73e9eef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBMSC_processBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called by the application after it has processed a buffer request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">USBMSC_Rwbuf_Info*RWBufInfo</td><td>Pass the value received from <a class="el" href="group__msc__state__machine__api.html#gad52c5e8c280065396de50e904fc27c8b">USBMSC_fetchInformationStructure()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called by the application after it has processed a buffer request. It indicates to the API that the application has fulfilled the request. Prior to calling this function, the application needs to write a return code to rwInfo.returnCode. This code should reflect the result of the operation. The value may come from the file system software, depending on the application. See Sec. 8.3.6 of <em>"Programmer's Guide: MSP430 USB API Stack for CDC/PHDC/HID/MSC"</em> for a list of valid return codes.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
<a class="anchor" id="gabb2d592b1c20619da3a8732c1ed67f98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBMSC_registerBufferInformation </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>RWbuf_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>RWbuf_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the API a Buffer to Use for READ/WRITE Data Transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>is the Lun number. </td></tr>
    <tr><td class="paramname">*RWbuf_x</td><td>is the address of an X-buffer. If null, then both buffers are de-activated. </td></tr>
    <tr><td class="paramname">*RWbuf_y</td><td>is the address of an Y-buffer. (Double-buffering is not supported in this version of the API.) </td></tr>
    <tr><td class="paramname">size</td><td>is the size, in bytes, of the buffers.</td></tr>
  </table>
  </dd>
</dl>
<p>Gives the API a buffer to use for READ/WRITE data transfer. <b>size</b> indicates the size of the buffer, in bytes.</p>
<p><b>NOTE:</b> Currently, only single-buffering is supported, so <b>RWbuf_y</b> should be set to null. If the application intends to allocate the buffer statically, then this function needs only to be called once, prior to any READ/WRITE commands being received from the host. Most likely this would happen during the application's initialization functions.</p>
<p><b>NOTE:</b> This API has to be called after the call to <a class="el" href="group__msc__state__machine__api.html#gafcf66debff3e4f3f3c3af3ed382ada2b">USBMSC_updateMediaInformation()</a> at the beginning of execution.</p>
<p>However, this function optionally enables dynamic buffer management. That is, it can activate and de-activate the buffer, by alternately assigning a null and valid address in <b>RWbuf_x</b>. This is useful because the buffer uses a significant portion of the RAM resources (typically 512 bytes). This memory is not needed when USB is not attached or suspended.</p>
<p>If doing this, it's important that the application re-activate the buffer when USB becomes active again, by issuing another call to the function, this time using valid buffer information. If the API needs the buffer and doesn't have it, it will begin failing READ/WRITE commands from the host. The re-activation can take place within <a class="el" href="group__event__handling__api.html#ga580415450cd23137ccd79fdc23134f30">USB_handleVbusOffEvent()</a>.</p>
<p><b>size</b> must be a multiple of a block size - for FAT, a block size is typically 512 bytes. Thus values of 512, 1024, 1536, etc. are valid. Non-multiples are not valid.</p>
<p>The function returns <b>USB_SUCCEED</b> every time. It is up to the application to ensure that the buffers are valid.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
<a class="anchor" id="gafcf66debff3e4f3f3c3af3ed382ada2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBMSC_updateMediaInformation </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structUSBMSC__mediaInfoStr.html">USBMSC_mediaInfoStr</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Informs the API of the Current State of the Media on LUN <b>lun</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>is the logical unit (LUN) on which the operation is taking place. Zero-based. (This version of the API only supports a single LUN.) </td></tr>
    <tr><td class="paramname">info</td><td>is a structure that communicates the most recent information about the medium.</td></tr>
  </table>
  </dd>
</dl>
<p>Informs the API of the current state of the media on LUN <b>lun</b>. It does this using an instance <b>info</b> of the API-defined structure <a class="el" href="structUSBMSC__mediaInfoStr.html">USBMSC_mediaInfoStr</a>. The API uses the information in the most recent call to this function in automatically handling certain requests from the host. In LUNs that are marked as not removable in USBMSC_CONFIG, this function should be called once at the beginning of execution, prior to attachment to the USB host. It then no longer needs to be called.</p>
<p>In LUNS that are marked as removable, the media information is dynamic. The function should still be called at the beginning of execution to indicate the initial state of the media, and then it should also be called every time the media changes.</p>
<p>See Sec. 8.3.4 of <em>"Programmer's Guide: MSP430 USB API Stack for CDC/PHDC/HID/MSC"</em> for more about informing the API of media changes.</p>
<dl class="section return"><dt>Returns</dt><dd><b>USB_SUCCEED</b> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
	<p>Copyright &#169; 2015, Texas Instruments Incorporated</p>	
    </li>
  </ul>
</div>
</body>
</html>
