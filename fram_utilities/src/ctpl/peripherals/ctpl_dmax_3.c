/* --COPYRIGHT--,FRAM-Utilities
 * Copyright (c) 2015, Texas Instruments Incorporated
 * All rights reserved.
 *
 * This source code is part of FRAM Utilities for MSP430 FRAM Microcontrollers.
 * Visit http://www.ti.com/tool/msp-fram-utilities for software information and
 * download.
 * --/COPYRIGHT--*/
#include <msp430.h>

#if defined(__MSP430FR2XX_4XX_FAMILY__) && !defined(__AUTOGENERATED__)
#include <msp430fr2xx_4xxgeneric.h>
#elif defined(__MSP430FR57XX_FAMILY__) && !defined(__AUTOGENERATED__)
#include <msp430fr57xxgeneric.h>
#elif defined(__MSP430FR5XX_6XX_FAMILY__) && !defined(__AUTOGENERATED__)
#include <msp430fr5xx_6xxgeneric.h>
#endif

#ifdef __MSP430_HAS_DMAX_3__

#include <stdint.h>

#include "ctpl_dmax_3.h"
#include "ctpl_hwreg.h"
#include "../ctpl_low_level.h"

void ctpl_DMAX_3_save(uint16_t baseAddress, uint16_t *storage, uint16_t mode)
{
    /* Save register context to non-volatile storage. */
    storage[20] = HWREG16(baseAddress + OFS_DMA2CTL);
    storage[19] = HWREG16(baseAddress + OFS_DMA2SZ);
    *(uint32_t *)&(storage[17]) = __data16_read_addr(baseAddress + OFS_DMA2DA);
    *(uint32_t *)&(storage[15]) = __data16_read_addr(baseAddress + OFS_DMA2SA);
    storage[14] = HWREG16(baseAddress + OFS_DMA1CTL);
    storage[13] = HWREG16(baseAddress + OFS_DMA1SZ);
    *(uint32_t *)&(storage[11]) = __data16_read_addr(baseAddress + OFS_DMA1DA);
    *(uint32_t *)&(storage[9])  = __data16_read_addr(baseAddress + OFS_DMA1SA);
    storage[8]  = HWREG16(baseAddress + OFS_DMA0CTL);
    storage[7]  = HWREG16(baseAddress + OFS_DMA0SZ);
    *(uint32_t *)&(storage[5])  = __data16_read_addr(baseAddress + OFS_DMA0DA);
    *(uint32_t *)&(storage[3])  = __data16_read_addr(baseAddress + OFS_DMA0SA);
    storage[2]  = HWREG16(baseAddress + OFS_DMACTL4);
    storage[1]  = HWREG16(baseAddress + OFS_DMACTL1);
    storage[0]  = HWREG16(baseAddress + OFS_DMACTL0);

    return;
}

void ctpl_DMAX_3_restore(uint16_t baseAddress, uint16_t *storage, uint16_t mode)
{
    /* Restore register context from non-volatile storage. */
    HWREG16(baseAddress + OFS_DMACTL0)    = storage[0];
    HWREG16(baseAddress + OFS_DMACTL1)    = storage[1];
    HWREG16(baseAddress + OFS_DMACTL4)    = storage[2];
    __data16_write_addr((baseAddress + OFS_DMA0SA), *(uint32_t *)&(storage[3]));
    __data16_write_addr((baseAddress + OFS_DMA0DA), *(uint32_t *)&(storage[5]));
    HWREG16(baseAddress + OFS_DMA0SZ)     = storage[7];
    HWREG16(baseAddress + OFS_DMA0CTL)    = storage[8];
    __data16_write_addr((baseAddress + OFS_DMA1SA), *(uint32_t *)&(storage[9]));
    __data16_write_addr((baseAddress + OFS_DMA1DA), *(uint32_t *)&(storage[11]));
    HWREG16(baseAddress + OFS_DMA1SZ)     = storage[13];
    HWREG16(baseAddress + OFS_DMA1CTL)    = storage[14];
    __data16_write_addr((baseAddress + OFS_DMA2SA), *(uint32_t *)&(storage[15]));
    __data16_write_addr((baseAddress + OFS_DMA2DA), *(uint32_t *)&(storage[17]));
    HWREG16(baseAddress + OFS_DMA2SZ)     = storage[19];
    HWREG16(baseAddress + OFS_DMA2CTL)    = storage[20];

    return;
}

#endif //__MSP430_HAS_DMAX_3__
