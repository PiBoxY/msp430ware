/*******************************************************************************
 * Copyright (c) ${year} Texas Instruments Incorporated - http://www.ti.com/
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Texas Instruments Incorporated - initial API and implementation
 *
 * Original Author:
 *     Boualem, Texas Instruments, Inc.
 *
 * Contributing Authors:
 *
 *******************************************************************************/
 
var __DEBUG_MODE = false;

var fs = require('fs');
var urlModule = require('url');
var dns = require('dns');

var endOfLine = "\r\n";
var length = 0;
var boundary = '-----np' + Math.random();
var buffer2Send = [];
var name = '';
var stats;
var contentType = 'multipart/form-data; boundary=' + boundary;


/* ===============================================
 * exported function
 * =============================================== */
module.exports = function (url, files, callbackFunction)
{
    consoleDebug("http.post entering");
    if (files.length && typeof (files) != 'undefined')
    {
        for (var file in files)
        {
            if (fs.existsSync(files[file].path))
            {
                // compute the name
                if (isString(files[file].name))
                {
                    name = files[file].name
                }
                else
                {
                    name = files[file].path.replace(/\\/g, '/').replace(/.*\//, '');
                }

                // Determine file size
                stats = fs.statSync(files[file].path);
                files[file].length = stats.size;

                buffer2Send.push('--' + boundary + endOfLine);
                buffer2Send.push('Content-Disposition: form-data; name="' + files[file].param + '"; filename="' + name + '"' + endOfLine);

                buffer2Send.push(endOfLine);
                buffer2Send.push(files[file]);
            }
        }

        // Add the last multipart terminator
        buffer2Send.push('--' + boundary + '--' + endOfLine);

        // Determine the total size of buffer2Send
        for (var i in buffer2Send)
        {
            length += buffer2Send[i].length;
        }


    }


    if (!isFunction(callbackFunction))
    {
        callbackFunction = function () {};
    }

    var proxied;
    if (process.versions['node-webkit'])
    {
        var gui = global.window.nwDispatcher.requireNwGui();
        proxied = gui.App.getProxyForURL(url);

        var options;
        if (proxied == 'DIRECT')
        {
            consoleDebug("nw App: DIRECT post");
            if (isString(url))
            {
                options = urlModule.parse(url);
                fillOptions(options);
                executePostRequest(options, callbackFunction, files);
            }
        }
        else
        {
            consoleDebug("nw App: Proxied post");
            // remove the leading characters 'PROXY '
            var proxyURL = proxied.replace('PROXY ', 'http://');

            var proxyOptions = urlModule.parse(proxyURL);
            var proxyHostName = proxyOptions.hostname;

            // lookup the IP Address of the proxy
            dns.lookup(proxyHostName, function (error, ipAddress4Proxy)
            {
                //logger.info
                consoleDebug("ipAddress4Proxy=" + ipAddress4Proxy);
                consoleDebug("error=" + error);

                if (!error || error == null)
                {

                    options = {
                        host: ipAddress4Proxy, // proxy IP
                        port: proxyOptions.port, // proxy port
                        path: url, // use the URL as path
                        protocol: "http:",
                    };

                    fillOptions(options);
                    executePostRequest(options, callbackFunction, files);
                }
            });

        }
        consoleDebug("Proxied URL=" + proxied);
    }
    else
    {
        //var proxy1 = process.env.http_proxy;
        //consoleDebug("process.env.http_proxy=" + proxy1);

        // we assume no proxy since it's a node app
        consoleDebug("node app: DIRECT post");
        if (isString(url))
        {
            options = urlModule.parse(url);
            fillOptions(options);
            executePostRequest(options, callbackFunction, files);
        }
    }



}

/* ===============================================
 * executePostRequest
 * =============================================== */
function executePostRequest(options, callbackFunction, files)
{
    try
    {
        var request = require('http').request(options, function (responce)
        {
            responce.on('data', function (chunk)
            {
                consoleDebug('response: ' + chunk);

                if (chunk.toString().indexOf("uploaded 1 file") < 0)
                {
                    // no file has been uploaded
                    callbackFunction(new Error("The file upload failed:  " + chunk.toString()));
                }


            });
            callbackFunction(responce);
        });

        request.on('error', function (e)
        {
            consoleDebug("executePostRequestrequest.on('error',f(e)): problem with request: " + e.message);
            consoleDebug(e);
            callbackFunction(e);
        });

        if (files.length)
        {
            for (var k in buffer2Send)
            {
                if (isString(buffer2Send[k]))
                {
                    request.write(buffer2Send[k]);
                }
                else
                {
                    request.write(fs.readFileSync(buffer2Send[k].path, 'binary'));
                    request.write(endOfLine);
                }
            }
        }

        request.end();
    }
    catch (err)
    {
        consoleDebug(err);
    }

}

/* ===============================================
 * fillOptions
 * =============================================== */
function fillOptions(options)
{
    options.headers = {
        'Content-Type': contentType,
        'Content-Length': length
    };
    options.method = 'POST';
    consoleDebug(options);
}

/* ===============================================
 * consoleDebug
 * =============================================== */
function consoleDebug(message)
{
    if (__DEBUG_MODE)
    {
        console.log(message);
    }
}

/* ===============================================
 * isString
 * =============================================== */
function isString(s)
{
    if (s === undefined || s === null)
    {
        return false;
    }

    //return (typeof s == 'string' || s instanceof String) //s.constructor===String;
    return (Object.prototype.toString.call(s) === '[object String]');

};

/* ===============================================
 * isFunction
 * =============================================== */
function isFunction(f)
{
    if (f === undefined || f === null)
    {
        return false;
    }

    return (Object.prototype.toString.call(f) === '[object Function]');
};


/* ===============================================
 * isError
 * =============================================== */
function isError(error)
{
    if (error === undefined && error === null)
    {
        return false;
    }

    return (Object.prototype.toString.call(error) === '[object Error]');
}