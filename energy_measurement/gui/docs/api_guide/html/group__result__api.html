<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>Result_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Result_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1834214615fdf22f3c4b3cd6c6dc8b0c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga1834214615fdf22f3c4b3cd6c6dc8b0c">EM_voltageDCFilter</a> (int32_t *p, int16_t x)</td></tr>
<tr class="memdesc:ga1834214615fdf22f3c4b3cd6c6dc8b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is intended for the removal of the DC content from 16 bit 50Hz/60Hz mains signals. All samples should be passed through the filter, in sequence, to obtain a signal free of DC content. The estimation is based on a noise shaped single pole LPF.The cutoff frequency of this filter is set very low, so its gain is essentially flat from 45Hz upwards. This means the filter can take several seconds to stabilize when the signal is initially applied.  <a href="#ga1834214615fdf22f3c4b3cd6c6dc8b0c">More...</a><br /></td></tr>
<tr class="separator:ga1834214615fdf22f3c4b3cd6c6dc8b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a88a65cef272e566d228b833fb1637"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga00a88a65cef272e566d228b833fb1637">EM_currentDCFilter</a> (int16_t p[3], int32_t x)</td></tr>
<tr class="memdesc:ga00a88a65cef272e566d228b833fb1637"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is intended for the removal of the DC content from 24 bit 50Hz/60Hz mains signals. All samples should be passed through the filter, in sequence, to obtain a signal free of DC content. The estimation is based on a noise shaped single pole LPF.The cutoff frequency of this filter is set very low, so its gain is essentially flat from 45Hz upwards. This means the filter can take several seconds to stabilize when the signal is initially applied.  <a href="#ga00a88a65cef272e566d228b833fb1637">More...</a><br /></td></tr>
<tr class="separator:ga00a88a65cef272e566d228b833fb1637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f9c190a63d2e367c421c770c23a7d21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga8f9c190a63d2e367c421c770c23a7d21">EM_perSample</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase, <a class="el" href="em_sw_lib_8h.html#a7880bb724e609f02cb3d6a0413e2d5b1">EM_Phase_BG_Results</a> *bgData)</td></tr>
<tr class="memdesc:ga8f9c190a63d2e367c421c770c23a7d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used update the previous voltage value for a phase and to increment the number of samples processed in the ISR. This API must be called inside the ISR after all the background APIs are executed for a phase.  <a href="#ga8f9c190a63d2e367c421c770c23a7d21">More...</a><br /></td></tr>
<tr class="separator:ga8f9c190a63d2e367c421c770c23a7d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6628dae04ad34378c448fb2de928e6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gad6628dae04ad34378c448fb2de928e6f">EM_perDataChunk</a> (<a class="el" href="em_sw_lib_8h.html#a837b6a11e53dcd5688fb2c05420e4ff9">EM_SW_Lib_Config_Handle</a> *config, <a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *result, uint16_t phaseIdx)</td></tr>
<tr class="memdesc:gad6628dae04ad34378c448fb2de928e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to swap the metrology ping and pong pointers. This API must be executed after the Frequency Function has processed N number of cycles (where N = config-&gt;algoConfig-&gt;mainNomFreq). The Metrology Ping struc is the buffer updated in the ISR, and Metrology Pong struct is used by the foreground APIs.  <a href="#gad6628dae04ad34378c448fb2de928e6f">More...</a><br /></td></tr>
<tr class="separator:gad6628dae04ad34378c448fb2de928e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade3085e201967bbf7770ce88765ca5fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gade3085e201967bbf7770ce88765ca5fb">EM_delayCurrent90Degrees</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase, <a class="el" href="em_sw_lib_8h.html#a7880bb724e609f02cb3d6a0413e2d5b1">EM_Phase_BG_Results</a> *bgData)</td></tr>
<tr class="memdesc:gade3085e201967bbf7770ce88765ca5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to delay the current degree by 90 degrees. It uses an IIR filter with 1 pole to shift current: (all pass 90 degree filter for w = PI*f/fs, f=signal freq and fs = sampling frequency) I90(IDX0 = I(IDX-1)+G*[I(IDX) - I90(IDX-1)] G = (tan(w) - 1)/(tan(w) + 1) The G constant used by the filter is based on signal frequency which is updated ~ once a second. It updates metro Result structure; storing the temporary multiply accumulate (MAC) calculations.  <a href="#gade3085e201967bbf7770ce88765ca5fb">More...</a><br /></td></tr>
<tr class="separator:gade3085e201967bbf7770ce88765ca5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218995a1fda2a83454aaa7ae83db94ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga218995a1fda2a83454aaa7ae83db94ac">EM_genPulseIndPhase</a> (<a class="el" href="em_sw_lib_8h.html#a85eac103503a6527fda74bf2bbb2e225">EM_System_Configuration</a> *config, <a class="el" href="em_sw_lib_8h.html#a5e7d7de3e9ae6ce0c56c199516333ef4">EM_Pulse_Settings</a> *pulse, <a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result)</td></tr>
<tr class="memdesc:ga218995a1fda2a83454aaa7ae83db94ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to generate pulses for an individual phase. This API checks if the config-&gt;pulseGeneration has the result-&gt; phaseID set. If is set then it will generate EM_PHASE_IMP_PER_KWHR impulses per kWhr. This API requires that the pulse settings are initialized for the activePulse and reactivePulse Port/Pins.  <a href="#ga218995a1fda2a83454aaa7ae83db94ac">More...</a><br /></td></tr>
<tr class="separator:ga218995a1fda2a83454aaa7ae83db94ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24aa9c669d32d27306a840ad9d196efe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga24aa9c669d32d27306a840ad9d196efe">EM_genPulseTotalPhases</a> (<a class="el" href="em_sw_lib_8h.html#a85eac103503a6527fda74bf2bbb2e225">EM_System_Configuration</a> *config, <a class="el" href="em_sw_lib_8h.html#a5e7d7de3e9ae6ce0c56c199516333ef4">EM_Pulse_Settings</a> *pulse, <a class="el" href="em_sw_lib_8h.html#ae3e8e409f282157e47284db0105b45cd">EM_Total_Results</a> *result)</td></tr>
<tr class="memdesc:ga24aa9c669d32d27306a840ad9d196efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to generate pulses for the total phase. This API checks if the config-&gt;pulseGeneration has EM_PULSE_GEN_PHASE_AGGREGATE set. If is set then it will generate EM_PHASE_IMP_PER_KWHR impulses per kWhr. This API requires that the pulse settings are initialized for the activePulse and reactivePulse Port/Pins.  <a href="#ga24aa9c669d32d27306a840ad9d196efe">More...</a><br /></td></tr>
<tr class="separator:ga24aa9c669d32d27306a840ad9d196efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga147110de9d95fdf71c193ce2cd9baf05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga147110de9d95fdf71c193ce2cd9baf05">EM_updateOneDivSC</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro)</td></tr>
<tr class="memdesc:ga147110de9d95fdf71c193ce2cd9baf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the 1/sample_count constant. This function must be executed after EM_perDataChunk API for each phase inside the foreground code. The 1/sample_count constant will be used to calculate the results parameters.  <a href="#ga147110de9d95fdf71c193ce2cd9baf05">More...</a><br /></td></tr>
<tr class="separator:ga147110de9d95fdf71c193ce2cd9baf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7163797e2a70de44e78d47da27e7faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gac7163797e2a70de44e78d47da27e7faf">EM_clearMetrology</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro)</td></tr>
<tr class="memdesc:gac7163797e2a70de44e78d47da27e7faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to clear the temporary variables inside the metro structure. This API must be called as the last API in the foreground code.  <a href="#gac7163797e2a70de44e78d47da27e7faf">More...</a><br /></td></tr>
<tr class="separator:gac7163797e2a70de44e78d47da27e7faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ffe9a979a07cf06d9b1ebb0442cca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga21ffe9a979a07cf06d9b1ebb0442cca9">EM_updateReactPowConst</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result, <a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *algo)</td></tr>
<tr class="memdesc:ga21ffe9a979a07cf06d9b1ebb0442cca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to look up the IIR G constant used to calculate the Reactive Power using the current frequency value. The index of the G constant in the reactPowIIRTable is calculated: index = (Current Frequency - reactPowIIRMinFreq) &gt;&gt; reactPowIIRShift if the index is &gt; reactPowIIRLength, then index = reactPowIIRLength.  <a href="#ga21ffe9a979a07cf06d9b1ebb0442cca9">More...</a><br /></td></tr>
<tr class="separator:ga21ffe9a979a07cf06d9b1ebb0442cca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9d4ea4efa8e5b8317d2b2a4e2dd0403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="em_sw_lib_8h.html#a49eed1476cbc4d90c0ef3708bf776f28">EM_message_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gaa9d4ea4efa8e5b8317d2b2a4e2dd0403">EM_processSample</a> (<a class="el" href="em_sw_lib_8h.html#a837b6a11e53dcd5688fb2c05420e4ff9">EM_SW_Lib_Config_Handle</a> *config)</td></tr>
<tr class="memdesc:gaa9d4ea4efa8e5b8317d2b2a4e2dd0403"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used process the samples. It is used to calculate intermediate dot product results that are fed into the foreground process for the calculation of metrology readings.  <a href="#gaa9d4ea4efa8e5b8317d2b2a4e2dd0403">More...</a><br /></td></tr>
<tr class="separator:gaa9d4ea4efa8e5b8317d2b2a4e2dd0403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56ee9d70b0dc6fbc6fb26117e4eff4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gaa56ee9d70b0dc6fbc6fb26117e4eff4a">EM_calcActivePowerMultAcc</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase)</td></tr>
<tr class="memdesc:gaa56ee9d70b0dc6fbc6fb26117e4eff4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the dot product and accumulation of Voltage and Current. This API reads the current and voltage values using the phase structure.It updates metro Result structure; storing the temporary multiply accumulate (MAC) calculations. The MAC value is used by the foreground function EM_calcActivePowerDiv to calculate Active Power.  <a href="#gaa56ee9d70b0dc6fbc6fb26117e4eff4a">More...</a><br /></td></tr>
<tr class="separator:gaa56ee9d70b0dc6fbc6fb26117e4eff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fab4b120d32a9c122b8bdf74d83276a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga2fab4b120d32a9c122b8bdf74d83276a">EM_calcActivePowerDiv</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase, <a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result, <a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *algo)</td></tr>
<tr class="memdesc:ga2fab4b120d32a9c122b8bdf74d83276a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the active power in the foreground code and store activePower in the result structure. The formula used: (metro-&gt;AP_dot_prod-&gt;P_accum x metro-&gt;oneDivSC) x phase-&gt;phaseCalibPtr-&gt;activePowerSF If the activePower calculated is less than algo-&gt;residualPowerCutoff then activePower will be set to 0.  <a href="#ga2fab4b120d32a9c122b8bdf74d83276a">More...</a><br /></td></tr>
<tr class="separator:ga2fab4b120d32a9c122b8bdf74d83276a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c43e46165cf16d27fb854d331066ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga3c43e46165cf16d27fb854d331066ccd">EM_calcActiveEnergy</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *algo, <a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result)</td></tr>
<tr class="memdesc:ga3c43e46165cf16d27fb854d331066ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the active energy result. The formula used to calculate activeEnergy (uWh): (result-&gt;activePower x metro-&gt;sampleCount) x energyCalcConst Where energyCalcConst = (1/(sampling freq x 3600)) This API must be called after EM_calcActivePowerDiv.  <a href="#ga3c43e46165cf16d27fb854d331066ccd">More...</a><br /></td></tr>
<tr class="separator:ga3c43e46165cf16d27fb854d331066ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae958917049f27a3a3eb4fccba9586d45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gae958917049f27a3a3eb4fccba9586d45">EM_calcReactivePowerMultAcc</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase, <a class="el" href="em_sw_lib_8h.html#a7880bb724e609f02cb3d6a0413e2d5b1">EM_Phase_BG_Results</a> *bgData)</td></tr>
<tr class="memdesc:gae958917049f27a3a3eb4fccba9586d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the dot product and accumulation of Voltage_90 and Current. This API reads the current and voltage values using the phase structure.It uses an IIR filter with 1 pole to shift the the voltage 90 degrees: (all pass 90 degree filter for w = PI*f/fs, f=signal freq and fs = sampling frequency) V90(IDX0 = V(IDX-1)+G*[V(IDX) - V90(IDX-1)] G = (tan(w) - 1)/(tan(w) + 1) The G constant used by the filter is based on signal frequency which is updated ~ once a second. It updates metro Result structure; storing the temporary multiply accumulate (MAC) calculations. The MAC value is used by the foreground function EM_calcReactivePowerDiv to calculate Reactive Power.  <a href="#gae958917049f27a3a3eb4fccba9586d45">More...</a><br /></td></tr>
<tr class="separator:gae958917049f27a3a3eb4fccba9586d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8479a9975c6370e31638c460260eaa48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga8479a9975c6370e31638c460260eaa48">EM_calcReactivePowerDiv</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase, <a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result, <a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *algo)</td></tr>
<tr class="memdesc:ga8479a9975c6370e31638c460260eaa48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the reactive power in the foreground code and store reactivePower in the result structure. The formula used: (metro-&gt;RP_dot_prod-&gt;P_accum x metro-&gt;oneDivSC) x phase-&gt;phaseCalibPtr-&gt;reactivePowerSF If the reactivePower calculated is less than algo-&gt;residualPowerCutoff then reactivePower will be set to 0.  <a href="#ga8479a9975c6370e31638c460260eaa48">More...</a><br /></td></tr>
<tr class="separator:ga8479a9975c6370e31638c460260eaa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da326b0f5b3e27e695253144a11cb64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga4da326b0f5b3e27e695253144a11cb64">EM_calcReactiveEnergy</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *algo, <a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result)</td></tr>
<tr class="memdesc:ga4da326b0f5b3e27e695253144a11cb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the reactive energy result. The formula used to calculate reactiveEnergy (uVArh): (result-&gt;reactivePower x metro-&gt;sampleCount) x energyCalcConst Where energyCalcConst = (1/(sampling freq x 3600)) This API must be called after EM_calcReactivePowerDiv.  <a href="#ga4da326b0f5b3e27e695253144a11cb64">More...</a><br /></td></tr>
<tr class="separator:ga4da326b0f5b3e27e695253144a11cb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13adade3e66abf65c11c9535e712d9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga13adade3e66abf65c11c9535e712d9be">EM_calcApparentPower</a> (<a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result)</td></tr>
<tr class="memdesc:ga13adade3e66abf65c11c9535e712d9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate apparent power. The formula used to calculate apparentPower (uVA): Sqrt Root (result-&gt;activePower ^ 2 + result-&gt;reactivePower ^ 2) This API must be called after EM_calcActivePowerMultAcc and EM_calcReactivePowerMultAcc.  <a href="#ga13adade3e66abf65c11c9535e712d9be">More...</a><br /></td></tr>
<tr class="separator:ga13adade3e66abf65c11c9535e712d9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa636506ae0691a1e990a8d7a034f5672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gaa636506ae0691a1e990a8d7a034f5672">EM_calcApparentEnergy</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *algo, <a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result)</td></tr>
<tr class="memdesc:gaa636506ae0691a1e990a8d7a034f5672"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the apparent energy result. The formula used to calculate apparentEnergy (uVAh): (result-&gt;apparentPower x metro-&gt;sampleCount) x energyCalcConst Where energyCalcConst = (1/(sampling freq x 3600)) This API must be called after EM_calcApparentPower.  <a href="#gaa636506ae0691a1e990a8d7a034f5672">More...</a><br /></td></tr>
<tr class="separator:gaa636506ae0691a1e990a8d7a034f5672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a2a50263682af4c16b3d17e3ee25a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga63a2a50263682af4c16b3d17e3ee25a8">EM_calcPowerFactor</a> (<a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result)</td></tr>
<tr class="memdesc:ga63a2a50263682af4c16b3d17e3ee25a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate power factor. The formula used to calculate it: activePower / apparentPower This API must be called after EM_calcActivePowerMultAcc and EM_calcApparentPower.  <a href="#ga63a2a50263682af4c16b3d17e3ee25a8">More...</a><br /></td></tr>
<tr class="separator:ga63a2a50263682af4c16b3d17e3ee25a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef08801742aee1da976354b529cc4e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gaef08801742aee1da976354b529cc4e79">EM_calcVRMSMultAcc</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase)</td></tr>
<tr class="memdesc:gaef08801742aee1da976354b529cc4e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the dot product and accumulation for VRMS. This API reads the voltage value from the voltage ptr in the phase structure and updates the Metro Result structure; storing the temporary multiply accumulate (MAC) calculations. The MAC value is used by the foreground function EM_calcVRMSDivSqrt to calculate VRMS.  <a href="#gaef08801742aee1da976354b529cc4e79">More...</a><br /></td></tr>
<tr class="separator:gaef08801742aee1da976354b529cc4e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45943f5807719c16a8e126d55e86026a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga45943f5807719c16a8e126d55e86026a">EM_calcVRMSDivSqrt</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase, <a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result)</td></tr>
<tr class="memdesc:ga45943f5807719c16a8e126d55e86026a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the division and square root for VRMS. This API uses the dot product calculated by the EM_calcVRMSMultAcc function. It updates the global Phase Result structure. The result can be read inside the result structure.  <a href="#ga45943f5807719c16a8e126d55e86026a">More...</a><br /></td></tr>
<tr class="separator:ga45943f5807719c16a8e126d55e86026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2613527572e71b8bb731a0f8ee879403"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga2613527572e71b8bb731a0f8ee879403">EM_calcIRMSMultAcc</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase)</td></tr>
<tr class="memdesc:ga2613527572e71b8bb731a0f8ee879403"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the dot product and accumulation for IRMS. This API reads the current value from the current ptr in the phase structure and updates the Metro Result structure; storing the temporary multiply accumulate (MAC) calculations. The MAC value is used by the foreground function EM_calcIRMSDivSqrt to calculate IRMS.  <a href="#ga2613527572e71b8bb731a0f8ee879403">More...</a><br /></td></tr>
<tr class="separator:ga2613527572e71b8bb731a0f8ee879403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc726817689d2d52f85a5c3e1f33d665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gabc726817689d2d52f85a5c3e1f33d665">EM_calcIRMSDivSqrt</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase, <a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result)</td></tr>
<tr class="memdesc:gabc726817689d2d52f85a5c3e1f33d665"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the division and square root for IRMS. This API uses the dot product calculated by the EM_calcIRMSMultAcc function. It updates the global Phase Result structure. The result can be read inside the result structure.  <a href="#gabc726817689d2d52f85a5c3e1f33d665">More...</a><br /></td></tr>
<tr class="separator:gabc726817689d2d52f85a5c3e1f33d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451f1a661958c82469169ad1c5f61df0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga451f1a661958c82469169ad1c5f61df0">EM_calcIPeak</a> (<a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result, <a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *algo)</td></tr>
<tr class="memdesc:ga451f1a661958c82469169ad1c5f61df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate I Peak. This API updates the global Phase Result structure. The formula used to calculate: result-&gt;IRMS x algo-&gt;sqrtTwoConst Where algo-&gt;sqrtTwoConst = Sqrt(2) The result can be read inside the result structure.  <a href="#ga451f1a661958c82469169ad1c5f61df0">More...</a><br /></td></tr>
<tr class="separator:ga451f1a661958c82469169ad1c5f61df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812a9164fd5c89735851bb2f560198f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga812a9164fd5c89735851bb2f560198f0">EM_calcVPeak</a> (<a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result, <a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *algo)</td></tr>
<tr class="memdesc:ga812a9164fd5c89735851bb2f560198f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate V Peak. This API updates the global Phase Result structure. The formula used to calculate: result-&gt;VRMS x algo-&gt;sqrtTwoConst Where algo-&gt;sqrtTwoConst = Sqrt(2) The result can be read inside the result structure.  <a href="#ga812a9164fd5c89735851bb2f560198f0">More...</a><br /></td></tr>
<tr class="separator:ga812a9164fd5c89735851bb2f560198f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18bc64d00da3b5171c2233e66022c485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga18bc64d00da3b5171c2233e66022c485">EM_calcFreqPeriod</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *phase, <a class="el" href="em_sw_lib_8h.html#a7880bb724e609f02cb3d6a0413e2d5b1">EM_Phase_BG_Results</a> *bgData)</td></tr>
<tr class="memdesc:ga18bc64d00da3b5171c2233e66022c485"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate the period of the voltage signal. For systems with 2 voltages, this API must be used with only one of the voltage signals. This API reads the voltage using the phase structure. This API requires the initialization of the following using the function count = (256 * Sampling Freq. / Fs ):  <a href="#ga18bc64d00da3b5171c2233e66022c485">More...</a><br /></td></tr>
<tr class="separator:ga18bc64d00da3b5171c2233e66022c485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada1e8ae5ca1f6368ea8c908fbc5c4884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gada1e8ae5ca1f6368ea8c908fbc5c4884">EM_calcFreq</a> (<a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *metro, <a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *result, <a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *algo)</td></tr>
<tr class="memdesc:gada1e8ae5ca1f6368ea8c908fbc5c4884"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate frequency. This API updates the global Phase Result structure. The formula used to calculate: algo-&gt;freqSampling * 256L*100L / metro-&gt;mainPeriod The result can be read inside the result structure.  <a href="#gada1e8ae5ca1f6368ea8c908fbc5c4884">More...</a><br /></td></tr>
<tr class="separator:gada1e8ae5ca1f6368ea8c908fbc5c4884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b768dc01c4625171d84cc70fee8cfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga68b768dc01c4625171d84cc70fee8cfd">EM_calcTotalActivePower</a> (uint8_t *phaseIdx, uint8_t length, <a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *result)</td></tr>
<tr class="memdesc:ga68b768dc01c4625171d84cc70fee8cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate total active power. This API will aggregate the total power of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer.  <a href="#ga68b768dc01c4625171d84cc70fee8cfd">More...</a><br /></td></tr>
<tr class="separator:ga68b768dc01c4625171d84cc70fee8cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0021c11695ba73c0db981903a26b530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gab0021c11695ba73c0db981903a26b530">EM_calcTotalReactivePower</a> (uint8_t *phaseIdx, uint8_t length, <a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *result)</td></tr>
<tr class="memdesc:gab0021c11695ba73c0db981903a26b530"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate total reactive power. This API will aggregate the total power of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer.  <a href="#gab0021c11695ba73c0db981903a26b530">More...</a><br /></td></tr>
<tr class="separator:gab0021c11695ba73c0db981903a26b530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae746e43b3c2d267aff4a33e802ee00e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gae746e43b3c2d267aff4a33e802ee00e1">EM_calcTotalApparentPower</a> (uint8_t *phaseIdx, uint8_t length, <a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *result)</td></tr>
<tr class="memdesc:gae746e43b3c2d267aff4a33e802ee00e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate total apparent power. This API will aggregate the total power of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer.  <a href="#gae746e43b3c2d267aff4a33e802ee00e1">More...</a><br /></td></tr>
<tr class="separator:gae746e43b3c2d267aff4a33e802ee00e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2611108294f9145fbdf6c3fa17543c7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#ga2611108294f9145fbdf6c3fa17543c7f">EM_calcTotalActiveEnergy</a> (uint8_t *phaseIdx, uint8_t length, <a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *result)</td></tr>
<tr class="memdesc:ga2611108294f9145fbdf6c3fa17543c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate total active energy. This API will aggregate the total energy of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer.  <a href="#ga2611108294f9145fbdf6c3fa17543c7f">More...</a><br /></td></tr>
<tr class="separator:ga2611108294f9145fbdf6c3fa17543c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59cfd11082392f59ddada372a9629ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gae59cfd11082392f59ddada372a9629ac">EM_calcTotalReactiveEnergy</a> (uint8_t *phaseIdx, uint8_t length, <a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *result)</td></tr>
<tr class="memdesc:gae59cfd11082392f59ddada372a9629ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate total reactive energy. This API will aggregate the total energy of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer.  <a href="#gae59cfd11082392f59ddada372a9629ac">More...</a><br /></td></tr>
<tr class="separator:gae59cfd11082392f59ddada372a9629ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0367492a07c010cd1dc4abbc3d47423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__result__api.html#gaa0367492a07c010cd1dc4abbc3d47423">EM_calcTotalApparentEnergy</a> (uint8_t *phaseIdx, uint8_t length, <a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *result)</td></tr>
<tr class="memdesc:gaa0367492a07c010cd1dc4abbc3d47423"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following API is used to calculate total apparent energy. This API will aggregate the total energy of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer.  <a href="#gaa0367492a07c010cd1dc4abbc3d47423">More...</a><br /></td></tr>
<tr class="separator:gaa0367492a07c010cd1dc4abbc3d47423"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1834214615fdf22f3c4b3cd6c6dc8b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1834214615fdf22f3c4b3cd6c6dc8b0c">&sect;&nbsp;</a></span>EM_voltageDCFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t EM_voltageDCFilter </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is intended for the removal of the DC content from 16 bit 50Hz/60Hz mains signals. All samples should be passed through the filter, in sequence, to obtain a signal free of DC content. The estimation is based on a noise shaped single pole LPF.The cutoff frequency of this filter is set very low, so its gain is essentially flat from 45Hz upwards. This means the filter can take several seconds to stabilize when the signal is initially applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>is a pointer to the filter state variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>is the next signal sample</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga00a88a65cef272e566d228b833fb1637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00a88a65cef272e566d228b833fb1637">&sect;&nbsp;</a></span>EM_currentDCFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t EM_currentDCFilter </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>p</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is intended for the removal of the DC content from 24 bit 50Hz/60Hz mains signals. All samples should be passed through the filter, in sequence, to obtain a signal free of DC content. The estimation is based on a noise shaped single pole LPF.The cutoff frequency of this filter is set very low, so its gain is essentially flat from 45Hz upwards. This means the filter can take several seconds to stabilize when the signal is initially applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>is a pointer to the filter state variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>is the next signal sample</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga8f9c190a63d2e367c421c770c23a7d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f9c190a63d2e367c421c770c23a7d21">&sect;&nbsp;</a></span>EM_perSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_perSample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7880bb724e609f02cb3d6a0413e2d5b1">EM_Phase_BG_Results</a> *&#160;</td>
          <td class="paramname"><em>bgData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used update the previous voltage value for a phase and to increment the number of samples processed in the ISR. This API must be called inside the ISR after all the background APIs are executed for a phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Ping Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bgData</td><td>is a pointer to the EM RP Phase Results structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad6628dae04ad34378c448fb2de928e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6628dae04ad34378c448fb2de928e6f">&sect;&nbsp;</a></span>EM_perDataChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_perDataChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a837b6a11e53dcd5688fb2c05420e4ff9">EM_SW_Lib_Config_Handle</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>phaseIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to swap the metrology ping and pong pointers. This API must be executed after the Frequency Function has processed N number of cycles (where N = config-&gt;algoConfig-&gt;mainNomFreq). The Metrology Ping struc is the buffer updated in the ISR, and Metrology Pong struct is used by the foreground APIs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>is a pointer to the EM SW Library user configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Library result structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phaseIdx</td><td>is the index for the phase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gade3085e201967bbf7770ce88765ca5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade3085e201967bbf7770ce88765ca5fb">&sect;&nbsp;</a></span>EM_delayCurrent90Degrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_delayCurrent90Degrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7880bb724e609f02cb3d6a0413e2d5b1">EM_Phase_BG_Results</a> *&#160;</td>
          <td class="paramname"><em>bgData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to delay the current degree by 90 degrees. It uses an IIR filter with 1 pole to shift current: (all pass 90 degree filter for w = PI*f/fs, f=signal freq and fs = sampling frequency) I90(IDX0 = I(IDX-1)+G*[I(IDX) - I90(IDX-1)] G = (tan(w) - 1)/(tan(w) + 1) The G constant used by the filter is based on signal frequency which is updated ~ once a second. It updates metro Result structure; storing the temporary multiply accumulate (MAC) calculations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Ping Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bgData</td><td>is a pointer to the EM SW BG Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga218995a1fda2a83454aaa7ae83db94ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga218995a1fda2a83454aaa7ae83db94ac">&sect;&nbsp;</a></span>EM_genPulseIndPhase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_genPulseIndPhase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a85eac103503a6527fda74bf2bbb2e225">EM_System_Configuration</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a5e7d7de3e9ae6ce0c56c199516333ef4">EM_Pulse_Settings</a> *&#160;</td>
          <td class="paramname"><em>pulse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to generate pulses for an individual phase. This API checks if the config-&gt;pulseGeneration has the result-&gt; phaseID set. If is set then it will generate EM_PHASE_IMP_PER_KWHR impulses per kWhr. This API requires that the pulse settings are initialized for the activePulse and reactivePulse Port/Pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>is a pointer to the EM SW Library user configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pulse</td><td>is a pointer to the EM SW Library pulse structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Library result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga24aa9c669d32d27306a840ad9d196efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24aa9c669d32d27306a840ad9d196efe">&sect;&nbsp;</a></span>EM_genPulseTotalPhases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_genPulseTotalPhases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a85eac103503a6527fda74bf2bbb2e225">EM_System_Configuration</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a5e7d7de3e9ae6ce0c56c199516333ef4">EM_Pulse_Settings</a> *&#160;</td>
          <td class="paramname"><em>pulse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ae3e8e409f282157e47284db0105b45cd">EM_Total_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to generate pulses for the total phase. This API checks if the config-&gt;pulseGeneration has EM_PULSE_GEN_PHASE_AGGREGATE set. If is set then it will generate EM_PHASE_IMP_PER_KWHR impulses per kWhr. This API requires that the pulse settings are initialized for the activePulse and reactivePulse Port/Pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>is a pointer to the EM SW Library user configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pulse</td><td>is a pointer to the EM SW Library pulse structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Library result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga147110de9d95fdf71c193ce2cd9baf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga147110de9d95fdf71c193ce2cd9baf05">&sect;&nbsp;</a></span>EM_updateOneDivSC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_updateOneDivSC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the 1/sample_count constant. This function must be executed after EM_perDataChunk API for each phase inside the foreground code. The 1/sample_count constant will be used to calculate the results parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gac7163797e2a70de44e78d47da27e7faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7163797e2a70de44e78d47da27e7faf">&sect;&nbsp;</a></span>EM_clearMetrology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_clearMetrology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to clear the temporary variables inside the metro structure. This API must be called as the last API in the foreground code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga21ffe9a979a07cf06d9b1ebb0442cca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21ffe9a979a07cf06d9b1ebb0442cca9">&sect;&nbsp;</a></span>EM_updateReactPowConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_updateReactPowConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *&#160;</td>
          <td class="paramname"><em>algo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to look up the IIR G constant used to calculate the Reactive Power using the current frequency value. The index of the G constant in the reactPowIIRTable is calculated: index = (Current Frequency - reactPowIIRMinFreq) &gt;&gt; reactPowIIRShift if the index is &gt; reactPowIIRLength, then index = reactPowIIRLength. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algo</td><td>is a pointer to the EM SW Algorithm structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa9d4ea4efa8e5b8317d2b2a4e2dd0403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9d4ea4efa8e5b8317d2b2a4e2dd0403">&sect;&nbsp;</a></span>EM_processSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="em_sw_lib_8h.html#a49eed1476cbc4d90c0ef3708bf776f28">EM_message_code</a> EM_processSample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a837b6a11e53dcd5688fb2c05420e4ff9">EM_SW_Lib_Config_Handle</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used process the samples. It is used to calculate intermediate dot product results that are fed into the foreground process for the calculation of metrology readings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>is a pointer to the EM SW Library user configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_message_code </dd></dl>

</div>
</div>
<a id="gaa56ee9d70b0dc6fbc6fb26117e4eff4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa56ee9d70b0dc6fbc6fb26117e4eff4a">&sect;&nbsp;</a></span>EM_calcActivePowerMultAcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcActivePowerMultAcc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the dot product and accumulation of Voltage and Current. This API reads the current and voltage values using the phase structure.It updates metro Result structure; storing the temporary multiply accumulate (MAC) calculations. The MAC value is used by the foreground function EM_calcActivePowerDiv to calculate Active Power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Ping Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2fab4b120d32a9c122b8bdf74d83276a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fab4b120d32a9c122b8bdf74d83276a">&sect;&nbsp;</a></span>EM_calcActivePowerDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcActivePowerDiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *&#160;</td>
          <td class="paramname"><em>algo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the active power in the foreground code and store activePower in the result structure. The formula used: (metro-&gt;AP_dot_prod-&gt;P_accum x metro-&gt;oneDivSC) x phase-&gt;phaseCalibPtr-&gt;activePowerSF If the activePower calculated is less than algo-&gt;residualPowerCutoff then activePower will be set to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algo</td><td>is a pointer to the EM SW Algorithm structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga3c43e46165cf16d27fb854d331066ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c43e46165cf16d27fb854d331066ccd">&sect;&nbsp;</a></span>EM_calcActiveEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcActiveEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *&#160;</td>
          <td class="paramname"><em>algo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the active energy result. The formula used to calculate activeEnergy (uWh): (result-&gt;activePower x metro-&gt;sampleCount) x energyCalcConst Where energyCalcConst = (1/(sampling freq x 3600)) This API must be called after EM_calcActivePowerDiv. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algo</td><td>is a pointer to the EM SW Algorithm structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae958917049f27a3a3eb4fccba9586d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae958917049f27a3a3eb4fccba9586d45">&sect;&nbsp;</a></span>EM_calcReactivePowerMultAcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcReactivePowerMultAcc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7880bb724e609f02cb3d6a0413e2d5b1">EM_Phase_BG_Results</a> *&#160;</td>
          <td class="paramname"><em>bgData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the dot product and accumulation of Voltage_90 and Current. This API reads the current and voltage values using the phase structure.It uses an IIR filter with 1 pole to shift the the voltage 90 degrees: (all pass 90 degree filter for w = PI*f/fs, f=signal freq and fs = sampling frequency) V90(IDX0 = V(IDX-1)+G*[V(IDX) - V90(IDX-1)] G = (tan(w) - 1)/(tan(w) + 1) The G constant used by the filter is based on signal frequency which is updated ~ once a second. It updates metro Result structure; storing the temporary multiply accumulate (MAC) calculations. The MAC value is used by the foreground function EM_calcReactivePowerDiv to calculate Reactive Power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Ping Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bgData</td><td>is a pointer to the EM SW BG Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga8479a9975c6370e31638c460260eaa48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8479a9975c6370e31638c460260eaa48">&sect;&nbsp;</a></span>EM_calcReactivePowerDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcReactivePowerDiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *&#160;</td>
          <td class="paramname"><em>algo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the reactive power in the foreground code and store reactivePower in the result structure. The formula used: (metro-&gt;RP_dot_prod-&gt;P_accum x metro-&gt;oneDivSC) x phase-&gt;phaseCalibPtr-&gt;reactivePowerSF If the reactivePower calculated is less than algo-&gt;residualPowerCutoff then reactivePower will be set to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algo</td><td>is a pointer to the EM SW Algorithm structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga4da326b0f5b3e27e695253144a11cb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da326b0f5b3e27e695253144a11cb64">&sect;&nbsp;</a></span>EM_calcReactiveEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcReactiveEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *&#160;</td>
          <td class="paramname"><em>algo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the reactive energy result. The formula used to calculate reactiveEnergy (uVArh): (result-&gt;reactivePower x metro-&gt;sampleCount) x energyCalcConst Where energyCalcConst = (1/(sampling freq x 3600)) This API must be called after EM_calcReactivePowerDiv. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algo</td><td>is a pointer to the EM SW Algorithm structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga13adade3e66abf65c11c9535e712d9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13adade3e66abf65c11c9535e712d9be">&sect;&nbsp;</a></span>EM_calcApparentPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcApparentPower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate apparent power. The formula used to calculate apparentPower (uVA): Sqrt Root (result-&gt;activePower ^ 2 + result-&gt;reactivePower ^ 2) This API must be called after EM_calcActivePowerMultAcc and EM_calcReactivePowerMultAcc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa636506ae0691a1e990a8d7a034f5672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa636506ae0691a1e990a8d7a034f5672">&sect;&nbsp;</a></span>EM_calcApparentEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcApparentEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *&#160;</td>
          <td class="paramname"><em>algo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the apparent energy result. The formula used to calculate apparentEnergy (uVAh): (result-&gt;apparentPower x metro-&gt;sampleCount) x energyCalcConst Where energyCalcConst = (1/(sampling freq x 3600)) This API must be called after EM_calcApparentPower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algo</td><td>is a pointer to the EM SW Algorithm structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga63a2a50263682af4c16b3d17e3ee25a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63a2a50263682af4c16b3d17e3ee25a8">&sect;&nbsp;</a></span>EM_calcPowerFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcPowerFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate power factor. The formula used to calculate it: activePower / apparentPower This API must be called after EM_calcActivePowerMultAcc and EM_calcApparentPower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaef08801742aee1da976354b529cc4e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef08801742aee1da976354b529cc4e79">&sect;&nbsp;</a></span>EM_calcVRMSMultAcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcVRMSMultAcc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the dot product and accumulation for VRMS. This API reads the voltage value from the voltage ptr in the phase structure and updates the Metro Result structure; storing the temporary multiply accumulate (MAC) calculations. The MAC value is used by the foreground function EM_calcVRMSDivSqrt to calculate VRMS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Ping Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga45943f5807719c16a8e126d55e86026a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45943f5807719c16a8e126d55e86026a">&sect;&nbsp;</a></span>EM_calcVRMSDivSqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcVRMSDivSqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the division and square root for VRMS. This API uses the dot product calculated by the EM_calcVRMSMultAcc function. It updates the global Phase Result structure. The result can be read inside the result structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Library result handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2613527572e71b8bb731a0f8ee879403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2613527572e71b8bb731a0f8ee879403">&sect;&nbsp;</a></span>EM_calcIRMSMultAcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcIRMSMultAcc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the dot product and accumulation for IRMS. This API reads the current value from the current ptr in the phase structure and updates the Metro Result structure; storing the temporary multiply accumulate (MAC) calculations. The MAC value is used by the foreground function EM_calcIRMSDivSqrt to calculate IRMS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Ping Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gabc726817689d2d52f85a5c3e1f33d665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc726817689d2d52f85a5c3e1f33d665">&sect;&nbsp;</a></span>EM_calcIRMSDivSqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcIRMSDivSqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the division and square root for IRMS. This API uses the dot product calculated by the EM_calcIRMSMultAcc function. It updates the global Phase Result structure. The result can be read inside the result structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Library result handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga451f1a661958c82469169ad1c5f61df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga451f1a661958c82469169ad1c5f61df0">&sect;&nbsp;</a></span>EM_calcIPeak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcIPeak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *&#160;</td>
          <td class="paramname"><em>algo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate I Peak. This API updates the global Phase Result structure. The formula used to calculate: result-&gt;IRMS x algo-&gt;sqrtTwoConst Where algo-&gt;sqrtTwoConst = Sqrt(2) The result can be read inside the result structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algo</td><td>is a pointer to the EM SW Algorithm structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga812a9164fd5c89735851bb2f560198f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga812a9164fd5c89735851bb2f560198f0">&sect;&nbsp;</a></span>EM_calcVPeak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcVPeak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *&#160;</td>
          <td class="paramname"><em>algo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate V Peak. This API updates the global Phase Result structure. The formula used to calculate: result-&gt;VRMS x algo-&gt;sqrtTwoConst Where algo-&gt;sqrtTwoConst = Sqrt(2) The result can be read inside the result structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algo</td><td>is a pointer to the EM SW Algorithm structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga18bc64d00da3b5171c2233e66022c485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18bc64d00da3b5171c2233e66022c485">&sect;&nbsp;</a></span>EM_calcFreqPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcFreqPeriod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#ac002052634f8b69b5bf8952ca6a3e803">EM_Phase_Configuration</a> *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7880bb724e609f02cb3d6a0413e2d5b1">EM_Phase_BG_Results</a> *&#160;</td>
          <td class="paramname"><em>bgData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate the period of the voltage signal. For systems with 2 voltages, this API must be used with only one of the voltage signals. This API reads the voltage using the phase structure. This API requires the initialization of the following using the function count = (256 * Sampling Freq. / Fs ): </p>
<ul>
<li>EMSWLIB_EM_HAL_ADC_minFreqCount - should be calculated for Fs = 70 Hz</li>
<li>EMSWLIB_EM_HAL_ADC_maxFreqCount - should be calculated for Fs = 40 Hz For example For Sampling Freq = 4096, minFreqCount = (256*4096 / 70) = 14,980 maxFreqCount = (256*4096 / 40) = 26,214 The Main Period is calculated using a running average of the main_period. To calculate the period interpolation is used using a resolution of 256. The period between two zero crossings (ZC_1 and ZC_2) is calculated using the following formula: Given, XC_N (interpolated x value) = - 256 * Y_Prev / (Y_Act - Y_Prev) Where Y_Prev and Y_Act are the Y values in the negative to positive transition (e.g. Y_Prev &lt; 0 and Y_Act &gt;= 0 ) Delta_N = 256 - XC_N Then, Period_N = Delta_N-1 + 256*samples (not including Y_Prev and Y_Act) + XC_N (e.g. for Period 2) = Delta_1 + 256*samples + XC_2</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Ping Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>is a pointer to the EM SW Phase structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bgData</td><td>is a pointer to the EM SW BG Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gada1e8ae5ca1f6368ea8c908fbc5c4884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada1e8ae5ca1f6368ea8c908fbc5c4884">&sect;&nbsp;</a></span>EM_calcFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a2e883ea1cc7d80cdfc58bf722eb62dae">EM_Metrology</a> *&#160;</td>
          <td class="paramname"><em>metro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a8189d9c8ea9b05335cec20f66763ad17">EM_Phase_Results</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a7f8c1ced728b07b1b156560517dc7dd4">EM_Algorithm_Configuration</a> *&#160;</td>
          <td class="paramname"><em>algo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate frequency. This API updates the global Phase Result structure. The formula used to calculate: algo-&gt;freqSampling * 256L*100L / metro-&gt;mainPeriod The result can be read inside the result structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metro</td><td>is a pointer to the EM SW Metrology structure (Pong Ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algo</td><td>is a pointer to the EM SW Algorithm structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga68b768dc01c4625171d84cc70fee8cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68b768dc01c4625171d84cc70fee8cfd">&sect;&nbsp;</a></span>EM_calcTotalActivePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcTotalActivePower </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>phaseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate total active power. This API will aggregate the total power of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phaseIdx</td><td>is a pointer to the phase indexes buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>is the length of the phaseIdx buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gab0021c11695ba73c0db981903a26b530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0021c11695ba73c0db981903a26b530">&sect;&nbsp;</a></span>EM_calcTotalReactivePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcTotalReactivePower </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>phaseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate total reactive power. This API will aggregate the total power of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phaseIdx</td><td>is a pointer to the phase indexes buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>is the length of the phaseIdx buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae746e43b3c2d267aff4a33e802ee00e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae746e43b3c2d267aff4a33e802ee00e1">&sect;&nbsp;</a></span>EM_calcTotalApparentPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcTotalApparentPower </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>phaseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate total apparent power. This API will aggregate the total power of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phaseIdx</td><td>is a pointer to the phase indexes buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>is the length of the phaseIdx buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2611108294f9145fbdf6c3fa17543c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2611108294f9145fbdf6c3fa17543c7f">&sect;&nbsp;</a></span>EM_calcTotalActiveEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcTotalActiveEnergy </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>phaseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate total active energy. This API will aggregate the total energy of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phaseIdx</td><td>is a pointer to the phase indexes buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>is the length of the phaseIdx buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae59cfd11082392f59ddada372a9629ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae59cfd11082392f59ddada372a9629ac">&sect;&nbsp;</a></span>EM_calcTotalReactiveEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcTotalReactiveEnergy </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>phaseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate total reactive energy. This API will aggregate the total energy of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phaseIdx</td><td>is a pointer to the phase indexes buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>is the length of the phaseIdx buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa0367492a07c010cd1dc4abbc3d47423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0367492a07c010cd1dc4abbc3d47423">&sect;&nbsp;</a></span>EM_calcTotalApparentEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EM_calcTotalApparentEnergy </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>phaseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="em_sw_lib_8h.html#a22b592d72c252500653d07af953b9c53">EM_SW_Lib_Result_Handle</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following API is used to calculate total apparent energy. This API will aggregate the total energy of the result-&gt;phaseResults buffer using the indexes included in the phaseIdx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phaseIdx</td><td>is a pointer to the phase indexes buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>is the length of the phaseIdx buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>is a pointer to the EM SW Result structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2018</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
