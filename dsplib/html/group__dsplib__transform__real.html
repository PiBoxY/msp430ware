<!-- --COPYRIGHT--,BSD
 *  Copyright (c) 2017, Texas Instruments Incorporated
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 * 
 *  *  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 
 *  *  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 *  *  Neither the name of Texas Instruments Incorporated nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 * 
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * --/COPYRIGHT-- -->
<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>MSP DSP Library: Real FFT</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <img alt="Logo" width=25% src="ti_hz_2c_pos_rgb_png.png"/>
    <table cellspacing="0" cellpadding="0">
        <tbody>
        <tr style="height: 56px;">
            <td style="padding-left: 0.5em;">
                <div id="projectname">MSP DSP Library
                </div>
            </td>
        </tr>
        </tbody>
    </table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="usersguide.html"><span>Users&#160;Guide</span></a></li>
      <li><a href="gui.html"><span>Filter&#160;Design&#160;GUI</span></a></li>
      <li><a href="modules.html"><span>API&#160;Guide</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li><a href="disclaimer.html"><span>Disclaimer</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__dsplib__transform__real.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Real FFT<div class="ingroups"><a class="el" href="group__dsplib__transform__api.html">Transform</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsp__fft__q15__params.html">msp_fft_q15_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter structure for Q15 real FFT functions.  <a href="structmsp__fft__q15__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsp__fft__iq31__params.html">msp_fft_iq31_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter structure for IQ31 real FFT functions.  <a href="structmsp__fft__iq31__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaba0e5463c92f91a635ba137e31f7f8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsplib__transform__real.html#gaba0e5463c92f91a635ba137e31f7f8d2">msp_fft_auto_q15</a> (const <a class="el" href="structmsp__fft__q15__params.html">msp_fft_q15_params</a> *params, int16_t *src, uint16_t *shift)</td></tr>
<tr class="memdesc:gaba0e5463c92f91a635ba137e31f7f8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real forward FFT function with auto-scaling.  <a href="#gaba0e5463c92f91a635ba137e31f7f8d2">More...</a><br /></td></tr>
<tr class="separator:gaba0e5463c92f91a635ba137e31f7f8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d6f504a72975cfab31c4dd9fa0c242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsplib__transform__real.html#ga91d6f504a72975cfab31c4dd9fa0c242">msp_fft_fixed_q15</a> (const <a class="el" href="structmsp__fft__q15__params.html">msp_fft_q15_params</a> *params, int16_t *src)</td></tr>
<tr class="memdesc:ga91d6f504a72975cfab31c4dd9fa0c242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real forward FFT function with fixed scaling by two at each stage.  <a href="#ga91d6f504a72975cfab31c4dd9fa0c242">More...</a><br /></td></tr>
<tr class="separator:ga91d6f504a72975cfab31c4dd9fa0c242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57fb7ae6cfb12898c4fc823821f5c2f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsplib__transform__real.html#ga57fb7ae6cfb12898c4fc823821f5c2f8">msp_fft_iq31</a> (const <a class="el" href="structmsp__fft__iq31__params.html">msp_fft_iq31_params</a> *params, int32_t *src)</td></tr>
<tr class="memdesc:ga57fb7ae6cfb12898c4fc823821f5c2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real forward FFT function without scaling.  <a href="#ga57fb7ae6cfb12898c4fc823821f5c2f8">More...</a><br /></td></tr>
<tr class="separator:ga57fb7ae6cfb12898c4fc823821f5c2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc1ee74315e8e8fccc092bfc9f8f2b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsplib__transform__real.html#gadfc1ee74315e8e8fccc092bfc9f8f2b6">msp_ifft_auto_q15</a> (const <a class="el" href="structmsp__fft__q15__params.html">msp_fft_q15_params</a> *params, int16_t *src, uint16_t shift)</td></tr>
<tr class="memdesc:gadfc1ee74315e8e8fccc092bfc9f8f2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real result inverse FFT function with auto-scaling.  <a href="#gadfc1ee74315e8e8fccc092bfc9f8f2b6">More...</a><br /></td></tr>
<tr class="separator:gadfc1ee74315e8e8fccc092bfc9f8f2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa615c641a91a40ad49fd9ed519c68ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsplib__transform__real.html#gaaa615c641a91a40ad49fd9ed519c68ea">msp_ifft_fixed_q15</a> (const <a class="el" href="structmsp__fft__q15__params.html">msp_fft_q15_params</a> *params, int16_t *src)</td></tr>
<tr class="memdesc:gaaa615c641a91a40ad49fd9ed519c68ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real result inverse FFT function with fixed scaling by two at each stage.  <a href="#gaaa615c641a91a40ad49fd9ed519c68ea">More...</a><br /></td></tr>
<tr class="separator:gaaa615c641a91a40ad49fd9ed519c68ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1224987f5e76e10a2096e02b1557d929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsplib__transform__real.html#ga1224987f5e76e10a2096e02b1557d929">msp_ifft_iq31</a> (const <a class="el" href="structmsp__fft__iq31__params.html">msp_fft_iq31_params</a> *params, int32_t *src)</td></tr>
<tr class="memdesc:ga1224987f5e76e10a2096e02b1557d929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real result inverse FFT function without scaling.  <a href="#ga1224987f5e76e10a2096e02b1557d929">More...</a><br /></td></tr>
<tr class="separator:ga1224987f5e76e10a2096e02b1557d929"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions for performing forward and inverse FFT of real 16-bit and 32-bit input data. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaba0e5463c92f91a635ba137e31f7f8d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a> msp_fft_auto_q15 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsp__fft__q15__params.html">msp_fft_q15_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real forward FFT function with auto-scaling. </p>
<dl class="section user"><dt>Details</dt><dd>Computes the forward discreet Fourier transform (DFT) of 16-bit real inputs. If the inputs are not already in bit reversed order the bit reversal parameter must be set. The output is monitored for overflow and scaled by a factor of two when an overflow risk is detected. The shift parameter contains the number of bit shifts that were applied to the output.</dd></dl>
<dl class="section user"><dt></dt><dd>This functions requires half the data storage and consumes roughly half the cycles and energy as running a complex FFT of the same length. When transforming purely real inputs, such as samples from an ADC or analog sensor, it is recommended to use the real FFT functions.</dd></dl>
<dl class="section user"><dt>Pseudo code</dt><dd><code>y = fft(real(x)) * 2^-shift</code></dd></dl>
<dl class="section user"><dt>Scaling</dt><dd>Scaling is applied as needed to prevent saturation of the output. The scale factor that was applied to the output is returned in the shift parameter and can be used to calculate the result by applying the following function.</dd></dl>
<dl class="section user"><dt></dt><dd><code>result = result * 2^shift</code></dd></dl>
<dl class="section user"><dt>LEA Support</dt><dd>This function is supported by LEA and requires data to be placed into shared LEA memory with alignment equal to twice the data length (e.g. a 256-point real FFT requires 512-byte alignment). When allocating data the MSP_ALIGN_FFT_Q15 macro can be used to calculate correct alignment. The twiddle table pointer parameter is not used with LEA and can be null or uninitialized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Pointer to the real FFT parameter structure. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the real data array to perform the FFT on. </td></tr>
    <tr><td class="paramname">shift</td><td>Auto-scaling shift that was applied to the output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91d6f504a72975cfab31c4dd9fa0c242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a> msp_fft_fixed_q15 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsp__fft__q15__params.html">msp_fft_q15_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real forward FFT function with fixed scaling by two at each stage. </p>
<dl class="section user"><dt>Details</dt><dd>Computes the forward discreet Fourier transform (DFT) of 16-bit real inputs. If the inputs are not already in bit reversed order the bit reversal parameter must be set. The output is scaled by a factor of two for each stage of the DFT.</dd></dl>
<dl class="section user"><dt></dt><dd>This functions requires half the data storage and consumes roughly half the cycles and energy as running a complex FFT of the same length. When transforming purely real inputs, such as samples from an ADC or analog sensor, it is recommended to use the real FFT functions.</dd></dl>
<dl class="section user"><dt>Pseudo code</dt><dd><code>y = fft(real(x)) ./ (N/2)</code></dd></dl>
<dl class="section user"><dt>Scaling</dt><dd>Each stage of the real FFT, with the exception of the final split stage, scales the result by a factor of 0.5. The output format can either be interpreted as the same type with (N/2) scaling or a different fixed point data type. This can be helpful when using the IQmathLib to process the results of the FFT, such as computing the magnitude or phase angle of the complex result.</dd></dl>
<dl class="section user"><dt></dt><dd><center> <table class="doxtable">
<tr>
<th>Length </th><th align="center">Input Type </th><th align="center">Result Type  </th></tr>
<tr>
<td><b>16</b> </td><td align="center">_q15 </td><td align="center">_q12 </td></tr>
<tr>
<td><b>32</b> </td><td align="center">_q15 </td><td align="center">_q11 </td></tr>
<tr>
<td><b>64</b> </td><td align="center">_q15 </td><td align="center">_q10 </td></tr>
<tr>
<td><b>128</b> </td><td align="center">_q15 </td><td align="center">_q9 </td></tr>
<tr>
<td><b>256</b> </td><td align="center">_q15 </td><td align="center">_q8 </td></tr>
<tr>
<td><b>512</b> </td><td align="center">_q15 </td><td align="center">_q7 </td></tr>
<tr>
<td><b>1024</b> </td><td align="center">_q15 </td><td align="center">_q6 </td></tr>
<tr>
<td><b>2048</b> </td><td align="center">_q15 </td><td align="center">_q5 </td></tr>
<tr>
<td><b>4096</b> </td><td align="center">_q15 </td><td align="center">_q4 </td></tr>
</table>
</center></dd></dl>
<dl class="section user"><dt></dt><dd>The following table lists the applied scaling factor and resulting data type when the input is a 16-bit integer.</dd></dl>
<dl class="section user"><dt></dt><dd><center> <table class="doxtable">
<tr>
<th>Length </th><th align="center">Input Type </th><th align="center">Result Type  </th></tr>
<tr>
<td><b>16</b> </td><td align="center">int16_t </td><td align="center">(int16_t)(result / 8) </td></tr>
<tr>
<td><b>32</b> </td><td align="center">int16_t </td><td align="center">(int16_t)(result / 16) </td></tr>
<tr>
<td><b>64</b> </td><td align="center">int16_t </td><td align="center">(int16_t)(result / 32) </td></tr>
<tr>
<td><b>128</b> </td><td align="center">int16_t </td><td align="center">(int16_t)(result / 64) </td></tr>
<tr>
<td><b>256</b> </td><td align="center">int16_t </td><td align="center">(int16_t)(result / 128) </td></tr>
<tr>
<td><b>512</b> </td><td align="center">int16_t </td><td align="center">(int16_t)(result / 256) </td></tr>
<tr>
<td><b>1024</b> </td><td align="center">int16_t </td><td align="center">(int16_t)(result / 512) </td></tr>
<tr>
<td><b>2048</b> </td><td align="center">int16_t </td><td align="center">(int16_t)(result / 1024) </td></tr>
<tr>
<td><b>4096</b> </td><td align="center">int16_t </td><td align="center">(int16_t)(result / 2048) </td></tr>
</table>
</center></dd></dl>
<dl class="section user"><dt>LEA Support</dt><dd>This function is supported by LEA and requires data to be placed into shared LEA memory with alignment equal to twice the data length (e.g. a 256-point real FFT requires 512-byte alignment). When allocating data the MSP_ALIGN_FFT_Q15 macro can be used to calculate correct alignment. The twiddle table pointer parameter is not used with LEA and can be null or uninitialized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Pointer to the real FFT parameter structure. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the real data array to perform the FFT on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga57fb7ae6cfb12898c4fc823821f5c2f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a> msp_fft_iq31 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsp__fft__iq31__params.html">msp_fft_iq31_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real forward FFT function without scaling. </p>
<dl class="section user"><dt>Details</dt><dd>Computes the forward discreet Fourier transform (DFT) of 32-bit real inputs. If the inputs are not already in bit reversed order the bit reversal parameter must be set. The output is not scaled.</dd></dl>
<dl class="section user"><dt></dt><dd>This functions requires half the data storage and consumes roughly half the cycles and energy as running a complex FFT of the same length. When transforming purely real inputs, such as samples from an ADC or analog sensor, it is recommended to use the real FFT functions.</dd></dl>
<dl class="section user"><dt>Pseudo code</dt><dd><code>y = fft(real(x))</code></dd></dl>
<dl class="section user"><dt>LEA Support</dt><dd>This function is supported by LEA and requires data to be placed into shared LEA memory with alignment equal to four times the data length (e.g. a 256-point real FFT requires 1024-byte alignment). When allocating data the MSP_ALIGN_FFT_IQ31 macro can be used to calculate correct alignment. The twiddle table pointer parameter is not used with LEA and can be null or uninitialized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Pointer to the real FFT parameter structure. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the real data array to perform the FFT on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="transform_ex3_fft_iq31_8c-example.html#a12">transform_ex3_fft_iq31.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gadfc1ee74315e8e8fccc092bfc9f8f2b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a> msp_ifft_auto_q15 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsp__fft__q15__params.html">msp_fft_q15_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real result inverse FFT function with auto-scaling. </p>
<dl class="section user"><dt>Details</dt><dd>Computes the inverse discreet Fourier transform (DFT) of 16-bit complex inputs with real result. If the inputs are not already in bit reversed order the bit reversal parameter must be set. Automatic scaling is performed such that this is the direct inverse of the forward FFT with auto scaling.</dd></dl>
<dl class="section user"><dt></dt><dd>This functions uses half the data storage and consumes roughly half the cycles and energy as running a complex IFFT of the same length. When transforming purely real inputs, such as samples from an ADC or analog sensor, it is recommended to use the real FFT functions.</dd></dl>
<dl class="section user"><dt>Pseudo code</dt><dd><code>y = (real(ifft(x)) * 2^shift) ./ (N/2)</code></dd></dl>
<dl class="section user"><dt>LEA Support</dt><dd>This function is supported by LEA and requires data to be placed into shared LEA memory with alignment equal to twice the data length (e.g. a 256-point real FFT requires 512-byte alignment). When allocating data the MSP_ALIGN_FFT_Q15 macro can be used to calculate correct alignment. The twiddle table pointer parameter is not used with LEA and can be null or uninitialized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Pointer to the real FFT parameter structure. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the real data array to perform the FFT on. </td></tr>
    <tr><td class="paramname">shift</td><td>Auto-scaling shift that was applied to the forward FFT.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa615c641a91a40ad49fd9ed519c68ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a> msp_ifft_fixed_q15 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsp__fft__q15__params.html">msp_fft_q15_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real result inverse FFT function with fixed scaling by two at each stage. </p>
<dl class="section user"><dt>Details</dt><dd>Computes the inverse discreet Fourier transform (DFT) of 16-bit complex inputs with real result. If the inputs are not already in bit reversed order the bit reversal parameter must be set. Fixed scaling is performed such that this is the direct inverse of the forward FFT with fixed scaling.</dd></dl>
<dl class="section user"><dt></dt><dd>This functions uses half the data storage and consumes roughly half the cycles and energy as running a complex IFFT of the same length. When transforming purely real inputs, such as samples from an ADC or analog sensor, it is recommended to use the real FFT functions.</dd></dl>
<dl class="section user"><dt>Pseudo code</dt><dd><code>y = real(ifft(x))</code></dd></dl>
<dl class="section user"><dt>Scaling</dt><dd>This function is the direct inverse of the forward real FFT with fixed scaling. The following fixed point input types will all result in Q15 results.</dd></dl>
<dl class="section user"><dt></dt><dd><center> <table class="doxtable">
<tr>
<th>Length </th><th align="center">Input Type </th><th align="center">Result Type  </th></tr>
<tr>
<td><b>16</b> </td><td align="center">_q12 </td><td align="center">_q15 </td></tr>
<tr>
<td><b>32</b> </td><td align="center">_q11 </td><td align="center">_q15 </td></tr>
<tr>
<td><b>64</b> </td><td align="center">_q10 </td><td align="center">_q15 </td></tr>
<tr>
<td><b>128</b> </td><td align="center">_q9 </td><td align="center">_q15 </td></tr>
<tr>
<td><b>256</b> </td><td align="center">_q8 </td><td align="center">_q15 </td></tr>
<tr>
<td><b>512</b> </td><td align="center">_q7 </td><td align="center">_q15 </td></tr>
<tr>
<td><b>1024</b> </td><td align="center">_q6 </td><td align="center">_q15 </td></tr>
<tr>
<td><b>2048</b> </td><td align="center">_q5 </td><td align="center">_q15 </td></tr>
<tr>
<td><b>4096</b> </td><td align="center">_q4 </td><td align="center">_q15 </td></tr>
</table>
</center></dd></dl>
<dl class="section user"><dt>LEA Support</dt><dd>This function is supported by LEA and requires data to be placed into shared LEA memory with alignment equal to twice the data length (e.g. a 256-point real FFT requires 512-byte alignment). When allocating data the MSP_ALIGN_FFT_Q15 macro can be used to calculate correct alignment. The twiddle table pointer parameter is not used with LEA and can be null or uninitialized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Pointer to the real FFT parameter structure. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the real data array to perform the FFT on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1224987f5e76e10a2096e02b1557d929"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dsplib__types.html#ga06ca7a9a51e3177ae81a069d7ec306ed">msp_status</a> msp_ifft_iq31 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsp__fft__iq31__params.html">msp_fft_iq31_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real result inverse FFT function without scaling. </p>
<dl class="section user"><dt>Details</dt><dd>Computes the inverse discreet Fourier transform (DFT) of 32-bit complex inputs with real result. If the inputs are not already in bit reversed order the bit reversal parameter must be set. Fixed scaling is performed such that this is the direct inverse of the forward FFT without scaling.</dd></dl>
<dl class="section user"><dt></dt><dd>This functions uses half the data storage and consumes roughly half the cycles and energy as running a complex IFFT of the same length. When transforming purely real inputs, such as samples from an ADC or analog sensor, it is recommended to use the real FFT functions.</dd></dl>
<dl class="section user"><dt>Pseudo code</dt><dd><code>y = real(ifft(x)) ./ N</code></dd></dl>
<dl class="section user"><dt>LEA Support</dt><dd>This function is supported by LEA and requires data to be placed into shared LEA memory with alignment equal to four times the data length (e.g. a 256-point real FFT requires 1024-byte alignment). When allocating data the MSP_ALIGN_FFT_IQ31 macro can be used to calculate correct alignment. The twiddle table pointer parameter is not used with LEA and can be null or uninitialized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Pointer to the real FFT parameter structure. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the real data array to perform the FFT on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
	<p>Copyright &#169; 2015, Texas Instruments Incorporated</p>	
    </li>
  </ul>
</div>
</body>
</html>
