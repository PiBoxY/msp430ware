

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Software Library &mdash; CapTIvate &amp;trade; Technology Guide 1.70.00.03 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="CapTIvate &amp;trade; Technology Guide 1.70.00.03 documentation" href="../index.html"/>
        <link rel="next" title="MSP-CAPT-FR2633 Development Kit" href="ch_evm.html"/>
        <link rel="prev" title="Device Family" href="ch_device.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">
  <header id="tiHeader">
    <div class="top">
      <ul>
        <li id="top_logo">
          <a href="http://www.ti.com">
            <img src="../_static/img/ti_logo.png"/>
          </a>
        </li>
      </ul>
    </div>
    <div class="nav"></div>
  </header>
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> CapTIvate &trade; Technology Guide
          

          
          </a>

          
            
            
              <div class="version">
                1.70.00.03
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ch_getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_basics.html">Capacitive Sensing Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_technology.html">Technology</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_design_guide.html">Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_designcenter.html">Design Center GUI</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_device.html">Device Family</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Software Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#using-this-chapter">Using This Chapter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-and-tools-support">Device and Tools Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#delivery-mechanism">Delivery Mechanism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#change-control">Change Control</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#programming-model">Programming Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objects">Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-measurement-results-and-data">Accessing Measurement Results and Data</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#organization-and-architecture">Organization and Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#base-module">BASE Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-module">ADVANCED Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-configuration">User Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comm-module">COMM Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#source-code-directory-structure">Source Code Directory Structure</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#getting-started">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#starting-from-scratch-with-the-starter-project">Starting from Scratch with the Starter Project</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#directory-structure">Directory Structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#main">Main</a></li>
<li class="toctree-l4"><a class="reference internal" href="#board-support-package-capt-bsp">Board Support Package (CAPT_BSP)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-application-capt-app">Example Application (CAPT_App)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#moving-forward">Moving Forward</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#adding-captivate-to-an-existing-project">Adding CapTIvate™ to an Existing Project</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#similar-devices">Similar Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#porting-approach">Porting Approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bringing-over-captivate-software-components-from-a-starter-project-to-an-existing-project">Bringing over CapTIvate™ Software Components from a Starter Project to an Existing Project</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#porting-an-existing-captivate-project-to-a-new-device">Porting an Existing CapTIvate Project to a New Device</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Porting Approach</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#how-to">How-To</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#use-the-top-level-api">Use the Top Level API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#scope">Scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="#open-source">Open Source</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setting-up-an-application">Setting up an Application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-code-example">Simple Code Example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#register-a-callback-function">Register a Callback Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#access-element-state-data">Access Element State Data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#accessing-element-state-data-directly">Accessing Element State Data Directly</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-element-state-data-indirectly">Accessing Element State Data Indirectly</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-a-status-bit-field-for-all-elements-in-a-sensor">Generating a Status Bit Field for all Elements in a Sensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-a-sensor-s-global-flags">Accessing a Sensor&#8217;s Global Flags</a></li>
<li class="toctree-l4"><a class="reference internal" href="#element-status-flag-reference-table">Element Status Flag Reference Table</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#access-the-dominant-button">Access the Dominant Button</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#accessing-the-dominant-button-directly">Accessing the Dominant Button Directly</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-the-dominant-button-indirectly">Accessing the Dominant Button Indirectly</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-the-dominant-button-with-a-function-call">Accessing the Dominant Button with a Function Call</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#access-slider-or-wheel-position-data">Access Slider or Wheel Position Data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#accessing-the-slider-or-wheel-position-directly">Accessing the Slider or Wheel Position Directly</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-the-slider-or-wheel-position-indirectly">Accessing the Slider or Wheel Position Indirectly</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-the-slider-or-wheel-position-with-a-function-call">Accessing the Slider or Wheel Position with a Function Call</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#access-element-measurement-data">Access Element Measurement Data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">Accessing Element State Data Directly</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-element-measurement-data-indirectly">Accessing Element Measurement Data Indirectly</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#update-sensors-independently">Update Sensors Independently</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#capt-updatesensor">CAPT_updateSensor()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#capt-updatesensorwithemc">CAPT_updateSensorWithEMC()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#important-functionality-to-handle">Important Functionality to Handle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#full-implementation">Full Implementation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#update-a-sensor-s-raw-data-only">Update a Sensor&#8217;s Raw Data Only</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-a-custom-emc-configuration">Create a Custom EMC Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stream-unformatted-data-to-the-design-center-gui">Stream Unformatted Data to the Design Center GUI</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#technical-details">Technical Details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pre-compiled-libraries">Pre-Compiled Libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#devices-with-captivate-software-in-rom">Devices with CapTIvate™ Software in ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#msp430-cpux-memory-model">MSP430 CPUX Memory Model</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id3">Base Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hal">HAL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#touch">Touch</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sensor-update-routines">Sensor Update Routines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#environmental-drift-algorithms">Environmental Drift Algorithms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#isr">ISR</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-definitions">Type Definitions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id6">Advanced Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#calibration">Calibration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#calibration-background">Calibration Background</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gain-and-offset">Gain and Offset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#measurement-setup">Measurement Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calibration-routines">Calibration Routines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selecting-a-routine">Selecting a Routine</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#manager">Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buttons">Buttons</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sliders-and-wheels">Sliders and Wheels</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#supported-sizes">Supported Sizes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#supported-resolution">Supported Resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slider-endpoint-trim">Slider Endpoint Trim</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#emc">EMC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#emc-module-background">EMC Module Background</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-emc-module">Using the EMC Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#emc-module-algorithms">EMC Module Algorithms</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#communications-module">Communications Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#background">Background</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#layers">Layers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operating-modes">Operating Modes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#host-processor-communication">Host Processor Communication</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tutorial">Tutorial</a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#commonly-asked-questions">Commonly Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interface-layer">Interface Layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-the-communications-module-initializing-the-interface">Using the Communications Module: Initializing the Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-communications-module-handling-incoming-data">Using the Communications Module: Handling Incoming Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-communications-module-writing-out-data">Using the Communications Module: Writing Out Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compile-time-configuration">Compile-Time Configuration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#protocol-layer">Protocol Layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#use-cases">Use Cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="#introduction-to-packet-types">Introduction to Packet Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transmission-rules">Transmission Rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#format-sensor-packets">Format: Sensor Packets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#format-cycle-packets">Format: Cycle Packets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#format-trackpad-packets">Format: Trackpad Packets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#format-general-purpose-packets">Format: General Purpose Packets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#format-parameter-packets">Format: Parameter Packets</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#uart-driver">UART Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#related-documents">Related Documents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#purpose-of-the-driver">Purpose of the Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-features">Driver Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-overview">Driver Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compile-time-driver-configuration-options">Compile-time Driver Configuration Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#run-time-driver-configuration-options">Run-time Driver Configuration Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-driver-opening-and-closing-the-driver">Using the Driver: Opening and Closing the Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-driver-transmitting-data">Using the Driver: Transmitting Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-driver-receiving-data">Using the Driver: Receiving Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-driver-error-handling">Using the Driver: Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-driver-example-application">Using the Driver: Example Application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-driver-backchannel-uart-to-serial-terminal">Using the Driver: Backchannel UART to Serial Terminal</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#i2c-slave-driver">I2C Slave Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">Related Documents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">Purpose of the Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">Driver Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">Driver Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">Compile-time Driver Configuration Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">Run-time Driver Configuration Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">Using the Driver: Opening and Closing the Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-driver-transmitting-data-i2c-read-operation">Using the Driver: Transmitting Data (I2C Read Operation)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-driver-receiving-data-i2c-write-operation">Using the Driver: Receiving Data (I2C Write Operation)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">Using the Driver: Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">Using the Driver: Example Application</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#benchmarks">Benchmarks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#memory-requirements">Memory Requirements</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#code-fram-and-data-ram-requirements">CODE (FRAM) and DATA (RAM) Requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stack-requirements">Stack Requirements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#execution-times">Execution Times</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#top-level-capt-updateui">Top Level - CAPT_updateUI()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sensor-level-capt-updatesensor">Sensor Level - CAPT_updateSensor()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#low-level-capt-startconversionandwaituntildone">Low Level - CAPT_startConversionAndWaitUntilDone()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ch_evm.html">MSP-CAPT-FR2633 Development Kit</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_evm_boostxl_capkeypad.html">BOOSTXL-CAPKEYPAD Development Kit</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_evm_CAP_MINI.html">EVM430-CAPMINI</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_workshop.html">Workshop (Getting Started)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch_revision.html">Revision History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">CapTIvate &trade; Technology Guide</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Software Library</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="software-library">
<h1>Software Library<a class="headerlink" href="#software-library" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The CapTIvate™ Software Library is a collection of target software components designed to help shorten the development process when working with CapTIvate™ MCUs. The library is provided and supported by Texas Instruments and is delivered with the CapTIvate™ Design Center.</p>
<p>The library provides the following features:</p>
<ol class="arabic simple">
<li><strong>Hardware abstraction</strong> of the CapTIvate peripheral features</li>
<li><strong>Processing</strong> of button, slider, wheel, and proximity sensors with simple callback reporting when measurement and processing are complete</li>
<li><strong>User interface management</strong> to enable a simple top level API that is easy to use</li>
<li><strong>Electromagnetic compatibility</strong> features for improving noise immunity</li>
<li><strong>Communications</strong> infrastructure for connecting a CapTIvate™ MCU to the CapTIvate™ Design Center during tuning or to a host processor in an application</li>
</ol>
<p>These features provide the following main benefits:</p>
<ol class="arabic simple">
<li>Simplification of sensor configuration, measurement, processing and data communication</li>
<li>Faster application development cycles</li>
<li>Seamless integration with the CapTIvate™ Design Center development GUI</li>
<li>Reduced code footprint on devices with CapTIvate™ software in ROM</li>
</ol>
<p>The library was designed and organized for capacitive user interface applications. However, it may also be used for other applications that require the ability to measure relative changes in capacitance.</p>
<div class="section" id="using-this-chapter">
<h3>Using This Chapter<a class="headerlink" href="#using-this-chapter" title="Permalink to this headline">¶</a></h3>
<p>This chapter consists of the following main sections:</p>
<ol class="arabic simple">
<li>The <a class="reference external" href="ch_library.html#overview">Overview</a> section introduces the programming model, organization, and architecture of the library.</li>
<li>The <a class="reference external" href="ch_library.html#getting-started">Getting Started</a> section introduces how to get up and running with the starter project, as well as how to add CapTIvate™ to an existing software project.</li>
<li>The <a class="reference external" href="ch_library.html#how-to">How-To</a> section provides basic code snippets that demonstrate how to do basic things.</li>
<li>The <a class="reference external" href="ch_library.html#technical-details">Technical Details</a> section discusses advanced software implementation details.</li>
<li>The <a class="reference external" href="ch_library.html#base-module">Base Module</a>, <a class="reference external" href="ch_library.html#advanced-module">Advanced Module</a>, and <a class="reference external" href="ch_library.html#communications-module">Communications Module</a> sections each provide a detailed description of the respective software module for advanced users.</li>
</ol>
<p>The <a class="reference external" href="ch_library.html#getting-started">Getting Started</a> and <a class="reference external" href="ch_library.html#how-to">How-To</a> are the most helpful sections for new users that want to quickly begin developing applications.</p>
</div>
<div class="section" id="device-and-tools-support">
<h3>Device and Tools Support<a class="headerlink" href="#device-and-tools-support" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate™ Software Library can only be used with MSP devices that have CapTIvate™ technology.</p>
<p>For a list of supported devices, visit the <a class="reference external" href="ch_device.html#devices">device tables</a> in the <a class="reference external" href="ch_device.html">device family</a> chapter. This table also lists the minimum CCS, IAR, and CapTIvate Design Center versions for each device.</p>
<p><strong>Programming Language</strong></p>
<p>The software library is available in C. It follows C99 conventions and uses C99 primitives (uintX).</p>
</div>
<div class="section" id="delivery-mechanism">
<h3>Delivery Mechanism<a class="headerlink" href="#delivery-mechanism" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate™ Software Library and CapTIvate™ Design Center GUI have linked functionality. Features that exist in the software library are configurable via the Design Center, and data measured via the software library can be communicated back to the Design Center. Because of this, the software library and Design Center are always released together as one software download and installation. The Design Center is the sole point of access to the software library.</p>
</div>
<div class="section" id="change-control">
<h3>Change Control<a class="headerlink" href="#change-control" title="Permalink to this headline">¶</a></h3>
<p>Although they are delivered together, the CapTIvate Software Library has its own version tracking and change control. Every major library release comes with change control data in the Software Library API guide that describes any new features that have been added and any changes to existing functionality.</p>
<ul class="simple">
<li><a class="reference external" href="../../../../api_guide/FR2633/html/index.html">Access the software library API guide</a></li>
<li><a class="reference external" href="../../../../api_guide/FR2633/html/md_imports_01_changelog.html">Access the software library change control document</a></li>
</ul>
</div>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This section introduces the CapTIvate™ Software Library programming model, its organization and its architecture. It also discusses delivery of the library and version control.</p>
<div class="section" id="programming-model">
<h3>Programming Model<a class="headerlink" href="#programming-model" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate™ Software Library consists of several software <em>modules</em> and <em>sub-modules</em> that work together to provide various features and abstract complexity. The software library model will be introduced here in a &#8220;top-down&#8221; approach, starting from the highest point of abstraction and working downward to the lowest point.</p>
<div class="section" id="objects">
<h4>Objects<a class="headerlink" href="#objects" title="Permalink to this headline">¶</a></h4>
<p>The software library function calls operate on C structures which will be referred to in this section as objects. All of the main objects (C type definitions) for the software library are defined in the BASE module inside of the CAPT_Type.h header file. See the <a class="reference external" href="ch_library.html#type-definitions">type definitions</a> section for more details.</p>
<p><strong>Generic Capacitive Touch Application</strong></p>
<p>Capacitive sensing applications involve the continual measurement and post-processing of one or more capacitive sensors. As such, an application typically has the following flow:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">Initialize</span> <span class="n">MCU</span>
<span class="n">Initialize</span> <span class="n">user</span> <span class="n">interface</span>
<span class="n">Calibrate</span> <span class="n">user</span> <span class="n">interface</span>

<span class="n">Loop</span><span class="p">(</span><span class="n">Forever</span><span class="p">)</span>
    <span class="n">If</span> <span class="p">(</span><span class="n">Time</span> <span class="n">to</span> <span class="n">update</span> <span class="o">=</span> <span class="n">true</span><span class="p">)</span>
        <span class="n">Then</span>
            <span class="n">Update</span> <span class="n">user</span> <span class="n">interface</span>
            <span class="n">Report</span> <span class="n">user</span> <span class="n">interface</span> <span class="n">status</span>
    <span class="n">End</span> <span class="n">If</span>
</pre></div>
</div>
<div class="section" id="top-level-object-user-interface-application">
<h5>Top Level Object (User Interface Application)<a class="headerlink" href="#top-level-object-user-interface-application" title="Permalink to this headline">¶</a></h5>
<p>The CapTIvate™ Software Library utilizes this basic application model as the framework for the top level API and top level object. The top level object in the software library is the <strong>user interface application</strong>, or <a class="reference external" href="file:///C:/msp430_designcenter/Applications/Captivate/DesignCenter/docs/api_guide/FR2633/html/structtCaptivateApplication.html">tCaptivateApplication</a>. Functions are provided for initializing a user interface, calibrating a user interface, and updating a user interface. These functions are implemented as CAPT_initUI(), CAPT_calibrateUI(), and CAPT_updateUI(), respectively. An application can be created just by using these three functions. This is discussed in the <a class="reference external" href="ch_library.html#use-th-top-level-api">Use the Top Level API</a> section.</p>
<p>In order to realize the top level API, the top level object (tCaptivateApplication) holds information about the state of the user interface, how many sensors there are to update, where to find those sensors, and how often to update them.</p>
</div>
<div class="section" id="sensor-object">
<h5>Sensor Object<a class="headerlink" href="#sensor-object" title="Permalink to this headline">¶</a></h5>
<p>It then follows that the next object that is needed is a <strong>sensor</strong> object, or <a class="reference external" href="file:///C:/msp430_designcenter/Applications/Captivate/DesignCenter/docs/api_guide/FR2633/html/structtSensor.html">tSensor</a>. A sensor object is an abstracted user interface control. The software library supports button group, slider, wheel, and proximity sensor types. Every sensor object contains the following information:</p>
<ol class="arabic simple">
<li>Information about which electrodes to measure and how to measure them in parallel (element objects and time cycle objects)</li>
<li>Information about how to configure the CapTIvate™ technology peripheral for measurement (conversion control parameters)</li>
<li>Information about how to interpret the data from the measurement (tuning parameters)</li>
</ol>
<p>Various functions can operate on sensor objects directly. For example, it is possible to only update a particular sensor via a call to CAPT_updateSensor() or CAPT_updateSensorWithEMC(). The top level API function CAPT_updateUI() merely calls CAPT_updateSensor() or CAPT_updateSensorWithEMC() for each sensor in the UI application.</p>
</div>
<div class="section" id="time-cycle-object">
<h5>Time Cycle Object<a class="headerlink" href="#time-cycle-object" title="Permalink to this headline">¶</a></h5>
<p>The sensor object links to <strong>time cycle</strong> objects. A time cycle object is defined as <a class="reference external" href="file:///C:/msp430_designcenter/Applications/Captivate/DesignCenter/docs/api_guide/FR2633/html/structtCycle.html">tCycle</a>. A time cycle is nothing more than a group of element objects that may be measured in parallel.</p>
</div>
<div class="section" id="element-object">
<h5>Element Object<a class="headerlink" href="#element-object" title="Permalink to this headline">¶</a></h5>
<p>Element objects are the lowest abstraction level, and can be thought of as the software representation of a single electrode, whether it is self or mutual capacitance. Each element contains the following types of information:</p>
<ol class="arabic simple">
<li>Information about the pin(s) the electrode is connected to</li>
<li>Any tuning parameters that are specific to the element (such as a touch threshold)</li>
<li>Any data associated with the element (such as its current sample or long term average)</li>
<li>Any status flags that are specific to the element (such as touch or proximity status).</li>
</ol>
</div>
<div class="section" id="object-tree">
<h5>Object Tree<a class="headerlink" href="#object-tree" title="Permalink to this headline">¶</a></h5>
<p>As an example, a basic application with one sensor and 4 elements organized into two time cycles could be represented with the object tree diagram shown below.</p>
<div class="figure" id="id17">
<img alt="Example Application Object Tree" src="../_images/lib_objecttree_basic.png" />
<p class="caption"><span class="caption-number">Fig. 169 </span><span class="caption-text">Example Application Object Tree</span></p>
</div>
<p>In software, this configuration would have the following structure:</p>
<p><strong>Element Definitions</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Sensor</span><span class="p">:</span> <span class="n">keypad</span><span class="p">,</span> <span class="n">Element</span><span class="p">:</span> <span class="n">E00</span>
<span class="n">uint16_t</span> <span class="n">keypad_E00_RawCnts</span><span class="p">[</span><span class="n">CAPT_SELF_FREQ_CNT</span><span class="p">];</span>
<span class="n">tCaptivateElementTuning</span> <span class="n">keypad_E00_Tuning</span><span class="p">[</span><span class="n">CAPT_SELF_FREQ_CNT</span><span class="p">];</span>
<span class="n">tElement</span> <span class="n">keypad_E00</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">.</span><span class="n">ui8RxPin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8RxBlock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8TouchThreshold</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pRawCount</span> <span class="o">=</span> <span class="n">keypad_E00_RawCnts</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pTuning</span> <span class="o">=</span> <span class="n">keypad_E00_Tuning</span><span class="p">,</span>
<span class="p">};</span>

<span class="o">//</span> <span class="n">Sensor</span><span class="p">:</span> <span class="n">keypad</span><span class="p">,</span> <span class="n">Element</span><span class="p">:</span> <span class="n">E01</span>
<span class="n">uint16_t</span> <span class="n">keypad_E01_RawCnts</span><span class="p">[</span><span class="n">CAPT_SELF_FREQ_CNT</span><span class="p">];</span>
<span class="n">tCaptivateElementTuning</span> <span class="n">keypad_E01_Tuning</span><span class="p">[</span><span class="n">CAPT_SELF_FREQ_CNT</span><span class="p">];</span>
<span class="n">tElement</span> <span class="n">keypad_E01</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">.</span><span class="n">ui8RxPin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8RxBlock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8TouchThreshold</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pRawCount</span> <span class="o">=</span> <span class="n">keypad_E01_RawCnts</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pTuning</span> <span class="o">=</span> <span class="n">keypad_E01_Tuning</span><span class="p">,</span>
<span class="p">};</span>

<span class="o">//</span> <span class="n">Sensor</span><span class="p">:</span> <span class="n">keypad</span><span class="p">,</span> <span class="n">Element</span><span class="p">:</span> <span class="n">E02</span>
<span class="n">uint16_t</span> <span class="n">keypad_E02_RawCnts</span><span class="p">[</span><span class="n">CAPT_SELF_FREQ_CNT</span><span class="p">];</span>
<span class="n">tCaptivateElementTuning</span> <span class="n">keypad_E02_Tuning</span><span class="p">[</span><span class="n">CAPT_SELF_FREQ_CNT</span><span class="p">];</span>
<span class="n">tElement</span> <span class="n">keypad_E02</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">.</span><span class="n">ui8RxPin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8RxBlock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8TouchThreshold</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pRawCount</span> <span class="o">=</span> <span class="n">keypad_E02_RawCnts</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pTuning</span> <span class="o">=</span> <span class="n">keypad_E02_Tuning</span><span class="p">,</span>
<span class="p">};</span>

<span class="o">//</span> <span class="n">Sensor</span><span class="p">:</span> <span class="n">keypad</span><span class="p">,</span> <span class="n">Element</span><span class="p">:</span> <span class="n">E03</span>
<span class="n">uint16_t</span> <span class="n">keypad_E03_RawCnts</span><span class="p">[</span><span class="n">CAPT_SELF_FREQ_CNT</span><span class="p">];</span>
<span class="n">tCaptivateElementTuning</span> <span class="n">keypad_E03_Tuning</span><span class="p">[</span><span class="n">CAPT_SELF_FREQ_CNT</span><span class="p">];</span>
<span class="n">tElement</span> <span class="n">keypad_E03</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">.</span><span class="n">ui8RxPin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8RxBlock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8TouchThreshold</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pRawCount</span> <span class="o">=</span> <span class="n">keypad_E03_RawCnts</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pTuning</span> <span class="o">=</span> <span class="n">keypad_E03_Tuning</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that each element has three components:</p>
<ol class="arabic simple">
<li>An array for storing raw data after a measurement is complete (<strong>keypad_E0x_RawCnts[]</strong>)</li>
<li>An array for storing element tuning values (<strong>keypad_E0x_Tuning[]</strong>)</li>
<li>The element data object itself (<strong>keypad_E0x</strong>)</li>
</ol>
<p>The first component is the raw data array. Whenever an element is updated, the raw conversion results are populated in this array. Normally, the raw data array is an array of one value (keypad_E0x_RawCnts[1]). However, if noise immunity is enabled (EMC features), the raw data array may be larger to store conversion results from a multi-frequency conversion.</p>
<p>The second component is the element&#8217;s tuning. Each element is calibrated with specific coarse gain, fine gain, and offset subtraction values. To understand what these parameters effect, check out the <a class="reference external" href="ch_technology.html">CapTIvate peripheral</a> section of the <a class="reference external" href="ch_technology.html">technology</a> chapter. Just like the raw data array, the tuning is stored in an array as well. If multi-frequency scanning is used to support noise immunity, a tuning is stored for each conversion frequency.</p>
<p>The final component is the element data object (<strong>tElement</strong>). This object stores the pin definition for the element. An electrode on CAPx.y would be mapped in this way, where &#8216;x&#8217; is the CapTIvate™ measurement block the electrode is connected to, and &#8216;y&#8217; is the pin on that block.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">ui8RxPin</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span>
<span class="o">.</span><span class="n">ui8RxBlock</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span>
</pre></div>
</div>
<p>In addition to the pin connection information, the element object also stores the touch threshold for this element. This specifies the level of interaction required to trigger a touch detection. Each element has its own touch threshold.</p>
<p>Finally, the element object is linked to the raw data and tuning arrays via pointers.</p>
<p><strong>Time Cycle Definitions</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Time</span> <span class="n">Cycle</span><span class="p">:</span> <span class="n">keypad_C00</span>
<span class="n">tElement</span><span class="o">*</span> <span class="n">keypad_C00_Elements</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">keypad_E00</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">keypad_E01</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">tCycle</span> <span class="n">keypad_C00</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">.</span><span class="n">ui8NrOfElements</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pElements</span> <span class="o">=</span> <span class="n">keypad_C00_Elements</span><span class="p">,</span>
<span class="p">};</span>

<span class="o">//</span> <span class="n">Time</span> <span class="n">Cycle</span><span class="p">:</span> <span class="n">keypad_C01</span>
<span class="n">tElement</span><span class="o">*</span> <span class="n">keypad_C01_Elements</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">keypad_E02</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">keypad_E03</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">tCycle</span> <span class="n">keypad_C01</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">.</span><span class="n">ui8NrOfElements</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pElements</span> <span class="o">=</span> <span class="n">keypad_C01_Elements</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As discussed previously, time cycles are simply a collection of element objects that have the capability of being measured in parallel. Each time cycle is composed of two components:</p>
<ol class="arabic simple">
<li>An array of pointers to the elements in the cycle (<strong>keypad_C0x_Elements[]</strong>)</li>
<li>The cycle object itself (<strong>keypad_C0x</strong>)</li>
</ol>
<p>The array of element pointers provides the link to the element objects that belong to the cycle. The cycle object links to that array, and also defines how many elements are in the cycle.</p>
<p><strong>Sensor Definition</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">Sensor</span><span class="p">:</span> <span class="n">keypad</span>
<span class="n">const</span> <span class="n">tCycle</span><span class="o">*</span> <span class="n">keypad_Cycles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">keypad_C00</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">keypad_C01</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">tButtonSensorParams</span> <span class="n">keypad_Params</span><span class="p">;</span>
<span class="n">tSensor</span> <span class="n">keypad</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Basic</span> <span class="n">Properties</span>
    <span class="o">.</span><span class="n">TypeOfSensor</span> <span class="o">=</span> <span class="n">eButtonGroup</span><span class="p">,</span>
    <span class="o">.</span><span class="n">SensingMethod</span> <span class="o">=</span> <span class="n">eSelf</span><span class="p">,</span>
    <span class="o">.</span><span class="n">DirectionOfInterest</span> <span class="o">=</span> <span class="n">eDOIDown</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pvCallback</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8NrOfCycles</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pCycle</span> <span class="o">=</span> <span class="n">keypad_Cycles</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pSensorParams</span> <span class="o">=</span> <span class="p">(</span><span class="n">tGenericSensorParams</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">keypad_Params</span><span class="p">,</span>
    <span class="o">//</span> <span class="n">Conversion</span> <span class="n">Control</span> <span class="n">Parameters</span>
    <span class="o">.</span><span class="n">ui16ConversionCount</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui16ConversionGain</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8FreqDiv</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8ChargeLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8TransferLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bModEnable</span> <span class="o">=</span> <span class="n">false</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8BiasControl</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bCsDischarge</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bLpmControl</span> <span class="o">=</span> <span class="n">false</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8InputSyncControl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bTimerSyncControl</span> <span class="o">=</span> <span class="n">false</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bIdleState</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
    <span class="o">//</span> <span class="n">Tuning</span>  <span class="n">Parameters</span>
    <span class="o">.</span><span class="n">ui16ProxThreshold</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui16NegativeTouchThreshold</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui16ErrorThreshold</span> <span class="o">=</span> <span class="mi">8191</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui16TimeoutThreshold</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ProxDbThreshold</span><span class="o">.</span><span class="n">DbIn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ProxDbThreshold</span><span class="o">.</span><span class="n">DbOut</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">TouchDbThreshold</span><span class="o">.</span><span class="n">DbIn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">TouchDbThreshold</span><span class="o">.</span><span class="n">DbOut</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bCountFilterEnable</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8CntBeta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bSensorHalt</span> <span class="o">=</span> <span class="n">false</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bPTSensorHalt</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bPTElementHalt</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8LTABeta</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bReCalibrateEnable</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The sensor definition has three components:</p>
<ol class="arabic simple">
<li>An array of pointers to the cycles in the sensor (<strong>keypad_Cycles[]</strong>)</li>
<li>The sensor type specific parameters (in this case, a button group) (<strong>keypad_Params</strong>)</li>
<li>The generic sensor object itself (<strong>keypad</strong>)</li>
</ol>
<p>The pointer to cycle array allows the sensor to find its child objects (cycles, and through the cycles, the elements). The sensor type specific parameters component stores parameters that are specific to a sensor type. For example, a button group, slider/wheel, and proximity sensor all have different parameter structures.</p>
<p>The remainder of the parameters in the sensor object provides the conversion control and tuning configuration, as set up in the CapTIvate™ Design Center.</p>
<p><strong>UI Application Definition</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Application</span>
<span class="n">tSensor</span><span class="o">*</span> <span class="n">g_pCaptivateSensorArray</span><span class="p">[</span><span class="n">CAPT_SENSOR_COUNT</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">keypad</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">tCaptivateApplication</span> <span class="n">g_uiApp</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">eUIActive</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pSensorList</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">g_pCaptivateSensorArray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="o">.</span><span class="n">ui8NrOfSensors</span> <span class="o">=</span> <span class="n">CAPT_SENSOR_COUNT</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8AppLPM</span> <span class="o">=</span> <span class="n">LPM0_bits</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bElementDataTxEnable</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bSensorDataTxEnable</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui16ActiveModeScanPeriod</span> <span class="o">=</span> <span class="mi">33</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui16WakeOnProxModeScanPeriod</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui16InactivityTimeout</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8WakeupInterval</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The application definition has two components:</p>
<ol class="arabic simple">
<li>An array of pointers to the sensors in the application (<strong>g_pCaptivateSensorArray[]</strong>)</li>
<li>The application object itself (<strong>g_uiApp</strong>)</li>
</ol>
<p>The array of pointers to sensors allows the top level API to find all of the sensors in the application through the application structure. Note that the application structure also defines the following items:</p>
<ol class="arabic simple">
<li>The low power mode to use during conversions (.ui8AppLPM)</li>
<li>Element and sensor data transmission enable/disable (.bElementDataTxEnable, .bSensorDataTxEnable)</li>
<li>The scan periods to use in active mode (.ui16ActiveModeScanPeriod)</li>
<li>A place holder for wake-on-proximity parameters (.ui16WakeOnProxModeScanPeriod, .ui16InactivityTimeout, .ui8WakeupInterval)</li>
</ol>
</div>
</div>
<div class="section" id="accessing-measurement-results-and-data">
<h4>Accessing Measurement Results and Data<a class="headerlink" href="#accessing-measurement-results-and-data" title="Permalink to this headline">¶</a></h4>
<p>In general, the software library operates on the principle of refreshing data inside of objects, rather than returning results directly via a function call. For example, when a top level API call is made to a function like CAPT_updateUI(), all sensors in the UI and each of those sensor&#8217;s child elements will have their data structures refreshed. CAPT_updateUI() does not provide any status information directly when returning to the application.</p>
<p>As such, it is the responsibility of the application to directly access the results of a measurement in the appropriate object data structure. A <a class="reference external" href="ch_library.html#register-a-callback-function">callback function</a> may be registered with any sensor, that will be called whenever a sensor&#8217;s data is refreshed.</p>
</div>
</div>
<div class="section" id="organization-and-architecture">
<h3>Organization and Architecture<a class="headerlink" href="#organization-and-architecture" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate™ Software Library is organized into three major modules by functionality: <strong>BASE</strong>, <strong>ADVANCED</strong>, and <strong>COMM</strong>. Each module has several sub-modules, or &#8220;layers&#8221;. Some of those sub-modules are delivered as source code; others are delivered as object code.</p>
<div class="section" id="base-module">
<h4>BASE Module<a class="headerlink" href="#base-module" title="Permalink to this headline">¶</a></h4>
<p>The <strong>BASE</strong> module is the core of the software library. It contains the hardware abstraction layer, the touch layer, the interrupt service routine (ISR), and the type definitions for the library. The touch layer acts as a &#8220;hub,&#8221; providing functions for calibrating, measuring, and processing sensors. For a detailed overview of the <strong>BASE</strong> module, see the <a class="reference external" href="ch_library.html#base-module">Base Module</a> section.</p>
</div>
<div class="section" id="advanced-module">
<h4>ADVANCED Module<a class="headerlink" href="#advanced-module" title="Permalink to this headline">¶</a></h4>
<p>The <strong>ADVANCED</strong> module provides several processing plug-ins to the <strong>BASE</strong> module. This includes button processing, slider and wheel processing, and EMC processing for noise immunity. It also contains the manager layer, which serves as the top level API for the library.</p>
<p>The basic software stack is shown below.</p>
<div class="figure" id="id18">
<img alt="CapTIvate™ Software Library Organization (Without COMMs)" src="../_images/lib_architecture_nocomm.png" />
<p class="caption"><span class="caption-number">Fig. 170 </span><span class="caption-text">CapTIvate™ Software Library Organization (Without COMMs)</span></p>
</div>
<p>As shown here, from the application space it is only necessary to call the top level API functions in the manager layer to have a functioning application. The touch layer handles pulling in the necessary plug-ins (button, slider/wheel, EMC), so there is no need to call these functions from the application space. For a detailed overview of the <strong>ADVANCED</strong> module, see the <a class="reference external" href="ch_library.html#advanced-module">Advanced Module</a> section.</p>
</div>
<div class="section" id="user-configuration">
<h4>User Configuration<a class="headerlink" href="#user-configuration" title="Permalink to this headline">¶</a></h4>
<p>Every CapTIvate™ application has a user configuration that defines all of the objects on the application. This includes the application, sensor, cycle, and element object definitions. This configuration is typically auto-generated by the CapTIvate™ Design Center.</p>
</div>
<div class="section" id="comm-module">
<h4>COMM Module<a class="headerlink" href="#comm-module" title="Permalink to this headline">¶</a></h4>
<p>The <strong>COMM</strong> module provides communication services to either a host processor or the CapTIvate Design Center. It contains a top level interface layer, a protocol layer, serial drivers, and several data structures. The expanded software stack with the communications module is shown below. For a detailed overview of the <strong>COMM</strong> module, see the <a class="reference external" href="ch_library.html#id6">Communications Module</a> section.</p>
<div class="figure" id="id19">
<img alt="CapTIvate™ Software Library Organization (With COMMs)" src="../_images/lib_architecture.png" />
<p class="caption"><span class="caption-number">Fig. 171 </span><span class="caption-text">CapTIvate™ Software Library Organization (With COMMs)</span></p>
</div>
</div>
<div class="section" id="source-code-directory-structure">
<h4>Source Code Directory Structure<a class="headerlink" href="#source-code-directory-structure" title="Permalink to this headline">¶</a></h4>
<p>The library source code is organized into sub-directories by module (<strong>BASE</strong>, <strong>ADVANCED</strong>, or <strong>COMM</strong>). In addition to the HAL, Touch, and ISR components, the <strong>BASE</strong> directory contains the following files:</p>
<ul class="simple">
<li><strong>captivate.lib</strong> This is the CCS library archive. It contains all of the functions that are pre-compiled and delivered as object code for linking against the CCS compiler.</li>
<li><strong>captivate.r43</strong> This is the IAR library archive. It contains all of the functions that are pre-compiled and delivered as object code for linking against the IAR compiler.</li>
<li><strong>lnk_captivate.cmd</strong> This linker command file tells the CCS linker about the CapTIvate peripheral address space.</li>
<li><strong>rom_captivate.h</strong> This is the ROM function header file. It defines the ROM function calls based on the ROM function table.</li>
<li><strong>rom_map_captivate.h</strong> This is the ROM map header file. It controls which ROM functions are valid for the version of the library that is being compiled. When making ROM calls, it is best to use the MAP_* convention. See the <a class="reference external" href="ch_library.html#devices-with-captivate-software-in-rom">ROM function overview</a> for details on how to call ROM functions.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="getting-started">
<h2>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<div class="section" id="starting-from-scratch-with-the-starter-project">
<h3>Starting from Scratch with the Starter Project<a class="headerlink" href="#starting-from-scratch-with-the-starter-project" title="Permalink to this headline">¶</a></h3>
<p>The recommended way to get started with a CapTIvate™ software library project is to generate a new starter software project with the CapTIvate™ Design Center. To learn how to do this, step through the <a class="reference external" href="ch_workshop.html#creating-a-new-sensor-design-project">new sensor project design workshop</a>.</p>
<p>This section will focus on the features of the starter project itself. The software library starter projected is a ready-to-go application that includes the following software components:</p>
<ol class="arabic simple">
<li>The CapTIvate™ Software Library</li>
<li>The MSP Peripheral Driver Library (DriverLib), delivered as pre-compiled object code</li>
<li>A board support package, configured for the MSP-CAPT-FR2633 EVM</li>
<li>An example application with wake-on-proximity support built-in</li>
<li>An example main.c</li>
</ol>
<p>The starter project contains everything that is needed to bring up the MCU, calibrate and run a capacitive sensing application per the specified user configuration, and communicate measurement data. It serves as a known-good starting point for new development and tuning. Once an application is tuned, features can be added and removed from the starter application to build toward a final production application.</p>
<div class="section" id="directory-structure">
<h4>Directory Structure<a class="headerlink" href="#directory-structure" title="Permalink to this headline">¶</a></h4>
<p>The directory structure of the starter project is shown below in CCS:</p>
<div class="figure" id="id20">
<img alt="Starter Project Files" src="../_images/starter_project_files.png" />
<p class="caption"><span class="caption-number">Fig. 172 </span><span class="caption-text">Starter Project Files</span></p>
</div>
<p>The <em>captivate</em> directory contains the CapTIvate™ Software Library. This directory will likely not need to be edited during development.</p>
<p>The <em>captivate_app</em> directory contains the board support package (CAPT_BSP) and the example wake-on-proximity application (CAPT_APP). This directory contains starter files that should be modified to suit the needs of each individual application.</p>
<p>The <em>captivate_config</em> directory contains the automatically generated user configuration files that describe the capacitive sensing application as specified in the CapTIvate™ Design Center. The CAPT_UserConfig.c and CAPT_UserConfig.h files in this directory <strong>should never be edited manually</strong>, as changes made to these files are <strong>overwritten if the Design Center is utilized to update the configuration</strong>. For this reason, it is best to modify all configuration parameters from inside the Design Center.</p>
<p>The <em>driverlib</em> directory contains the MSP430 peripheral driver library. To lower compilation times, it is delivered as a pre-compiled library archive. It is possible to replace this DriverLib directory with the standard, open-source driver library, if desired.</p>
</div>
<div class="section" id="main">
<h4>Main<a class="headerlink" href="#main" title="Permalink to this headline">¶</a></h4>
<p>The starter application main.c is shown below:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##include &lt;msp430.h&gt;                      // Generic MSP430 Device Include</span>
<span class="c1">##include &quot;driverlib.h&quot;                   // MSPWare Driver Library</span>
<span class="c1">##include &quot;captivate.h&quot;                   // CapTIvate Touch Software Library</span>
<span class="c1">##include &quot;CAPT_App.h&quot;                    // CapTIvate Application Code</span>
<span class="c1">##include &quot;CAPT_BSP.h&quot;                    // CapTIvate EVM Board Support Package</span>

<span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Initialize</span> <span class="n">the</span> <span class="n">MCU</span>
    <span class="o">//</span> <span class="n">BSP_configureMCU</span><span class="p">()</span> <span class="n">sets</span> <span class="n">up</span> <span class="n">the</span> <span class="n">device</span> <span class="n">IO</span> <span class="ow">and</span> <span class="n">clocking</span>
    <span class="o">//</span> <span class="n">The</span> <span class="k">global</span> <span class="n">interrupt</span> <span class="n">enable</span> <span class="ow">is</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">allow</span> <span class="n">peripherals</span>
    <span class="o">//</span> <span class="n">to</span> <span class="n">wake</span> <span class="n">the</span> <span class="n">MCU</span><span class="o">.</span>
    <span class="o">//</span>
    <span class="n">WDT_A_hold</span><span class="p">(</span><span class="n">WDT_A_BASE</span><span class="p">);</span>
    <span class="n">BSP_configureMCU</span><span class="p">();</span>
    <span class="n">__bis_SR_register</span><span class="p">(</span><span class="n">GIE</span><span class="p">);</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Start</span> <span class="n">the</span> <span class="n">CapTIvate</span> <span class="n">application</span>
    <span class="o">//</span>
    <span class="n">CAPT_appStart</span><span class="p">();</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Background</span> <span class="n">Loop</span>
    <span class="o">//</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span>
        <span class="o">//</span> <span class="n">Run</span> <span class="n">the</span> <span class="n">captivate</span> <span class="n">application</span> <span class="n">handler</span><span class="o">.</span>
        <span class="o">//</span> <span class="n">Set</span> <span class="n">LED1</span> <span class="k">while</span> <span class="n">the</span> <span class="n">app</span> <span class="n">handler</span> <span class="ow">is</span> <span class="n">running</span><span class="p">,</span>
        <span class="o">//</span> <span class="ow">and</span> <span class="nb">set</span> <span class="n">LED2</span> <span class="k">if</span> <span class="n">proximity</span> <span class="ow">is</span> <span class="n">detected</span>
        <span class="o">//</span> <span class="n">on</span> <span class="nb">any</span> <span class="n">sensor</span><span class="o">.</span>
        <span class="o">//</span>
        <span class="n">LED1_ON</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">CAPT_appHandler</span><span class="p">()</span><span class="o">==</span><span class="n">true</span><span class="p">)</span>
            <span class="n">LED2_ON</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">LED2_OFF</span><span class="p">;</span>
        <span class="n">LED1_OFF</span><span class="p">;</span>

        <span class="o">//</span>
        <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">great</span> <span class="n">place</span> <span class="n">to</span> <span class="n">add</span> <span class="ow">in</span> <span class="nb">any</span>
        <span class="o">//</span> <span class="n">background</span> <span class="n">application</span> <span class="n">code</span><span class="o">.</span>
        <span class="o">//</span>
        <span class="n">__no_operation</span><span class="p">();</span>

        <span class="o">//</span>
        <span class="o">//</span> <span class="n">End</span> <span class="n">of</span> <span class="n">background</span> <span class="n">loop</span> <span class="n">iteration</span>
        <span class="o">//</span> <span class="n">Go</span> <span class="n">to</span> <span class="n">sleep</span> <span class="k">if</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">nothing</span> <span class="n">left</span> <span class="n">to</span> <span class="n">do</span>
        <span class="o">//</span>
        <span class="n">CAPT_appSleep</span><span class="p">();</span>

    <span class="p">}</span> <span class="o">//</span> <span class="n">End</span> <span class="n">background</span> <span class="n">loop</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">End</span> <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>The <strong>main()</strong> routine disables the watchdog timer, initializes the MCU via the board support package, and starts the capacitive sensing application. It then spends the rest of its time inside the application background loop. LED1 is toggled whenever the application handler is called, and LED2 is set whenever the <strong>CAPT_appHandler()</strong> function returns true, indicating that any sensor has a proximity detection. After the app handler runs, a call to <strong>CAPT_appSleep()</strong> will put the MCU to sleep if there are no pending flags that need to be serviced. The CapTIvate™ conversion timer interrupt will wake the application each time the user interface needs to be refreshed.</p>
</div>
<div class="section" id="board-support-package-capt-bsp">
<h4>Board Support Package (CAPT_BSP)<a class="headerlink" href="#board-support-package-capt-bsp" title="Permalink to this headline">¶</a></h4>
<p>The board support package configures the MCU for operation with the following parameters:</p>
<ul class="simple">
<li>Watchdog timer is disabled</li>
<li>16 MHz DCO Frequency</li>
<li>16 MHz MCLK, sourced from the DCO</li>
<li>2 MHz SMCLK, sourced from the DCO</li>
<li>32 kHz ACLK, sourced from an external crystal (if connected) or the internal REFO</li>
<li>USCI_A0 and USCI_B0 are muxed to pins to allow for communication</li>
</ul>
<p>The port muxing is configured for the CAPTIVATE-FR2633 processor module. <strong>The board support package should be ported to the platform and device used in each application!</strong></p>
</div>
<div class="section" id="example-application-capt-app">
<h4>Example Application (CAPT_App)<a class="headerlink" href="#example-application-capt-app" title="Permalink to this headline">¶</a></h4>
<p>The example application demonstrates how to enable a generic capacitive sensing application with or without wake-on-proximity. It includes three functions:</p>
<ul class="simple">
<li>CAPT_appStart()</li>
<li>CAPT_appHandler()</li>
<li>CAPT_appSleep()</li>
</ul>
<div class="section" id="capt-appstart">
<h5>CAPT_appStart()<a class="headerlink" href="#capt-appstart" title="Permalink to this headline">¶</a></h5>
<p>This function provides an example of the functions that need to be called to configure the CapTIvate™ Software Library for operation. It handles the following tasks:</p>
<ol class="arabic simple">
<li>Initializing and calibrating the capacitive sensing UI via the CapTIvate™ Software Library top level API calls</li>
<li>Configuring and starting the CapTIvate™ timer for periodic interrupts</li>
</ol>
<p>As discussed in the <a class="reference external" href="ch_library.html#use-th-top-level-api">guide for using the top level API</a>, it is necessary to call <strong>CAPT_initUI()</strong> and <strong>CAPT_calibrateUI()</strong> when starting a CapTIvate™ software library application. These functions configure the CapTIvate™ peripheral and calibrate all of the elements in the UI. If noise immunity (EMC) functionality is going to be used, it is also necessary to load an EMC configuration structure via a call to <strong>CAPT_loadEMCConfig()</strong>. Note that in the actual example CAPT_appStart() function, the <strong>CAPT_loadEMCConfig()</strong> function is a compile-time include.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>CAPT_initUI(&amp;g_uiApp);
CAPT_loadEMCConfig(&amp;g_EMCConfig); // (Only needed if EMC features are enabled!)
CAPT_calibrateUI(&amp;g_uiApp);
</pre></div>
</div>
<p>The integrated CapTIvate™ conversion timer is a periodic timer that can be used to generate an interrupt or directly trigger a conversion at a specified interval. The timer is configured via HAL function calls, as shown below. Note that these HAL functions are available in ROM on devices with CapTIvate™ software in ROM- hence the <strong>MAP_</strong> calls. For more information on ROM software, see the <a class="reference external" href="ch_library.html#devices-with-captivate-software-in-rom">ROM</a> section.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">MAP_CAPT_stopTimer</span><span class="p">();</span>
<span class="n">MAP_CAPT_clearTimer</span><span class="p">();</span>
<span class="n">MAP_CAPT_selectTimerSource</span><span class="p">(</span><span class="n">CAPT_TIMER_SRC_ACLK</span><span class="p">);</span>
<span class="n">MAP_CAPT_selectTimerSourceDivider</span><span class="p">(</span><span class="n">CAPT_TIMER_CLKDIV__1</span><span class="p">);</span>
<span class="n">MAP_CAPT_writeTimerCompRegister</span><span class="p">(</span><span class="n">CAPT_MS_TO_CYCLES</span><span class="p">(</span><span class="n">g_uiApp</span><span class="o">.</span><span class="n">ui16ActiveModeScanPeriod</span><span class="p">));</span>
<span class="n">MAP_CAPT_startTimer</span><span class="p">();</span>
<span class="n">MAP_CAPT_enableISR</span><span class="p">(</span><span class="n">CAPT_TIMER_INTERRUPT</span><span class="p">);</span>
</pre></div>
</div>
<p>These setup functions configure the timer to be sourced from ACLK (32 kHz in this starter project). An input divider of 1 is selected, and the compare register is set to the active mode scan period, converted to cycles. The macro <strong>CAPT_MS_TO_CYCLES</strong> approximates the number of 32 kHz clock cycles needed to produce the desired scan rate by multiplying the saved value (in milliseconds) by 32 (via a 5x bit shift). The timer interrupt is enabled to start the application. When the timer interrupt is asserted by the timer, the CapTIvate™ peripheral interrupt handler will run. The interrupt handler is in the BASE layer of the CapTIvate™ library, and is available in source code for transparency.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##pragma vector=CAPTIVATE_VECTOR</span>
<span class="n">__interrupt</span> <span class="n">void</span> <span class="n">CAPT_ISR</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">switch</span><span class="p">(</span><span class="n">__even_in_range</span><span class="p">(</span><span class="n">CAPT_getInterruptVector</span><span class="p">(),</span> <span class="n">CAPT_IV_MAX_COUNT_ERROR</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">End</span> <span class="n">of</span> <span class="n">Conversion</span> <span class="n">Interrupt</span>
        <span class="n">case</span> <span class="n">CAPT_IV_END_OF_CONVERSION</span><span class="p">:</span>
            <span class="n">g_bEndOfConversionFlag</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">Detection</span> <span class="n">Interrupt</span>
        <span class="n">case</span> <span class="n">CAPT_IV_DETECTION</span><span class="p">:</span>
            <span class="n">g_bDetectionFlag</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">Timer</span> <span class="n">Interrupt</span>
        <span class="n">case</span> <span class="n">CAPT_IV_TIMER</span><span class="p">:</span>
            <span class="n">g_bConvTimerFlag</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">Conversion</span> <span class="n">Counter</span> <span class="n">Interrupt</span>
        <span class="n">case</span> <span class="n">CAPT_IV_CONVERSION_COUNTER</span><span class="p">:</span>
            <span class="n">g_bConvCounterFlag</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">Max</span> <span class="n">Count</span> <span class="n">Error</span> <span class="n">Interrupt</span>
        <span class="n">case</span> <span class="n">CAPT_IV_MAX_COUNT_ERROR</span><span class="p">:</span>
            <span class="n">g_bMaxCountErrorFlag</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">__bic_SR_register_on_exit</span><span class="p">(</span><span class="n">LPM3_bits</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The interrupt handler will set the appropriate flag, and it always exits active. Therefore, the application merely needs to monitor the <strong>g_bConvTimerFlag</strong> boolean value to known when the timer has tripped, meaning that it is time to update the user interface.</p>
</div>
<div class="section" id="capt-apphandler">
<h5>CAPT_appHandler()<a class="headerlink" href="#capt-apphandler" title="Permalink to this headline">¶</a></h5>
<p>The application handler function must be periodically called from the application background loop, as shown in <strong>main.c</strong>. At first glance, the function appears quite complex- but really, all the application handler does is manage when the UI needs to be updated (in active mode), as well as manage the transitions between active mode and wake-on-proximity mode.</p>
<p>The application handler makes use of several convenience variables in the CapTIvate™ top level application object:</p>
<ul class="simple">
<li>The active mode scan period</li>
<li>The wake on proximity mode scan period</li>
<li>The inactivity time-out</li>
<li>The wakeup interval</li>
</ul>
<p>It may be configured at compile time for two different modes of operation:</p>
<ol class="arabic simple">
<li>Active mode only (No wake-on-proximity state handling). This is the reduced memory footprint option.</li>
<li>Active mode with wake-on-proximity management. This option requires more memory to handle the wake-on-proximity management.</li>
</ol>
<p>The compile time mode is determined by settings in the user configuration header file (CAPT_UserConfig.h in the <em>CAPT_config</em> directory):</p>
<p><strong>Active Mode Only Configuration</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##define CAPT_WAKEONPROX_ENABLE  (false)</span>
<span class="c1">##define CAPT_WAKEONPROX_SENSOR  (none)</span>
</pre></div>
</div>
<p><strong>Active Mode with Wake-on-Proximity Configuration</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##define CAPT_WAKEONPROX_ENABLE  (true)</span>
<span class="c1">##define CAPT_WAKEONPROX_SENSOR  (selected sensor)</span>
</pre></div>
</div>
<p>These options can and should be configured through the CapTIvate™ Design Center. See the <a class="reference external" href="ch_designcenter.html#select-compile-time-options">Compile Time Options</a> section for details.</p>
<p>Active mode is characterized by the following behavior:</p>
<ul class="simple">
<li>The CapTIvate™ conversion timer is used in interrupt mode to wake the CPU at a specified interval</li>
<li>When the <strong>g_bConvTimerFlag</strong> is asserted, <strong>CAPT_updateUI()</strong> is called to refresh all sensors in the UI under CPU control.</li>
</ul>
<p>Wake-on-proximity mode is characterized by the following behavior:</p>
<ul class="simple">
<li>The CapTIvate™ conversion timer is used in timer-triggered conversion mode to automatically start a conversion of a single time cycle at a specified interval without any CPU intervention</li>
<li>When any element in the time cycle selected for wake-on-proximity has a proximity threshold crossing or negative touch threshold crossing, the detection flag (<strong>g_bDetectionFlag</strong>) is asserted and the application switches to active mode</li>
<li>If the conversion counter flag (<strong>g_bConvCounterFlag</strong>)is asserted, the application switches to active mode</li>
</ul>
<p>CAPT_appHandler() Compiled for Active Mode Only</p>
<p>The diagram below describes the behaviour of the application handler when compiled for active mode support only.</p>
<div class="figure" id="id21">
<img alt="CAPT\_appHandler() with Active Mode Only Support" src="../_images/app_handler_basic.png" />
<p class="caption"><span class="caption-number">Fig. 173 </span><span class="caption-text">CAPT_appHandler() with Active Mode Only Support</span></p>
</div>
<p>When compiled for active mode only, the function is pre-processed down to this basic set of functionality:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">CAPT_appHandler</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="nb">bool</span> <span class="n">bActivity</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">g_bConvTimerFlag</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span>
        <span class="o">//</span> <span class="n">Clear</span> <span class="n">the</span> <span class="n">conversion</span> <span class="n">timer</span> <span class="n">flag</span><span class="p">,</span>
        <span class="o">//</span> <span class="ow">and</span> <span class="n">update</span> <span class="n">the</span> <span class="n">UI</span>
        <span class="o">//</span>
        <span class="n">g_bConvTimerFlag</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
        <span class="n">CAPT_updateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
        <span class="n">bActivity</span> <span class="o">=</span> <span class="n">CAPT_getGlobalUIProximityStatus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">bActivity</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since the CapTIvate™ conversion timer was already configured by <strong>CAPT_appStart()</strong>, all that is needed is to test the <strong>g_bConvTimerFlag</strong>. If it is set, then the application handler clears it, updates the UI via <strong>CAPT_updateUI()</strong>, and checks to see if any elements in the UI have a proximity detection. The function returns true if any element was in proximity, else false.</p>
<p>If communications are enabled, the function also checks for incoming packets as shown below:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">CAPT_appHandler</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="nb">bool</span> <span class="n">bActivity</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">g_bConvTimerFlag</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span>
        <span class="o">//</span> <span class="n">Clear</span> <span class="n">the</span> <span class="n">conversion</span> <span class="n">timer</span> <span class="n">flag</span><span class="p">,</span>
        <span class="o">//</span> <span class="ow">and</span> <span class="n">update</span> <span class="n">the</span> <span class="n">UI</span>
        <span class="o">//</span>
        <span class="n">g_bConvTimerFlag</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
        <span class="n">CAPT_updateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
        <span class="n">bActivity</span> <span class="o">=</span> <span class="n">CAPT_getGlobalUIProximityStatus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">If</span> <span class="n">communications</span> <span class="n">are</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">check</span> <span class="k">for</span> <span class="nb">any</span> <span class="n">incoming</span> <span class="n">packets</span><span class="o">.</span>
    <span class="o">//</span>
    <span class="n">CAPT_checkForInboundPacket</span><span class="p">();</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Check</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">the</span> <span class="n">packet</span> <span class="n">requested</span> <span class="n">a</span> <span class="n">re</span><span class="o">-</span><span class="n">calibration</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">If</span> <span class="n">wake</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">prox</span> <span class="ow">is</span> <span class="n">enabled</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">current</span> <span class="n">application</span> <span class="n">state</span>
    <span class="o">//</span> <span class="ow">is</span> <span class="n">wake</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">prox</span><span class="p">,</span> <span class="n">disable</span> <span class="n">the</span> <span class="n">wake</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">prox</span> <span class="n">feature</span> <span class="n">during</span> <span class="n">the</span> <span class="n">calibration</span>
    <span class="o">//</span> <span class="ow">and</span> <span class="n">re</span><span class="o">-</span><span class="n">enable</span> <span class="n">it</span> <span class="n">after</span> <span class="n">the</span> <span class="n">calibration</span><span class="o">.</span>
    <span class="o">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CAPT_checkForRecalibrationRequest</span><span class="p">()</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">CAPT_calibrateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">bActivity</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A call is made to <strong>CAPT_checkForInboundPacket()</strong> to see if any packets have been received that need processing. Some parameter packets (such as a sensor&#8217;s conversion count) require that a re-calibration take place. The <strong>CAPT_checkForRecalibrationRequest()</strong> checks to see if a re-calibration request is pending.</p>
<p>Note that if <strong>g_bConvTimerFlag</strong> is false, the function is essentially non-blocking. This allows the background loop in <strong>main()</strong> to service other application tasks, while just periodically calling <strong>CAPT_appHandler()</strong> to see if it is time to do something.</p>
<p>CAPT_appHandler() Compiled for Active Mode with Wake-on-Proximity Mode</p>
<p>When compiled with wake-on-proximity mode enabled, the application handler manages transitions between active mode and wake-on-proximity mode. The application starts in active mode, and follows the flow shown below:</p>
<div class="figure" id="id22">
<img alt="CAPT\_appHandler() with Wake-on-Proximity Support" src="../_images/app_handler_wop.png" />
<p class="caption"><span class="caption-number">Fig. 174 </span><span class="caption-text">CAPT_appHandler() with Wake-on-Proximity Support</span></p>
</div>
<p>The wake-on-proximity feature allows for one time cycle to be measured and processed autonomously with no CPU interaction until a detection, counter interrupt, or error condition occurs. This is useful for applications that have a power key or a proximity sensor that is used to wake up the rest of the system, since that sensor may be scanned with no CPU overhead. When a detection does occur, the handler switches operation to active mode and the entire user interface is scanned under CPU control.</p>
<p>The application remains in active mode under CPU control as long as at least one element is in proximity detect. Once all elements are clear of proximity, the session time-out counter begins counting down. This counter will keep the system in active mode for the specified number of samples before returning into wake-on-proximity mode. The timeout is specified in the application object via the <strong>ui16InactivityTimeout</strong> parameter.</p>
<p>In addition to waking on a detection, it is also possible to periodically wake up into active mode after a certain number of conversions have taken place in wake-on-proximity mode. This is useful to ensure that all the other sensors in the system have current long term averages (LTAs) to account for environmental drift. The conversion counter interrupt may be used to specify a wakeup period.</p>
<p>These wakeup sources are discussed further in the <a class="reference external" href="ch_glossary.html#system-wakeonprox-mode">wake-on-proximity</a> description.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">CAPT_appHandler</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="n">uint16_t</span> <span class="n">g_ui16UISessionTimeoutCtr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">static</span> <span class="nb">bool</span> <span class="n">bActivity</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>

    <span class="n">switch</span> <span class="p">(</span><span class="n">g_uiApp</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">case</span> <span class="n">eUIActive</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">g_bConvTimerFlag</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="o">//</span>
                <span class="o">//</span> <span class="n">Clear</span> <span class="n">the</span> <span class="n">conversion</span> <span class="n">timer</span> <span class="n">flag</span><span class="p">,</span>
                <span class="o">//</span> <span class="ow">and</span> <span class="n">update</span> <span class="n">the</span> <span class="n">UI</span>
                <span class="o">//</span>
                <span class="n">g_bConvTimerFlag</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
                <span class="n">CAPT_updateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
                <span class="n">bActivity</span> <span class="o">=</span> <span class="n">CAPT_getGlobalUIProximityStatus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>

                <span class="o">//</span>
                <span class="o">//</span> <span class="n">If</span> <span class="n">autonomous</span> <span class="n">mode</span> <span class="ow">is</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">check</span> <span class="n">to</span>
                <span class="o">//</span> <span class="n">see</span> <span class="k">if</span> <span class="n">autonomous</span> <span class="n">mode</span> <span class="n">should</span> <span class="n">be</span> <span class="n">entered</span><span class="o">.</span>
                <span class="o">//</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">bActivity</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="o">//</span>
                    <span class="o">//</span> <span class="n">If</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">still</span> <span class="n">a</span> <span class="n">prox</span> <span class="n">detection</span><span class="p">,</span>
                    <span class="o">//</span> <span class="n">reset</span> <span class="n">the</span> <span class="n">session</span> <span class="n">timeout</span> <span class="n">counter</span><span class="o">.</span>
                    <span class="o">//</span>
                    <span class="n">g_ui16UISessionTimeoutCtr</span> <span class="o">=</span> <span class="n">g_uiApp</span><span class="o">.</span><span class="n">ui16InactivityTimeout</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">g_ui16UISessionTimeoutCtr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="o">//</span>
                    <span class="o">//</span> <span class="n">If</span> <span class="n">the</span> <span class="n">session</span> <span class="n">has</span> <span class="n">timed</span> <span class="n">out</span><span class="p">,</span>
                    <span class="o">//</span> <span class="n">enter</span> <span class="n">autonomous</span> <span class="n">mode</span>
                    <span class="o">//</span>
                    <span class="n">g_uiApp</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">eUIWakeOnProx</span><span class="p">;</span>
                    <span class="n">bActivity</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>

                    <span class="o">//</span>
                    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">period</span> <span class="k">for</span> <span class="n">wake</span> <span class="n">on</span> <span class="n">touch</span> <span class="n">interval</span>
                    <span class="o">//</span>
                    <span class="n">MAP_CAPT_disableISR</span><span class="p">(</span><span class="n">CAPT_TIMER_INTERRUPT</span><span class="p">);</span>
                    <span class="n">MAP_CAPT_stopTimer</span><span class="p">();</span>
                    <span class="n">MAP_CAPT_clearTimer</span><span class="p">();</span>
                    <span class="n">MAP_CAPT_writeTimerCompRegister</span><span class="p">(</span><span class="n">CAPT_MS_TO_CYCLES</span><span class="p">(</span><span class="n">g_uiApp</span><span class="o">.</span><span class="n">ui16WakeOnProxModeScanPeriod</span><span class="p">));</span>
                    <span class="n">MAP_CAPT_startTimer</span><span class="p">();</span>
                    <span class="n">g_bConvTimerFlag</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
                    <span class="n">CAPT_startWakeOnProxMode</span><span class="p">(</span>
                            <span class="o">&amp;</span><span class="n">CAPT_WAKEONPROX_SENSOR</span><span class="p">,</span>
                            <span class="mi">0</span><span class="p">,</span>
                            <span class="n">g_uiApp</span><span class="o">.</span><span class="n">ui8WakeupInterval</span>
                        <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="n">case</span> <span class="n">eUIWakeOnProx</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">g_bDetectionFlag</span> <span class="o">||</span> <span class="n">g_bConvCounterFlag</span> <span class="o">||</span> <span class="n">g_bMaxCountErrorFlag</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="o">//</span>
                <span class="o">//</span> <span class="n">If</span> <span class="n">a</span> <span class="n">detection</span><span class="p">,</span> <span class="n">conversion</span> <span class="n">counter</span><span class="p">,</span> <span class="ow">or</span> <span class="nb">max</span> <span class="n">count</span> <span class="n">error</span> <span class="n">flag</span> <span class="n">was</span> <span class="nb">set</span><span class="p">,</span>
                <span class="o">//</span> <span class="n">stop</span> <span class="n">autonomous</span> <span class="n">mode</span> <span class="ow">and</span> <span class="n">reload</span> <span class="n">an</span> <span class="n">active</span> <span class="n">session</span>
                <span class="o">//</span>
                <span class="n">CAPT_stopWakeOnProxMode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CAPT_WAKEONPROX_SENSOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">g_bDetectionFlag</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
                <span class="n">g_bConvCounterFlag</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
                <span class="n">g_bMaxCountErrorFlag</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
                <span class="n">g_uiApp</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">eUIActive</span><span class="p">;</span>
                <span class="n">g_ui16UISessionTimeoutCtr</span> <span class="o">=</span> <span class="n">g_uiApp</span><span class="o">.</span><span class="n">ui16InactivityTimeout</span><span class="p">;</span>

                <span class="o">//</span>
                <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">period</span> <span class="k">for</span> <span class="n">normal</span> <span class="n">scan</span> <span class="n">interval</span>
                <span class="o">//</span>
                <span class="n">MAP_CAPT_disableISR</span><span class="p">(</span><span class="n">CAPT_TIMER_INTERRUPT</span><span class="p">);</span>
                <span class="n">MAP_CAPT_stopTimer</span><span class="p">();</span>
                <span class="n">MAP_CAPT_clearTimer</span><span class="p">();</span>
                <span class="n">MAP_CAPT_writeTimerCompRegister</span><span class="p">(</span><span class="n">CAPT_MS_TO_CYCLES</span><span class="p">(</span><span class="n">g_uiApp</span><span class="o">.</span><span class="n">ui16ActiveModeScanPeriod</span><span class="p">));</span>
                <span class="n">MAP_CAPT_startTimer</span><span class="p">();</span>
                <span class="n">CAPT_clearIFG</span><span class="p">(</span><span class="n">CAPT_TIMER_INTERRUPT</span><span class="p">);</span>
                <span class="n">MAP_CAPT_enableISR</span><span class="p">(</span><span class="n">CAPT_TIMER_INTERRUPT</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">bActivity</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that it is possible to set a different scan period for wake-on-proximity mode than the period used in active mode. This allows for slow scanning while waiting for proximity, and faster scanning when a user is detected. Scanning less often reduces the overall power consumption.</p>
<p>In addition, the clock source and low power mode used during wake-on-proximity mode may be set to the VLO and LPM4, respectively, for applications that require low power but cannot use a crystal. To enable this combination, define <strong>CAPT_WOP_VLO_LPM4</strong> at the beginning of CAPT_App.c. When this is defined, the application&#8217;s low power mode will be set to LPM4 (ACLK off), and the VLO will be selected as the input clock source to the CapTIvate timer.</p>
<p>For more details on designing for low power, see the <a class="reference external" href="ch_design_guide.html#ultra-low-power">low power design guide</a>.</p>
</div>
<div class="section" id="capt-appsleep">
<h5>CAPT_appSleep()<a class="headerlink" href="#capt-appsleep" title="Permalink to this headline">¶</a></h5>
<p>The application sleep function is a safety wrapper that ensures no flags are pending when the application transitions into a low power mode. Safety is achieved by disabling interrupts, testing the flags, and then entering a low power mode while simultaneously re-enabling interrupts. This sequence protects the application from any software race conditions that might occur, such as a flag being set after the flag was tested but before the device entered low power mode.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>__bic_SR_register(GIE);
if (!(g_bConvTimerFlag ||g_bDetectionFlag || g_bConvCounterFlag || g_bMaxCountErrorFlag))
{
    __bis_SR_register(g_uiApp.ui8AppLPM | GIE);
}
else
{
    __bis_SR_register(GIE);
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="moving-forward">
<h4>Moving Forward<a class="headerlink" href="#moving-forward" title="Permalink to this headline">¶</a></h4>
<p>That&#8217;s it! The example application in <em>captivate_app</em> is meant to be just that- an example. Feel free to modify it to suit the needs of another application. For details on how to use the CapTIvate™ Software Library top level API, see <a class="reference external" href="ch_library.html#use-th-top-level-api">Using the Top Level API</a>.</p>
</div>
</div>
<div class="section" id="adding-captivate-to-an-existing-project">
<h3>Adding CapTIvate™ to an Existing Project<a class="headerlink" href="#adding-captivate-to-an-existing-project" title="Permalink to this headline">¶</a></h3>
<p>If you have an existing application using an MSP MCU and would like to add CapTIvate™ capacitive touch sensing capability to that project, this guide will discuss the important steps to take to make the integration as seamless as possible.</p>
<p>This guide also provides details about how to set up a new project from scratch, if the CapTIvate™ starter project is not being used.</p>
<div class="section" id="similar-devices">
<h4>Similar Devices<a class="headerlink" href="#similar-devices" title="Permalink to this headline">¶</a></h4>
<p>The CapTIvate™ MSP430FR26xx and MSP430FR25xx MCUs have a similar platform architecture as some other MSP430 FRAM devices. As such, porting an existing application from another FRAM device to an MSP430FR26xx or MSP430FR25xx MCU does not require significant effort. MCUs that are very compatible include the MSP430FR4133, MSP430FR2433, and MSP430FR2033.</p>
</div>
<div class="section" id="porting-approach">
<h4>Porting Approach<a class="headerlink" href="#porting-approach" title="Permalink to this headline">¶</a></h4>
<p>The best way to begin CapTIvate™ software library development, regardless of whether the capacitive sensing functionality will be integrated with another project or not, is to generate a starter project with the CapTIvate™ Design Center. This starter project may then be used by itself to quickly bring up a capacitive sensing application and experiment with tuning. Once that process is complete, all that is needed is to bring over the necessary CapTIvate™ software components from the starter project into the existing software project.</p>
<p>The <a class="reference external" href="ch_library.html#starting-from-scratch-with-th-starter-project">previous section</a> discusses how to generate a starter project. The <a class="reference external" href="ch_workshop.html#creating-a-new-sensor-design-project">new sensor project design workshop</a> also provides a step-by-step overview of the process. Once you have a starter project, you can extract the CapTIvate™ software library components from the starter project and integrate them into the existing project.</p>
</div>
<div class="section" id="bringing-over-captivate-software-components-from-a-starter-project-to-an-existing-project">
<h4>Bringing over CapTIvate™ Software Components from a Starter Project to an Existing Project<a class="headerlink" href="#bringing-over-captivate-software-components-from-a-starter-project-to-an-existing-project" title="Permalink to this headline">¶</a></h4>
<p>As an example, this section will discuss bringing over the CapTIvate™ software components from a starter project to an existing software project. This example will be discussed in the context of TI&#8217;s Code Composer Studio (CCS) IDE. The same principles apply to an IAR Embedded Workbench project. In this example, the existing software project will be an empty CCS project, as shown below:</p>
<div class="figure" id="id23">
<img alt="Empty Application" src="../_images/existing_project_files_PartA.png" />
<p class="caption"><span class="caption-number">Fig. 175 </span><span class="caption-text">Empty Application</span></p>
</div>
<p><strong>main.c</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##include &lt;msp430.h&gt;</span>

<span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">WDTCTL</span> <span class="o">=</span> <span class="n">WDTPW</span> <span class="o">|</span> <span class="n">WDTHOLD</span><span class="p">;</span>
    <span class="n">PM5CTL0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOCKLPM5</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">__no_operation</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To bring over CapTIvate™, the following steps are required:</p>
<ol class="arabic simple">
<li>Copy over the <em>captivate</em>, <em>captivate_config</em>, and <em>driverlib</em> directories and all of their content from the starter project to the existing application</li>
<li>Configure the existing project&#8217;s compiler settings for CapTIvate™</li>
<li>Configure the existing project&#8217;s linker settings for CapTIvate™</li>
<li>Add top level API calls to the main application to initialize, calibrate, and begin updating the newly added capacitive sensing interface</li>
<li>[Optional] Optimize the clock system configuration for CapTIvate™</li>
</ol>
<div class="section" id="step-1-copying-the-needed-captivate-files">
<h5>Step 1: Copying the Needed CapTIvate™ Files<a class="headerlink" href="#step-1-copying-the-needed-captivate-files" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>1a. Copy the <em>captivate</em>, <em>captivate_config</em>, and <em>driverlib</em> directories and all of their content from the starter project to the existing application</li>
<li>1b. Copy the <em>driverlib</em> directory and all of its contents from the starter project to the existing application</li>
</ul>
<p>Below are the directories that need to be copied from the starter project:</p>
<div class="figure" id="id24">
<img alt="Starter Application Files To Copy" src="../_images/starter_project_files_transfer.png" />
<p class="caption"><span class="caption-number">Fig. 176 </span><span class="caption-text">Starter Application Files To Copy</span></p>
</div>
</div>
<div class="section" id="step-2-configuring-the-existing-project-s-compiler-settings-for-captivate">
<h5>Step 2: Configuring the Existing Project&#8217;s Compiler Settings for CapTIvate™<a class="headerlink" href="#step-2-configuring-the-existing-project-s-compiler-settings-for-captivate" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>2a. Add the <em>captivate</em>, <em>captivate/BASE</em>, <em>captivate/ADVANCED</em>, <em>captivate/COMM</em>, and <em>captivate_config</em> project directories to the existing project&#8217;s include search path, as shown below. Also add the DriverLib directory <em>driverlib/MSP430FR2x_4xx</em></li>
</ul>
<div class="figure" id="id25">
<img alt="Compiler Include Settings" src="../_images/lib_existing_project_includes.png" />
<p class="caption"><span class="caption-number">Fig. 177 </span><span class="caption-text">Compiler Include Settings</span></p>
</div>
<ul class="simple">
<li>2b. Select the correct memory models for the device that is being configured by changing the existing project&#8217;s compiler processor options settings. This is required for the project to be compatible with the ROM and object code library. To determine the required memory model for a given device, refer to the <a class="reference external" href="ch_library.html#msp430-cpux-memory-model">memory model</a> section.</li>
</ul>
<div class="figure" id="id26">
<img alt="Compiler Processor Options" src="../_images/lib_existing_project_scsd.png" />
<p class="caption"><span class="caption-number">Fig. 178 </span><span class="caption-text">Compiler Processor Options</span></p>
</div>
<ul class="simple">
<li>2c. Add the following definitions to the project&#8217;s compiler predefined symbol list:<ul>
<li>TARGET_IS_MSP430FR2633 (To include the CapTIvate™ ROM functions). This definition is not needed for software library versions 1.10.xx.xx and greater, as ROM header file selection is determined at compile time based on the device definition (such as <strong>MSP430FR2633</strong>) which is set by the IDE.</li>
<li>TARGET_IS_MSP430FR2XX_4XX (To include the DriverLib ROM functions)</li>
</ul>
</li>
</ul>
<div class="figure" id="id27">
<img alt="Compiler Pre-Defined Symbols" src="../_images/lib_existing_project_defines.png" />
<p class="caption"><span class="caption-number">Fig. 179 </span><span class="caption-text">Compiler Pre-Defined Symbols</span></p>
</div>
</div>
<div class="section" id="step-3-configuring-the-existing-project-s-linker-settings-for-captivate">
<h5>Step 3: Configuring the Existing Project&#8217;s Linker Settings for CapTIvate™<a class="headerlink" href="#step-3-configuring-the-existing-project-s-linker-settings-for-captivate" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>3a. Add the CapTIvate™ library archive to the linker&#8217;s input. Be sure to include the correct pre-built CapTIvate library that corresponds to the device that is being developed with. The library correspondence is described <a class="reference external" href="ch_library.html#pre-compiled-libraries">here</a>. Once the correct library is selected, it is necessary to exclude the unused libraries from the CCS build, as shown in the example below. In the example, the project is being built for an MSP430FR2633 family device, so the MSP430FR2522 library is excluded from the build.</li>
</ul>
<div class="figure" id="id28">
<img alt="Linker Inputs" src="../_images/lib_precompiled_obj_lib_exclusion.png" />
<p class="caption"><span class="caption-number">Fig. 180 </span><span class="caption-text">Linker Inputs</span></p>
</div>
<p>If you are using the pre-compiled DriverLib directory from the starter project, add the DriverLib library archive as well, as shown below.</p>
<div class="figure" id="id29">
<img alt="Linker Inputs" src="../_images/lib_existing_project_linker.png" />
<p class="caption"><span class="caption-number">Fig. 181 </span><span class="caption-text">Linker Inputs</span></p>
</div>
</div>
<div class="section" id="step-4-add-top-level-api-calls-to-begin-using-captivate">
<h5>Step 4: Add Top Level API Calls to Begin Using CapTIvate™<a class="headerlink" href="#step-4-add-top-level-api-calls-to-begin-using-captivate" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>4a. Insert calls to initialize and calibrate the user interface once at the beginning of the application. Be sure to also add the include statement for the CapTIvate library.</li>
</ul>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">a</span><span class="p">:</span>
<span class="n">CAPT_initUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
<span class="n">CAPT_calibrateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
</pre></div>
</div>
<p>If noise immunity (EMC) features are going to be enabled for this design, it is also necessary to link the EMC configuration structure to the EMC module via a call to <strong>CAPT_loadEMCConfig()</strong>. This must be done before calling <strong>CAPT_calibrateUI()</strong>, so that the EMC configuration parameters are available during the calibration process.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">a</span> <span class="k">with</span> <span class="n">EMC</span><span class="p">:</span>
<span class="n">CAPT_initUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
<span class="n">CAPT_loadEMCConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_EMCConfig</span><span class="p">);</span>
<span class="n">CAPT_calibrateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li>4b. Configure the CapTIvate™ interval timer to periodically set the <strong>g_bConvTimerFlag</strong> status flag.</li>
</ul>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">b</span><span class="p">:</span>
<span class="n">MAP_CAPT_selectTimerSource</span><span class="p">(</span><span class="n">CAPT_TIMER_SRC_ACLK</span><span class="p">);</span>
<span class="n">MAP_CAPT_writeTimerCompRegister</span><span class="p">(</span><span class="n">CAPT_MS_TO_CYCLES</span><span class="p">(</span><span class="n">g_uiApp</span><span class="o">.</span><span class="n">ui16ActiveModeScanPeriod</span><span class="p">));</span>
<span class="n">MAP_CAPT_startTimer</span><span class="p">();</span>
<span class="n">MAP_CAPT_enableISR</span><span class="p">(</span><span class="n">CAPT_TIMER_INTERRUPT</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li>4c. Begin updating the UI! Add a test in the background loop to see if the conversion timer flag has been set. If it has, clear it and update the user interface via <strong>CAPT_updateUI()</strong>.</li>
</ul>
<p><strong>main.c</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##include &lt;msp430.h&gt;</span>
<span class="c1">##include &quot;captivate.h&quot;</span>

<span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">WDTCTL</span> <span class="o">=</span> <span class="n">WDTPW</span> <span class="o">|</span> <span class="n">WDTHOLD</span><span class="p">;</span>
    <span class="n">PM5CTL0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOCKLPM5</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">a</span><span class="p">:</span>
    <span class="n">CAPT_initUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
    <span class="n">CAPT_calibrateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">b</span><span class="p">:</span>
    <span class="n">MAP_CAPT_selectTimerSource</span><span class="p">(</span><span class="n">CAPT_TIMER_SRC_ACLK</span><span class="p">);</span>
    <span class="n">MAP_CAPT_writeTimerCompRegister</span><span class="p">(</span><span class="n">CAPT_MS_TO_CYCLES</span><span class="p">(</span><span class="n">g_uiApp</span><span class="o">.</span><span class="n">ui16ActiveModeScanPeriod</span><span class="p">));</span>
    <span class="n">MAP_CAPT_startTimer</span><span class="p">();</span>
    <span class="n">MAP_CAPT_enableISR</span><span class="p">(</span><span class="n">CAPT_TIMER_INTERRUPT</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">c</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">g_bConvTimerFlag</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">g_bConvTimerFlag</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
            <span class="n">CAPT_updateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>4d. Check the touch status of the sensor by testing its <strong>bSensorTouch</strong> flag. This flag will indicate if any element in the sensor has a touch detection. After <strong>CAPT_updateUI()</strong> is called, all of the sensor and element objects in the UI will have updated status variables.</li>
</ul>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">c</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">g_bConvTimerFlag</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">g_bConvTimerFlag</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
        <span class="n">CAPT_updateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>

        <span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">d</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keypad</span><span class="o">.</span><span class="n">bSensorTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">__no_operation</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="step-5-optional-optimizing-the-clock-system-for-captivate">
<h5>Step 5: [Optional] Optimizing the Clock System for CapTIvate™<a class="headerlink" href="#step-5-optional-optimizing-the-clock-system-for-captivate" title="Permalink to this headline">¶</a></h5>
<p>The default clock frequency for the DCO is approximately 1 MHz. The CapTIvate™ Software Library runs most efficiently at 8 MHz. At 8 MHz, no memory access wait states are required, providing an efficient uA/MHz ratio. To increase the DCO clock frequency to 8 MHz, insert calls to DriverLib to configure the clock system as shown below. It is best to configure the clock system before any calls to the CapTIvate™ Software Library.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##define MCLK_FREQ 8000000</span>
<span class="c1">##define FLLREF_FREQ 32768</span>
<span class="c1">##define FLL_RATIO (MCLK_FREQ / FLLREF_FREQ)</span>

<span class="o">//</span> <span class="n">Step</span> <span class="mi">5</span><span class="p">:</span>
<span class="n">CS_initClockSignal</span><span class="p">(</span><span class="n">CS_FLLREF</span><span class="p">,</span> <span class="n">CS_REFOCLK_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_1</span><span class="p">);</span>
<span class="n">CS_initClockSignal</span><span class="p">(</span><span class="n">CS_ACLK</span><span class="p">,</span> <span class="n">CS_REFOCLK_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_1</span><span class="p">);</span>
<span class="n">CS_initClockSignal</span><span class="p">(</span><span class="n">CS_MCLK</span><span class="p">,</span> <span class="n">CS_DCOCLKDIV_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_1</span><span class="p">);</span>
<span class="n">CS_initClockSignal</span><span class="p">(</span><span class="n">CS_SMCLK</span><span class="p">,</span> <span class="n">CS_DCOCLKDIV_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_4</span><span class="p">);</span>
<span class="n">CS_initFLLSettle</span><span class="p">((</span><span class="n">MCLK_FREQ</span><span class="o">/</span><span class="mi">1000</span><span class="p">),</span> <span class="n">FLL_RATIO</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">CS_getFaultFlagStatus</span><span class="p">(</span><span class="n">CS_DCOFFG</span> <span class="o">|</span> <span class="n">CS_FLLULIFG</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">CS_clearFaultFlag</span><span class="p">(</span><span class="n">CS_DCOFFG</span> <span class="o">|</span> <span class="n">CS_FLLULIFG</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that SMCLK is configured to run at DCO/4, or 2 MHz. This is the frequency that the CapTIvate™ Software Library COMM module expects in order to generate UART baud rates correctly.</p>
</div>
<div class="section" id="step-6-optional-muxing-io-for-communications">
<h5>Step 6: [Optional] Muxing IO for Communications<a class="headerlink" href="#step-6-optional-muxing-io-for-communications" title="Permalink to this headline">¶</a></h5>
<p>To add the ability to communicate with the CapTIvate™ Design Center, it is necessary to configure the CapTIvate™ user configuration for a communication interface (UART or I2C) and mux the appropriate peripheral to device pins. See the appropriate device datasheet and device family user&#8217;s guide for information on how to mux digital functions to device pins. The starter project also provides an example of how to mux the eUSCI_A0 and eUSCI_B0 peripherals on the MSP430FR2633.</p>
</div>
<div class="section" id="completed-example-application">
<h5>Completed Example Application<a class="headerlink" href="#completed-example-application" title="Permalink to this headline">¶</a></h5>
<p>Below is the completed example:</p>
<p><strong>main.c</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##include &lt;msp430.h&gt;</span>
<span class="c1">##include &quot;captivate.h&quot;</span>
<span class="c1">##include &quot;driverlib.h&quot;</span>

<span class="c1">##define MCLK_FREQ 8000000</span>
<span class="c1">##define FLLREF_FREQ 32768</span>
<span class="c1">##define FLL_RATIO (MCLK_FREQ / FLLREF_FREQ)</span>

<span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">WDTCTL</span> <span class="o">=</span> <span class="n">WDTPW</span> <span class="o">|</span> <span class="n">WDTHOLD</span><span class="p">;</span>
    <span class="n">PM5CTL0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOCKLPM5</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Step</span> <span class="mi">5</span><span class="p">:</span>
    <span class="n">CS_initClockSignal</span><span class="p">(</span><span class="n">CS_FLLREF</span><span class="p">,</span> <span class="n">CS_REFOCLK_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_1</span><span class="p">);</span>
    <span class="n">CS_initClockSignal</span><span class="p">(</span><span class="n">CS_ACLK</span><span class="p">,</span> <span class="n">CS_REFOCLK_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_1</span><span class="p">);</span>
    <span class="n">CS_initClockSignal</span><span class="p">(</span><span class="n">CS_MCLK</span><span class="p">,</span> <span class="n">CS_DCOCLKDIV_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_1</span><span class="p">);</span>
    <span class="n">CS_initClockSignal</span><span class="p">(</span><span class="n">CS_SMCLK</span><span class="p">,</span> <span class="n">CS_DCOCLKDIV_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_4</span><span class="p">);</span>
    <span class="n">CS_initFLLSettle</span><span class="p">((</span><span class="n">MCLK_FREQ</span><span class="o">/</span><span class="mi">1000</span><span class="p">),</span> <span class="n">FLL_RATIO</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">CS_getFaultFlagStatus</span><span class="p">(</span><span class="n">CS_DCOFFG</span> <span class="o">|</span> <span class="n">CS_FLLULIFG</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">CS_clearFaultFlag</span><span class="p">(</span><span class="n">CS_DCOFFG</span> <span class="o">|</span> <span class="n">CS_FLLULIFG</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">a</span><span class="p">:</span>
    <span class="n">CAPT_initUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
    <span class="n">CAPT_calibrateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">b</span><span class="p">:</span>
    <span class="n">MAP_CAPT_selectTimerSource</span><span class="p">(</span><span class="n">CAPT_TIMER_SRC_ACLK</span><span class="p">);</span>
    <span class="n">MAP_CAPT_writeTimerCompRegister</span><span class="p">(</span><span class="n">CAPT_MS_TO_CYCLES</span><span class="p">(</span><span class="n">g_uiApp</span><span class="o">.</span><span class="n">ui16ActiveModeScanPeriod</span><span class="p">));</span>
    <span class="n">MAP_CAPT_startTimer</span><span class="p">();</span>
    <span class="n">MAP_CAPT_enableISR</span><span class="p">(</span><span class="n">CAPT_TIMER_INTERRUPT</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">c</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">g_bConvTimerFlag</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">g_bConvTimerFlag</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
            <span class="n">CAPT_updateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Step</span> <span class="mi">4</span><span class="n">d</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">keypad</span><span class="o">.</span><span class="n">bSensorTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">__no_operation</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="porting-an-existing-captivate-project-to-a-new-device">
<h3>Porting an Existing CapTIvate Project to a New Device<a class="headerlink" href="#porting-an-existing-captivate-project-to-a-new-device" title="Permalink to this headline">¶</a></h3>
<p>If you have an existing application using a CapTIvate MCU and would like to change the CapTIvate device, this guide will discuss the important steps to take to make the integration as seamless as possible.</p>
<div class="section" id="id1">
<h4>Porting Approach<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>The best method to seamlessly port a CapTIvate application from one device to another is to start with the CapTIvate Design Center and use it to generate a starter project for the new device. This will generate all of the needed files. Once the new project is available in CapTIvate Design Center, it is possible to generate a new starter project to import into Code Composer Studio (CCS). In this example, we will look at how to update an MSP430FR2532 4-button project to run on an MSP430FR2522 device.</p>
<div class="section" id="step-1-create-starter-project-for-new-device">
<h5>Step 1: Create Starter Project for New Device<a class="headerlink" href="#step-1-create-starter-project-for-new-device" title="Permalink to this headline">¶</a></h5>
<p>Step 1 in porting a development project from one CapTIvate device to another is creating a CapTIvate Design Center project based on the original design, and updating the controller to the new device.</p>
<p>1a. Open the CapTIvate Design Center project for the original design. Let us use a 4-button application on an MSP430FR2532 as a starting point, as shown below.</p>
<div class="figure" id="id30">
<img alt="MSP430FR2532 Starting Project Canvas" src="../_images/porting_fr2532_canvas.png" />
<p class="caption"><span class="caption-number">Fig. 182 </span><span class="caption-text">MSP430FR2532 Starting Project Canvas</span></p>
</div>
<p>1b. Select File-&gt;Save As, and create a new project folder with a new name. In this example, we will be porting to the MSP430FR2522, so we will name the new project folder &#8216;MigrationExample_MSP430FR2522_New.&#8217;</p>
<div class="figure" id="id31">
<img alt="Save As" src="../_images/porting_fr2532_saveas.png" />
<p class="caption"><span class="caption-number">Fig. 183 </span><span class="caption-text">Save As</span></p>
</div>
<p>1c. Now that we have a new project for the new device (MSP430FR2522), we need to change the controller. We can keep all of the existing sensor widgets and tunings; we just need to change the controller type and re-assign sensors to IO pins on the new device.</p>
<div class="figure" id="id32">
<img alt="Save As" src="../_images/porting_device_select.png" />
<p class="caption"><span class="caption-number">Fig. 184 </span><span class="caption-text">Save As</span></p>
</div>
<p>1d. Now that the new device is selected, the pin routing must be completed again. To achieve this, the CapTIvate Design Center auto-route feature can be used, or the pins may be assigned manually.</p>
</div>
<div class="section" id="step-2-prepare-a-ccs-workspace">
<h5>Step 2: Prepare a CCS Workspace<a class="headerlink" href="#step-2-prepare-a-ccs-workspace" title="Permalink to this headline">¶</a></h5>
<p>Set up a Code Composer Studio workspace with the original project. Then, import the starter project for the new device based on the CapTIvate Design Center project (the one that was created in Step 1 above).</p>
<div class="figure" id="id33">
<img alt="CCS Workspace with Original Project and New Starter Project" src="../_images/porting_ccs_wksp_start.png" />
<p class="caption"><span class="caption-number">Fig. 185 </span><span class="caption-text">CCS Workspace with Original Project and New Starter Project</span></p>
</div>
<p>Once the starter project is imported, we can start copying the required files to the original project.</p>
</div>
<div class="section" id="step-3-copying-the-new-files">
<h5>Step 3: Copying the New Files<a class="headerlink" href="#step-3-copying-the-new-files" title="Permalink to this headline">¶</a></h5>
<p>To support the new device in the original project, we need the following directories from the new starter project:</p>
<ol class="arabic simple">
<li>/captivate (The latest CapTIvate Software Library)</li>
<li>/captivate_config (The new configuration files with the sensor-to-pin mapping of the new device)</li>
<li>/driverlib (The up-to-date driver library to support the new devices)</li>
</ol>
<div class="figure" id="id34">
<img alt="Directories to Copy" src="../_images/porting_ccs_wksp_dirs_to_cpy.png" />
<p class="caption"><span class="caption-number">Fig. 186 </span><span class="caption-text">Directories to Copy</span></p>
</div>
<p>Copy these directories from the new starter project, and replace all the directories in the original project with the copied directories. At this point, it is not yet possible to build the project, because the project compiler and linker settings need to be updated for the new device.</p>
</div>
<div class="section" id="step-4-updating-ccs-project-settings">
<h5>Step 4: Updating CCS Project Settings<a class="headerlink" href="#step-4-updating-ccs-project-settings" title="Permalink to this headline">¶</a></h5>
<p>In this step, the original MSP430FR2532 CCS project settings will be updated to support the new MSP430FR2522 device.</p>
<p>1a. Open the CSS project properties. Change the device from MSP430FR2532 to MSP430FR2522.</p>
<div class="figure" id="id35">
<img alt="Project Properties" src="../_images/port_prjprop_device.png" />
<p class="caption"><span class="caption-number">Fig. 187 </span><span class="caption-text">Project Properties</span></p>
</div>
<p>1b. In the project properties, select MSP430 Linker -&gt; File Search Path. Change the include library file for the CapTIvate library from captivate_fr2633_family.lib to captivate_fr2522_family.lib. The library to device mapping for a given project is listed in the <a class="reference external" href="ch_device.html#devices">device family</a> chapter. This step may not be necessary for all ports if the device that is being ported to utilizes the same library.</p>
<div class="figure" id="id36">
<img alt="Project Properties" src="../_images/port_prjprop_lib.png" />
<p class="caption"><span class="caption-number">Fig. 188 </span><span class="caption-text">Project Properties</span></p>
</div>
</div>
<div class="section" id="step-5-update-relevant-port-muxing-settings">
<h5>Step 5: Update Relevant Port Muxing Settings<a class="headerlink" href="#step-5-update-relevant-port-muxing-settings" title="Permalink to this headline">¶</a></h5>
<p>Note that this procedure did not modify the /captivate_app directory or main.c. This was intentional, to leave as much of the original project intact as possible. Be sure to adjust port muxing settings as needed to support the new device.</p>
</div>
</div>
</div>
</div>
<div class="section" id="how-to">
<h2>How-To<a class="headerlink" href="#how-to" title="Permalink to this headline">¶</a></h2>
<p>The how-to section of the CapTIvate™ Software Library chapter contains basic code snippets that demonstrate how to perform a simple task, such as measuring a sensor, checking the status of a sensor, or accessing raw data.</p>
<div class="section" id="use-the-top-level-api">
<h3>Use the Top Level API<a class="headerlink" href="#use-the-top-level-api" title="Permalink to this headline">¶</a></h3>
<p>The top level API of the CapTIvate™ Software Library provides a very simple, highly abstracted programming interface to the library. To get an application up and running, it is only necessary to have knowledge of three basic functions: <strong>CAPT_initUI()</strong>, <strong>CAPT_calibrateUI()</strong>, and <strong>CAPT_updateUI()</strong>.</p>
<div class="section" id="scope">
<h4>Scope<a class="headerlink" href="#scope" title="Permalink to this headline">¶</a></h4>
<p>As introduced in the <a class="reference external" href="ch_library.html#programming-model">programming model</a> section, the top level API functions operate solely on the top level application object, or <em>tCaptivateApplication</em>. This object contains all of the information that is needed to run the user interface. It contains the links to all of the sensors that are in the UI. It is important to understand that when a top level API function is used, all of the sensors that are associated with the application are affected. For example, calling <strong>CAPT_calibrateUI()</strong> causes each sensor in the UI to be calibrated.</p>
</div>
<div class="section" id="open-source">
<h4>Open Source<a class="headerlink" href="#open-source" title="Permalink to this headline">¶</a></h4>
<p>The top level API functions are delivered as open source functions in the library, so that the software designer can understand how the functions work. The functions exist in the <em>CAPT_Manager.c</em> and <em>CAPT_Manager.h</em> files, which are a part of the <strong>ADVANCED</strong> module of the library.</p>
</div>
<div class="section" id="setting-up-an-application">
<h4>Setting up an Application<a class="headerlink" href="#setting-up-an-application" title="Permalink to this headline">¶</a></h4>
<p>When setting up an application, it is important to note that there are two types of functions in the top level API:</p>
<ul class="simple">
<li>Initialization functions (Run one time at start-up)</li>
<li>Periodic functions (called periodically while the application is running to do something)</li>
</ul>
<p>The initialization functions are <strong>CAPT_initUI()</strong> and <strong>CAPT_calibrateUI()</strong>. <strong>CAPT_updateUI()</strong> is a periodic function. The initialization functions must be called at the beginning of the application. The behavior of each function is described below.</p>
<div class="section" id="capt-initui">
<h5>CAPT_initUI()<a class="headerlink" href="#capt-initui" title="Permalink to this headline">¶</a></h5>
<p>The CAPT_initUI() function is responsible for the following actions at start-up:</p>
<ol class="arabic simple">
<li>Power on the CapTIvate™ peripheral</li>
<li>Initialize the CapTIvate™ peripheral global settings</li>
<li>Configure each sensor&#8217;s IO</li>
<li>Initialize each sensor</li>
<li>If communications are enabled, initialize the library&#8217;s communication (COMM) module</li>
</ol>
<p>Essentially, this function takes care of the one-time settings that do not change once the application is up and running. It should be called one time before any other CapTIvate™ library function is called.</p>
</div>
<div class="section" id="capt-calibrateui">
<h5>CAPT_calibrateUI()<a class="headerlink" href="#capt-calibrateui" title="Permalink to this headline">¶</a></h5>
<p>The CAPT_calibrateUI() function is responsible for obtaining coarse gain, fine gain, and offset subtraction calibration values for every element in every sensor in the application. Once these calibration values are obtained via this function call, they will be applied every time an element is measured to provide the correct amount of gain and offset. For details on how gain and offset parameters work, see the <a class="reference external" href="ch_technology.html#the-captivate-peripheral">peripheral section</a> of the technology guide.</p>
<p>This top-level calibration function is also responsible for determining whether to use the standard calibration routine (<strong>CAPT_calibrateSensor()</strong>) or the EMC calibration routine (<strong>CAPT_calibrateSensorWithEMC()</strong>), depending on whether or not noise immunity is enabled. If noise immunity is enabled, the EMC calibration routine provides calibration values at multiple conversion frequencies and performs additional self-test functions.</p>
<p>This function must be called before any UI or sensor update functions are called- otherwise, no calibration values will be present!</p>
<p>In addition to the first call, in certain applications it may be desirable to force a re-calibration at run-time. One example of this scenario is a mobile device that experiences a &#8220;negative&#8221; or &#8220;reverse&#8221; touch. If a user is touching a sensor during power-up or reset, the sensor will be calibrated to the touched state rather than the un-touched state. When the user lets go of the sensor, the measurement will change rapidly <em>against</em> the expected direction of change. This can be interpreted as a reverse touch scenario, after which it may be desirable to re-calibrate the entire user interface to ensure a good starting point.</p>
</div>
<div class="section" id="capt-updateui">
<h5>CAPT_updateUI()<a class="headerlink" href="#capt-updateui" title="Permalink to this headline">¶</a></h5>
<p>The CAPT_updateUI() function is responsible for the following actions:</p>
<ol class="arabic simple">
<li>Updating each sensor</li>
<li>Testing each sensor for a re-calibration condition</li>
<li>If communications are enabled, attempting transmission of element and/or sensor data via the COMM module</li>
</ol>
<p>This top-level update function is also responsible for determining whether to use the standard update routine (<strong>CAPT_updateSensor()</strong>)or the EMC update routine (<strong>CAPT_updateSensorWithEMC()</strong>), depending on whether or not noise immunity is enabled.</p>
<p>This function should be called periodically to update all of the sensors in the system. After this function is called, the following values are updated:</p>
<ul class="simple">
<li>Raw count</li>
<li>Filtered count</li>
<li>Long term average (LTA)</li>
<li>Detect and negative touch flags</li>
<li>Touch and proximity flags</li>
<li>Previous touch flags</li>
<li>Dominant element ID (for a button group)</li>
<li>Position (for a slider or wheel)</li>
<li>Max count error flags and noise state flags</li>
<li>De-bounce counters</li>
</ul>
<p>After the values are updated via a call to <strong>CAPT_updateUI()</strong>, any value can be checked by referencing it in the appropriate data structure.</p>
</div>
</div>
<div class="section" id="simple-code-example">
<h4>Simple Code Example<a class="headerlink" href="#simple-code-example" title="Permalink to this headline">¶</a></h4>
<p>The example below demonstrates the structure of a typical application. For simplicity, this example application continuously measures the UI and does not go to sleep in between scans. To enable scheduled scanning, it is necessary to use a timer to trigger the update, such as the CapTIvate™ interval timer.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Execute</span> <span class="n">one</span><span class="o">-</span><span class="n">time</span> <span class="n">setup</span> <span class="n">functions</span>
<span class="n">CAPT_initUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
<span class="n">CAPT_calibrateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>

<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Continuously</span> <span class="n">update</span> <span class="n">the</span> <span class="n">UI</span>
    <span class="n">CAPT_updateUI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_uiApp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="register-a-callback-function">
<h3>Register a Callback Function<a class="headerlink" href="#register-a-callback-function" title="Permalink to this headline">¶</a></h3>
<p>Callbacks provide a mechanism for the application to be notified when a sensor has been updated. The application must first register its &#8220;callback&#8221; function for each sensor before it can receive updates. When the callback is executed, the application can query the sensor&#8217;s data structure to determine the status of the sensor.</p>
<p>The library function <strong>CAPT_registerCallback()</strong> provides the registration.</p>
<p><strong>Format</strong></p>
<p>Sensor callback functions are passed a pointer to the calling sensor, and they must return void. An example skeleton callback function is shown below:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">my_button_callback</span><span class="p">(</span><span class="n">tSensor</span><span class="o">*</span> <span class="n">pSensor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">DO</span> <span class="n">SOMETHING</span> <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Example</strong></p>
<p>This is what it would look like to register the callback function named &#8220;my_button_callback&#8221; to the sensor BTN0000.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">MAP_CAPT_registerCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTN0000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_button_callback</span><span class="p">);</span>
</pre></div>
</div>
<p>Once an application&#8217;s callback function is registered, the callback is executed each time the corresponding sensor is scanned and processed, regardless if a proximity or touch detection has occurred. Inside the user callback, the application can perform any required sensor data and status post-processing. In a typical button application, this is where the application will check for a proximity, touch detection or slider/wheel position.</p>
<p><strong>Example</strong></p>
<p>Here is a typical callback example for a button that checks both when a touch is detected and a release.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">my_button_callback</span><span class="p">(</span><span class="n">tSensor</span><span class="o">*</span> <span class="n">pSensor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">((</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">bSensorTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">bSensorPrevTouch</span> <span class="o">==</span> <span class="n">false</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">BUTTON</span> <span class="n">PRESSED</span>

        <span class="o">//</span> <span class="n">DO</span> <span class="n">SOMETHING</span> <span class="o">...</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">bSensorTouch</span> <span class="o">==</span> <span class="n">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">bSensorPrevTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">BUTTON</span> <span class="n">RELEASED</span>

        <span class="o">//</span> <span class="n">DO</span> <span class="n">SOMETHING</span> <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here is a callback example for a proximity sensor.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">my_proximity_callback</span><span class="p">(</span><span class="n">tSensor</span><span class="o">*</span> <span class="n">pSensor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">bSensorProx</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">PROXIMITY</span> <span class="n">DETECTED</span>

        <span class="o">//</span> <span class="n">DO</span> <span class="n">SOMETHING</span> <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In addition to proximity and touch status, sliders and wheels also provide position status. Here is a typical callback example for a slider or wheel that checks a sensor&#8217;s position.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">my_slider_callback</span><span class="p">(</span><span class="n">tSensor</span><span class="o">*</span> <span class="n">pSensor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uint16_t</span> <span class="n">ui16Position</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">FIRST</span> <span class="n">CHECK</span> <span class="n">IF</span> <span class="n">THERE</span> <span class="n">IS</span> <span class="n">VALID</span> <span class="n">TOUCH</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">bSensorTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">THEN</span> <span class="n">GET</span> <span class="n">THE</span> <span class="n">CURRENT</span> <span class="n">TOUCH</span> <span class="n">POSITION</span> <span class="n">ON</span> <span class="n">THE</span> <span class="n">SLIDER</span><span class="o">/</span><span class="n">WHEEL</span>
        <span class="n">ui16Position</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint16_t</span><span class="p">)((</span><span class="n">tSliderSensorParams</span><span class="o">*</span><span class="p">)</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">pSensorParams</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SliderPosition</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">DO</span> <span class="n">SOMETHING</span> <span class="n">WITH</span> <span class="n">POSITION</span> <span class="o">...</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="access-element-state-data">
<h3>Access Element State Data<a class="headerlink" href="#access-element-state-data" title="Permalink to this headline">¶</a></h3>
<p>Each element in a sensor has a set of boolean state flags that indicate its status. The following flags are provided:</p>
<ul class="simple">
<li>Detection</li>
<li>Negative touch detection</li>
<li>Proximity</li>
<li>Touch</li>
<li>Built-in-self-test (BIST) status</li>
<li>Noise status</li>
</ul>
<p>When a sensor is updated (via <strong>CAPT_updateUI()</strong>, <strong>CAPT_updateSensor()</strong>, or <strong>CAPT_updateSensorWithEMC()</strong>), these status flags are updated for every element within the sensor. There are multiple ways to retrieve the data for processing.</p>
<div class="section" id="accessing-element-state-data-directly">
<h4>Accessing Element State Data Directly<a class="headerlink" href="#accessing-element-state-data-directly" title="Permalink to this headline">¶</a></h4>
<p>It is possible to access element state data directly in an element&#8217;s data structure. To do this, it is necessary to know the name of the variable in the element. An example is shown below that uses element 0 of a sensor named <em>keypad</em> to control some other function, such as illuminating an LED.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">tElement</span> <span class="n">keypad_E00</span><span class="p">;</span>

<span class="n">void</span> <span class="n">updateLED</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">keypad_E00</span><span class="o">.</span><span class="n">bTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">ILLUMINATE</span> <span class="n">LED</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">TURN</span> <span class="n">LED</span> <span class="n">OFF</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-element-state-data-indirectly">
<h4>Accessing Element State Data Indirectly<a class="headerlink" href="#accessing-element-state-data-indirectly" title="Permalink to this headline">¶</a></h4>
<p>Note that in the example above, it was necessary to forward declare keypad_E00. It is also possible to &#8220;look up&#8221; E00 of the keypad sensor though the parent sensor structure, as shown below. All sensor structures are forward declared in the user configuration header file (<em>CAPT_UserConfig.h</em>), and do not need to be re-declared. The element of interest is accessed via the cycle pointer array and the element pointer array of that cycle.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">updateLED</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">keypad</span><span class="o">.</span><span class="n">pCycle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pElements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">ILLUMINATE</span> <span class="n">LED</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">TURN</span> <span class="n">LED</span> <span class="n">OFF</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="generating-a-status-bit-field-for-all-elements-in-a-sensor">
<h4>Generating a Status Bit Field for all Elements in a Sensor<a class="headerlink" href="#generating-a-status-bit-field-for-all-elements-in-a-sensor" title="Permalink to this headline">¶</a></h4>
<p>The above access methods shown are simple and do not require very much memory. However, they only provide data for one element. The library function <strong>CAPT_getElementStateBitField()</strong> returns a bit field in which each element is represented with a bit position. The bit field supports up to 64 elements. The return type is a 64-bit unsigned integer, which may be casted down to the size that is needed for the application.</p>
<p>Elements are mapped to bit positions starting with the first element of the first cycle to the last element of the last cycle. For example, a sensor with two cycles and two elements in each cycle would have the following mapping:</p>
<ul class="simple">
<li>Return value bit 0 (0x01): Cycle 0 Element 0</li>
<li>Return value bit 1 (0x02): Cycle 0 Element 1</li>
<li>Return value bit 2 (0x04): Cycle 1 Element 0</li>
<li>Return value bit 3 (0x08): Cycle 1 Element 1</li>
</ul>
<p>This function may be used to query any of the element status flags. The example below tests the touch status flag. If element 0 and element 1 (BIT0 and BIT1), or 0x03, are touched, the LED would be illuminated.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">updateLED</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">multiTouchState</span><span class="p">;</span>
    <span class="n">multiTouchState</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint8_t</span><span class="p">)</span><span class="n">CAPT_getElementStateBitField</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypad</span><span class="p">,</span> <span class="n">eTouchStatus</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">If</span> <span class="s1">&#39;0x03&#39;</span><span class="p">,</span> <span class="ow">or</span> <span class="n">element</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">element</span> <span class="mi">1</span><span class="p">,</span> <span class="n">are</span> <span class="n">both</span> <span class="ow">in</span> <span class="n">detect</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">multiTouchState</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">ILLUMINATE</span> <span class="n">LED</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">LED</span> <span class="n">OFF</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-a-sensor-s-global-flags">
<h4>Accessing a Sensor&#8217;s Global Flags<a class="headerlink" href="#accessing-a-sensor-s-global-flags" title="Permalink to this headline">¶</a></h4>
<p>Many of the flags that are available at the element level are also available as global flags at the sensor level. The global, sensor-level flags operate as a logical OR of all elements in the sensor. In other words, if any element&#8217;s flag is set, the sensor&#8217;s global flag is also set. It this way, it is possible to quickly test one flag to see if anything is happening with a sensor. Then, if something is, the element flags can be used to identify which element(s) threw the flag. In the example below, the LED would be illuminated if any element in the sensor was touched.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">sensorHandler</span><span class="p">(</span><span class="n">tSensor</span><span class="o">*</span> <span class="n">pSensor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">bSensorTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">ILLUMINATE</span> <span class="n">LED</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">TURN</span> <span class="n">LED</span> <span class="n">OFF</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In addition to the global sensor touch flag (<em>bSensorTouch</em>), there is also a global sensor previously touched flag (<em>bSensorPrevTouch</em>). This flag is set if <em>bSensorTouch</em> was set on the previous sample. This can be used as a mechanism to determine if a touch is new (meaning someone just touched the button) versus stale (meaning the touch on this sample is a continuation of a previously started touch). This allows for toggling between states, as shown below:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">sensorHandler</span><span class="p">(</span><span class="n">tSensor</span><span class="o">*</span> <span class="n">pSensor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">((</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">bSensorTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">bSensorPrevTouch</span> <span class="o">==</span> <span class="n">false</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">TOGGLE</span> <span class="n">A</span> <span class="n">FUNCTION</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="element-status-flag-reference-table">
<h4>Element Status Flag Reference Table<a class="headerlink" href="#element-status-flag-reference-table" title="Permalink to this headline">¶</a></h4>
<p>The table below lists the available status flags that all elements have, and the name of the parameter to use when accessing it.</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="30%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Element Structure Parameter</th>
<th class="head">CAPT_getElementStateBitField() Parameter</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Touch Detection</td>
<td>.bTouch</td>
<td>eTouchStatus</td>
</tr>
<tr class="row-odd"><td>Proximity Detection</td>
<td>.bProx</td>
<td>eProxStatus</td>
</tr>
<tr class="row-even"><td>Negative Touch Detect</td>
<td>.bNegativeTouch</td>
<td>eNegativeTouchStatus</td>
</tr>
<tr class="row-odd"><td>Detect</td>
<td>.bDetect</td>
<td>eDetectStatus</td>
</tr>
<tr class="row-even"><td>Built-in-self-test Fail</td>
<td>.bBISTFail</td>
<td>eBISTStatus</td>
</tr>
<tr class="row-odd"><td>Noise Detected</td>
<td>.bNoiseDetected</td>
<td>eNoiseStatus</td>
</tr>
</tbody>
</table>
<p>The <em>detect</em> status is the un-debounced state of the <em>prox</em> status. When an element is in <em>detect</em> but not in <em>prox</em>, this means that the long term average tracking filter is disabled, but the state change into proximity detection is not yet complete because it is currently being de-bounced.</p>
</div>
</div>
<div class="section" id="access-the-dominant-button">
<h3>Access the Dominant Button<a class="headerlink" href="#access-the-dominant-button" title="Permalink to this headline">¶</a></h3>
<p>Button group sensors output a dominant button ID that corresponds to the element with the highest delta response. This is useful for keypads which do not require multi-touch but would like to have some level of nearby key rejection. For example, if a user is touching in between to keys, the dominant key with the highest delta response will be reported.</p>
<p>When a button group sensor is updated (via <strong>CAPT_updateUI()</strong>, <strong>CAPT_updateSensor()</strong>, or <strong>CAPT_updateSensorWithEMC()</strong>), the dominant element value is updated.</p>
<p>Elements are mapped to IDs starting with the first element of the first cycle to the last element of the last cycle. For example, a sensor with two cycles and two elements in each cycle would have the following mapping:</p>
<ul class="simple">
<li>0: Cycle 0 Element 0</li>
<li>1: Cycle 0 Element 1</li>
<li>2: Cycle 1 Element 0</li>
<li>3: Cycle 1 Element 1</li>
</ul>
<div class="section" id="accessing-the-dominant-button-directly">
<h4>Accessing the Dominant Button Directly<a class="headerlink" href="#accessing-the-dominant-button-directly" title="Permalink to this headline">¶</a></h4>
<p>The example below shows how to directly access the value in the <em>tButtonSensorParams</em> structure. The LED is illuminated if a touch is present and the dominant key is the first element.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">tButtonSensorParams</span> <span class="n">keypadSensor_Params</span><span class="p">;</span>

<span class="n">void</span> <span class="n">updateLED</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">keypadSensor</span><span class="o">.</span><span class="n">bSensorTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keypadSensor_Params</span><span class="o">.</span><span class="n">ui16DominantElement</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">ILLUMINATE</span> <span class="n">LED</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">TURN</span> <span class="n">OFF</span> <span class="n">LED</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">TURN</span> <span class="n">OFF</span> <span class="n">LED</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-the-dominant-button-indirectly">
<h4>Accessing the Dominant Button Indirectly<a class="headerlink" href="#accessing-the-dominant-button-indirectly" title="Permalink to this headline">¶</a></h4>
<p>Note that in the example above, it was necessary to forward declare keypadSensor_Params. It is also possible to &#8220;look up&#8221; these parameter structures through the parent sensor structure, as shown below. All sensor structures are forward declared in the user configuration header file (<em>CAPT_UserConfig.h</em>), and do not need to be re-declared. It is necessary to type-cast the parameter structure based on the type of sensor.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">updateLED</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">dominantButton</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">keypadSensor</span><span class="o">.</span><span class="n">bSensorTouch</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dominantButton</span> <span class="o">=</span> <span class="p">((</span><span class="n">tButtonSensorParams</span><span class="o">*</span><span class="p">)(</span><span class="n">keypadSensor</span><span class="o">.</span><span class="n">pSensorParams</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">ui16DominantElement</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dominantButton</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">ILLUMINATE</span> <span class="n">LED</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">TURN</span> <span class="n">OFF</span> <span class="n">LED</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">TURN</span> <span class="n">OFF</span> <span class="n">LED</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-the-dominant-button-with-a-function-call">
<h4>Accessing the Dominant Button with a Function Call<a class="headerlink" href="#accessing-the-dominant-button-with-a-function-call" title="Permalink to this headline">¶</a></h4>
<p>The final way to access the dominant button value is via a function call to <strong>CAPT_getDominantButton()</strong> or <strong>CAPT_getDominantButtonAddr()</strong>. The former function returns the ID of the dominant button, while the latter function returns the memory address (essentially a pointer to) the dominant element.</p>
<p>The example below demonstrates accessing the dominant button ID via a function call.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">updateLEDs</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">dominantElement</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">keypadSensor</span><span class="o">.</span><span class="n">bSensorTouch</span><span class="o">==</span><span class="n">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">keypadSensor</span><span class="o">.</span><span class="n">bSensorPrevTouch</span><span class="o">==</span><span class="n">false</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">dominantElement</span> <span class="o">=</span> <span class="n">CAPT_getDominantButton</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dominantElement</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LED1_OFF</span><span class="p">;</span>
            <span class="n">LED2_OFF</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dominantElement</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LED1_ON</span><span class="p">;</span>
            <span class="n">LED2_OFF</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dominantElement</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LED1_OFF</span><span class="p">;</span>
            <span class="n">LED2_ON</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dominantElement</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LED1_ON</span><span class="p">;</span>
            <span class="n">LED2_ON</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The example below demonstrates processing of the dominant button based on a pointer to the dominant element.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">tElement</span> <span class="n">keypadSensor_E00</span><span class="p">;</span>
<span class="n">extern</span> <span class="n">tElement</span> <span class="n">keypadSensor_E01</span><span class="p">;</span>
<span class="n">extern</span> <span class="n">tElement</span> <span class="n">keypadSensor_E02</span><span class="p">;</span>
<span class="n">extern</span> <span class="n">tElement</span> <span class="n">keypadSensor_E03</span><span class="p">;</span>

<span class="n">void</span> <span class="n">updateLEDs</span><span class="p">(</span><span class="n">tSensor</span> <span class="o">*</span><span class="n">sensor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">tElement</span><span class="o">*</span> <span class="n">dominantElement</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">keypadSensor</span><span class="o">.</span><span class="n">bSensorTouch</span><span class="o">==</span><span class="n">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">keypadSensor</span><span class="o">.</span><span class="n">bSensorPrevTouch</span><span class="o">==</span><span class="n">false</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">dominantElement</span> <span class="o">=</span> <span class="n">CAPT_getDominantButtonAddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dominantElement</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">keypadSensor_E00</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LED1_OFF</span><span class="p">;</span>
            <span class="n">LED2_OFF</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dominantElement</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">keypadSensor_E01</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LED1_ON</span><span class="p">;</span>
            <span class="n">LED2_OFF</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dominantElement</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">keypadSensor_E02</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LED1_OFF</span><span class="p">;</span>
            <span class="n">LED2_ON</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dominantElement</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">keypadSensor_E03</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LED1_ON</span><span class="p">;</span>
            <span class="n">LED2_ON</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="access-slider-or-wheel-position-data">
<h3>Access Slider or Wheel Position Data<a class="headerlink" href="#access-slider-or-wheel-position-data" title="Permalink to this headline">¶</a></h3>
<p>Slider and wheel sensors output a position in addition to touch and proximity status. The position value is available as a IQ16-style value, with 16 integer bits and 16 fractional bits. For almost all applications, the integer bits are the bits of interest, and the fractional bits are merely there to support filtering.</p>
<p>When a slider or wheel sensor is updated (via <strong>CAPT_updateUI()</strong>, <strong>CAPT_updateSensor()</strong>, or <strong>CAPT_updateSensorWithEMC()</strong>), the position value is updated.</p>
<p><strong>NOTE:</strong> When a slider or wheel sensor is not being touched, a value of 0xFFFF (UINT16_MAX) is reported.</p>
<div class="section" id="accessing-the-slider-or-wheel-position-directly">
<h4>Accessing the Slider or Wheel Position Directly<a class="headerlink" href="#accessing-the-slider-or-wheel-position-directly" title="Permalink to this headline">¶</a></h4>
<p>The example below shows how to directly access the slider and wheel position parameters in the <em>tSliderSensorParams</em> and <em>tWheelSensorParams</em> structures, respectively. The application assigns the values to the speakerVolume and optionSelection variables, which are intended to represent functionality in an application.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">uint16_t</span> <span class="n">speakerVolume</span><span class="p">;</span>
<span class="n">uint16_t</span> <span class="n">optionSelection</span><span class="p">;</span>
<span class="n">extern</span> <span class="n">tSliderSensorParams</span> <span class="n">volumeSlider_Params</span><span class="p">;</span>
<span class="n">extern</span> <span class="n">tWheelSensorParams</span> <span class="n">scrollWheel_Params</span><span class="p">;</span>

<span class="n">void</span> <span class="n">updateVolumeAndOptionSelection</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">speaker</span> <span class="n">volume</span> <span class="n">to</span> <span class="n">the</span> <span class="n">natural</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">16</span> <span class="n">bit</span> <span class="n">slider</span> <span class="n">position</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">volumeSlider_Params</span><span class="o">.</span><span class="n">SliderPosition</span><span class="o">.</span><span class="n">ui16Natural</span> <span class="o">!=</span> <span class="n">UINT16_MAX</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">speakerVolume</span> <span class="o">=</span> <span class="n">volumeSlider_Params</span><span class="o">.</span><span class="n">SliderPosition</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">option</span> <span class="n">selection</span> <span class="n">to</span> <span class="n">the</span> <span class="n">natural</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">16</span> <span class="n">bit</span> <span class="n">wheel</span> <span class="n">position</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scrollWheel_Params</span><span class="o">.</span><span class="n">SliderPosition</span><span class="o">.</span><span class="n">ui16Natural</span> <span class="o">!=</span> <span class="n">UINT16_MAX</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">optionSelection</span> <span class="o">=</span> <span class="n">scrollWheel_Params</span><span class="o">.</span><span class="n">SliderPosition</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-the-slider-or-wheel-position-indirectly">
<h4>Accessing the Slider or Wheel Position Indirectly<a class="headerlink" href="#accessing-the-slider-or-wheel-position-indirectly" title="Permalink to this headline">¶</a></h4>
<p>Note that in the example above, it was necessary to forward declare volumeSlider_Params and scrollWheel_Params. It is also possible to &#8220;look up&#8221; these parameter structures through the parent sensor structure, as shown below. All sensor structures are forward declared in the user configuration header file (<em>CAPT_UserConfig.h</em>), and do not need to be re-declared. It is necessary to type-cast the parameter structure based on the type of sensor.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">uint16_t</span> <span class="n">speakerVolume</span><span class="p">;</span>
<span class="n">uint16_t</span> <span class="n">optionSelection</span><span class="p">;</span>

<span class="n">void</span> <span class="n">updateVolumeAndOptionSelection</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uint16_t</span> <span class="n">position</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">speaker</span> <span class="n">volume</span> <span class="n">to</span> <span class="n">the</span> <span class="n">natural</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">16</span> <span class="n">bit</span> <span class="n">slider</span> <span class="n">position</span>
    <span class="n">position</span> <span class="o">=</span> <span class="p">((</span><span class="n">tSliderSensorParams</span><span class="o">*</span><span class="p">)(</span><span class="n">volumeSlider</span><span class="o">.</span><span class="n">pSensorParams</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">SliderPosition</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">position</span> <span class="o">!=</span> <span class="n">UINT16_MAX</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">speakerVolume</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">option</span> <span class="n">selection</span> <span class="n">to</span> <span class="n">the</span> <span class="n">natural</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">16</span> <span class="n">bit</span> <span class="n">wheel</span> <span class="n">position</span>
    <span class="n">position</span> <span class="o">=</span> <span class="p">((</span><span class="n">tWheelSensorParams</span><span class="o">*</span><span class="p">)(</span><span class="n">scrollWheel</span><span class="o">.</span><span class="n">pSensorParams</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">SliderPosition</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">position</span> <span class="o">!=</span> <span class="n">UINT16_MAX</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">optionSelection</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that for both slider and wheel parameter structures, the parameter for position is called <em>SliderPosition</em>. This is because both of these sensor types utilize the same processing algorithm.</p>
</div>
<div class="section" id="accessing-the-slider-or-wheel-position-with-a-function-call">
<h4>Accessing the Slider or Wheel Position with a Function Call<a class="headerlink" href="#accessing-the-slider-or-wheel-position-with-a-function-call" title="Permalink to this headline">¶</a></h4>
<p>The final (and simplest) way to access slider or wheel position is via a function call to <strong>CAPT_getSensorPosition()</strong>. This function will return 0xFFFF (UINT16_MAX) if no touch is present.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">uint16_t</span> <span class="n">speakerVolume</span><span class="p">;</span>
<span class="n">uint16_t</span> <span class="n">optionSelection</span><span class="p">;</span>

<span class="n">void</span> <span class="n">updateVolumeAndOptionSelection</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uint16_t</span> <span class="n">position</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">speaker</span> <span class="n">volume</span> <span class="n">to</span> <span class="n">the</span> <span class="n">natural</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">16</span> <span class="n">bit</span> <span class="n">slider</span> <span class="n">position</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">CAPT_getSensorPosition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">volumeSlider</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">position</span> <span class="o">!=</span> <span class="n">UINT16_MAX</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">speakerVolume</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">option</span> <span class="n">selection</span> <span class="n">to</span> <span class="n">the</span> <span class="n">natural</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">16</span> <span class="n">bit</span> <span class="n">wheel</span> <span class="n">position</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">CAPT_getSensorPosition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scrollWheel</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">position</span> <span class="o">!=</span> <span class="n">UINT16_MAX</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">optionSelection</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using the function call allows the software implementation to be clearer, at the penalty of function overhead.</p>
</div>
</div>
<div class="section" id="access-element-measurement-data">
<h3>Access Element Measurement Data<a class="headerlink" href="#access-element-measurement-data" title="Permalink to this headline">¶</a></h3>
<p>Each element in a sensor has several variables that contain the current measurement data. The following values are provided:</p>
<ul class="simple">
<li>Filtered Count (The conversion result)</li>
<li>Long Term Average (LTA) (The baseline reference)</li>
<li>Raw Count(s) (The raw data sample before any processing is applied)</li>
<li>Composite Raw Count (The composite data sample of a multi-frequency or oversampled conversion)</li>
<li>Previous Composite Raw Count (The previous composite data sample of a multi-frequency or oversampled conversion)</li>
</ul>
<p>When a sensor is updated (via <strong>CAPT_updateUI()</strong>, <strong>CAPT_updateSensor()</strong>, or <strong>CAPT_updateSensorWithEMC()</strong>), these variables are updated for every element within the sensor. There are multiple ways to retrieve the data.</p>
<div class="section" id="id2">
<h4>Accessing Element State Data Directly<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>It is possible to access element measurement data directly in an element&#8217;s data structure. To do this, it is necessary to know the name of the variable in the element. An example is shown below that uses element 0 of a sensor named <em>keypad</em>.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">tElement</span> <span class="n">keypad_E00</span><span class="p">;</span>

<span class="n">void</span> <span class="n">myDataFunction</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uint16_t</span> <span class="n">data</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Place</span> <span class="n">the</span> <span class="n">filtered</span> <span class="n">count</span> <span class="n">value</span> <span class="n">into</span> <span class="n">the</span> <span class="s1">&#39;data&#39;</span> <span class="n">variable</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">Note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">filtered</span> <span class="n">count</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">IQ16</span> <span class="nb">format</span> <span class="n">variable</span> <span class="k">with</span> <span class="mi">16</span> <span class="n">integer</span> <span class="n">bits</span> <span class="ow">and</span> <span class="mi">16</span> <span class="n">fractional</span> <span class="n">bits</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">Typically</span><span class="p">,</span> <span class="n">only</span> <span class="n">the</span> <span class="n">integer</span> <span class="n">bits</span> <span class="n">are</span> <span class="n">of</span> <span class="n">interest</span><span class="o">.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">keypad_E00</span><span class="o">.</span><span class="n">filterCount</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">;</span>
    <span class="n">__no_operation</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Place</span> <span class="n">the</span> <span class="n">long</span> <span class="n">term</span> <span class="n">average</span> <span class="n">into</span> <span class="n">the</span> <span class="s1">&#39;data&#39;</span> <span class="n">variable</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">Note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">LTA</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">IQ16</span> <span class="nb">format</span> <span class="n">variable</span> <span class="k">with</span> <span class="mi">16</span> <span class="n">integer</span> <span class="n">bits</span> <span class="ow">and</span> <span class="mi">16</span> <span class="n">fractional</span> <span class="n">bits</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">Typically</span><span class="p">,</span> <span class="n">only</span> <span class="n">the</span> <span class="n">integer</span> <span class="n">bits</span> <span class="n">are</span> <span class="n">of</span> <span class="n">interest</span><span class="o">.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">keypad_E00</span><span class="o">.</span><span class="n">LTA</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">;</span>
    <span class="n">__no_operation</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Place</span> <span class="n">the</span> <span class="n">raw</span> <span class="n">count</span> <span class="n">value</span> <span class="n">into</span> <span class="n">the</span> <span class="s1">&#39;data&#39;</span> <span class="n">variable</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">Note</span> <span class="n">that</span> <span class="n">there</span> <span class="n">may</span> <span class="n">be</span> <span class="n">either</span> <span class="mi">1</span> <span class="ow">or</span> <span class="mi">4</span> <span class="n">raw</span> <span class="n">count</span> <span class="n">variables</span><span class="p">,</span> <span class="n">depending</span> <span class="n">on</span> <span class="n">whether</span> <span class="n">the</span> <span class="n">conversion</span>
    <span class="o">//</span> <span class="nb">type</span> <span class="n">used</span> <span class="ow">is</span> <span class="n">single</span> <span class="ow">or</span> <span class="n">multi</span><span class="o">-</span><span class="n">frequency</span><span class="o">.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">keypad_E00</span><span class="o">.</span><span class="n">pRawCount</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">__no_operation</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">the</span> <span class="n">conversion</span> <span class="ow">is</span> <span class="n">multi</span><span class="o">-</span><span class="n">frequency</span><span class="p">,</span> <span class="n">then</span> <span class="n">keypad_E00</span><span class="o">.</span><span class="n">pRawCount</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">holds</span> <span class="n">frequency</span> <span class="mi">0</span><span class="s1">&#39;s result,</span>
    <span class="o">//</span> <span class="ow">and</span> <span class="n">keypad_E00</span><span class="o">.</span><span class="n">pRawCount</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">holds</span> <span class="n">frequency</span> <span class="mi">3</span><span class="s1">&#39;s result.</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">raw</span> <span class="n">composite</span> <span class="n">result</span> <span class="n">of</span> <span class="nb">all</span> <span class="mi">4</span> <span class="n">frequencies</span> <span class="ow">is</span> <span class="n">placed</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">keypad_E00</span><span class="o">.</span><span class="n">ui16CompositeRawCount</span> <span class="n">variable</span><span class="o">.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">keypad_E00</span><span class="o">.</span><span class="n">ui16CompositeRawCount</span><span class="p">;</span>
    <span class="n">__no_operation</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-element-measurement-data-indirectly">
<h4>Accessing Element Measurement Data Indirectly<a class="headerlink" href="#accessing-element-measurement-data-indirectly" title="Permalink to this headline">¶</a></h4>
<p>Note that in the example above, it was necessary to forward declare keypad_E00. It is also possible to &#8220;look up&#8221; E00 of the keypad sensor though the parent sensor structure, as shown below. All sensor structures are forward declared in the user configuration header file (<em>CAPT_UserConfig.h</em>), and do not need to be re-declared. The element of interest is accessed via the cycle pointer array and the element pointer array of that cycle.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">myDataFunction</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uint16_t</span> <span class="n">data</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Place</span> <span class="n">the</span> <span class="n">filtered</span> <span class="n">count</span> <span class="n">value</span> <span class="n">into</span> <span class="n">the</span> <span class="s1">&#39;data&#39;</span> <span class="n">variable</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">Note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">filtered</span> <span class="n">count</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">IQ16</span> <span class="nb">format</span> <span class="n">variable</span> <span class="k">with</span> <span class="mi">16</span> <span class="n">integer</span> <span class="n">bits</span> <span class="ow">and</span> <span class="mi">16</span> <span class="n">fractional</span> <span class="n">bits</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">Typically</span><span class="p">,</span> <span class="n">only</span> <span class="n">the</span> <span class="n">integer</span> <span class="n">bits</span> <span class="n">are</span> <span class="n">of</span> <span class="n">interest</span><span class="o">.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">keypad</span><span class="o">.</span><span class="n">pCycle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pElements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">filterCount</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">;</span>
    <span class="n">__no_operation</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="update-sensors-independently">
<h3>Update Sensors Independently<a class="headerlink" href="#update-sensors-independently" title="Permalink to this headline">¶</a></h3>
<p>Up until this point, all discussion around measuring sensors has been via the top level API- specifically, the <strong>CAPT_updateUI()</strong> call. When using the <strong>CAPT_updateUI()</strong> function call, all sensors in the application are updated. For most applications, this is the desired operation. However, there are cases where it may be desired to update sensors individually or at different rates. This how-to explains the function calls that are used to individually update sensors. There are two function calls available for updating a sensor: <strong>CAPT_updateSensor()</strong> and <strong>CAPT_updateSensorWithEMC()</strong>.</p>
<div class="section" id="capt-updatesensor">
<h4>CAPT_updateSensor()<a class="headerlink" href="#capt-updatesensor" title="Permalink to this headline">¶</a></h4>
<p>This is the standard sensor update function. After calling this function, the following values are updated for the passed sensor only:</p>
<ul class="simple">
<li>Raw counts</li>
<li>Filtered counts</li>
<li>Long term averages (LTAs)</li>
<li>Detect and negative touch flags</li>
<li>Touch and proximity flags</li>
<li>Previous touch flags</li>
<li>Dominant element ID (for a button group)</li>
<li>Position (for a slider or wheel)</li>
<li>Max count error flags and noise state flags</li>
<li>De-bounce counters</li>
</ul>
<p>Below is the syntax used to call the function. The parameters include a pointer to the sensor to update, and the low power mode bits to set during the conversion process. LPM0, LPM1, LPM2, and LPM3 may be used.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">CAPT_updateSensor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">,</span> <span class="n">LPM0_bits</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="capt-updatesensorwithemc">
<h4>CAPT_updateSensorWithEMC()<a class="headerlink" href="#capt-updatesensorwithemc" title="Permalink to this headline">¶</a></h4>
<p>The EMC version of the sensor update call provides the same end functionality as the standard call, with the exception that EMC plug-ins from the advanced layer are applied. When this function is used, the EMC configuration structure defines the style of conversion to use. This may mean that multi-frequency scanning and/or oversampling is utilized.</p>
<p>The syntax for the EMC version is identical to the standard version, as shown below. This is to provide a standard call so that application code does not need to change significantly to accommodate switching to an EMC scanning mode. All EMC plug-in configuration is controlled by the EMC configuration structure.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">CAPT_updateSensorWithEMC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">,</span> <span class="n">LPM0_bits</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="important-functionality-to-handle">
<h4>Important Functionality to Handle<a class="headerlink" href="#important-functionality-to-handle" title="Permalink to this headline">¶</a></h4>
<p>When the sensor update functions are used rather than the top level API, several other tasks need to be handled by the application, such as testing for a re-calibration condition or transmitting data.</p>
<div class="section" id="testing-for-re-calibration">
<h5>Testing for Re-Calibration<a class="headerlink" href="#testing-for-re-calibration" title="Permalink to this headline">¶</a></h5>
<p>Over time, the long term average of a sensor may drift. To ensure that consistent sensitivity is always provided, the software library provides a mechanism to test to see if any element in a sensor has drifted outside of an acceptable boundary. This mechanism is the <strong>CAPT_testForRecalibration()</strong> function. The <strong>CAPT_updateUI()</strong> function takes care of handling this when the top level API is used, but if sensors are updated individually then this needs to be handled by the application.</p>
<p>The typical handling method is shown below:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Update</span> <span class="n">the</span> <span class="n">individual</span> <span class="n">sensor</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">CAPT_updateSensor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">,</span> <span class="n">LPM0_bits</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Test</span> <span class="k">for</span> <span class="n">a</span> <span class="n">re</span><span class="o">-</span><span class="n">calibration</span> <span class="n">condition</span>
<span class="k">if</span> <span class="p">(</span><span class="n">CAPT_testForRecalibration</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">)</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">If</span> <span class="n">a</span> <span class="n">re</span><span class="o">-</span><span class="n">calibration</span> <span class="ow">is</span> <span class="n">required</span><span class="p">,</span> <span class="n">perform</span> <span class="n">it</span> <span class="n">now</span>
    <span class="n">CAPT_calibrateSensor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For details on how the re-calibration test works, see the <a class="reference external" href="ch_glossary.html#run-time-recalibration">runtime re-calibration</a> definition.</p>
</div>
<div class="section" id="transmitting-sensor-and-element-data">
<h5>Transmitting Sensor and Element Data<a class="headerlink" href="#transmitting-sensor-and-element-data" title="Permalink to this headline">¶</a></h5>
<p>If communication via the COMM module is desired, it is nescessary to add the calls to transmit the sensor and element data for this sensor via the COMM module.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span>
<span class="o">//</span> <span class="n">If</span> <span class="n">the</span> <span class="n">UART</span> <span class="ow">or</span> <span class="n">Bulk</span> <span class="n">I2C</span> <span class="n">interface</span> <span class="ow">is</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">write</span> <span class="n">out</span> <span class="n">element</span>
<span class="o">//</span> <span class="ow">and</span> <span class="n">sensor</span> <span class="n">data</span><span class="o">.</span>
<span class="o">//</span>
<span class="c1">##if ((CAPT_INTERFACE==__CAPT_UART_INTERFACE__)||\</span>
        <span class="p">(</span><span class="n">CAPT_INTERFACE</span><span class="o">==</span><span class="n">__CAPT_BULKI2C_INTERFACE__</span><span class="p">))</span>
<span class="n">CAPT_writeElementData</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">CAPT_writeSensorData</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="c1">##endif</span>
</pre></div>
</div>
<p>In this code example, &#8216;x&#8217; represents the sensor&#8217;s integer ID. This ID is the position of the sensor in the global sensor pointer array. This is the array that the COMM module uses to look up sensors.</p>
<p>For the CAPTIVATE-BSWP demo panel, the array looks like this:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">tSensor</span><span class="o">*</span> <span class="n">g_pCaptivateSensorArray</span><span class="p">[</span><span class="n">CAPT_SENSOR_COUNT</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">proximitySensor</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">sliderSensor</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">wheelSensor</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Thus, the ID of the keypad sensor would be 0.</p>
</div>
</div>
<div class="section" id="full-implementation">
<h4>Full Implementation<a class="headerlink" href="#full-implementation" title="Permalink to this headline">¶</a></h4>
<p>Putting it all together, updating a sensor individually would have the following progression:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Update</span> <span class="n">the</span> <span class="n">individual</span> <span class="n">sensor</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">CAPT_updateSensor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">,</span> <span class="n">LPM0_bits</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Test</span> <span class="k">for</span> <span class="n">a</span> <span class="n">re</span><span class="o">-</span><span class="n">calibration</span> <span class="n">condition</span>
<span class="k">if</span> <span class="p">(</span><span class="n">CAPT_testForRecalibration</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">)</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">If</span> <span class="n">a</span> <span class="n">re</span><span class="o">-</span><span class="n">calibration</span> <span class="ow">is</span> <span class="n">required</span><span class="p">,</span> <span class="n">perform</span> <span class="n">it</span> <span class="n">now</span>
    <span class="n">CAPT_calibrateSensor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">If</span> <span class="n">communications</span> <span class="n">are</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">transmit</span> <span class="n">data</span> <span class="n">now</span>
<span class="c1">##if ((CAPT_INTERFACE==__CAPT_UART_INTERFACE__)||\</span>
        <span class="p">(</span><span class="n">CAPT_INTERFACE</span><span class="o">==</span><span class="n">__CAPT_BULKI2C_INTERFACE__</span><span class="p">))</span>
<span class="n">CAPT_writeElementData</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">CAPT_writeSensorData</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">##endif</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="update-a-sensor-s-raw-data-only">
<h3>Update a Sensor&#8217;s Raw Data Only<a class="headerlink" href="#update-a-sensor-s-raw-data-only" title="Permalink to this headline">¶</a></h3>
<p>For certain custom applications it may be desirable to only update a sensor&#8217;s raw data after a conversion, bypassing all of the high-level processing. For applications that require this, the <strong>CAPT_updateSensorRawCount()</strong> may be used directly. This function only updates raw count values for each element in the sensor. No processing is performed on the data, and the sensor callback function is not called upon completion of the update. The raw data update function takes two additional parameters that specify details about type of conversion. An example function call is shown below that updates the raw data for a sensor named <em>keypad</em>. For details on the conversion type and oversampling type parameters, see the <a class="reference external" href="ch_library.html#capt-updatesensorrawcount">CAPT_updateSensorRawCount</a> overview.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">CAPT_updateSensorRawCount</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">,</span>      <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">sensor</span> <span class="n">to</span> <span class="n">update</span>
        <span class="n">eStandard</span><span class="p">,</span>          <span class="o">//</span> <span class="n">Conversion</span> <span class="nb">type</span>
        <span class="n">eNoOversampling</span><span class="p">,</span>    <span class="o">//</span> <span class="n">Oversampling</span> <span class="nb">type</span>
        <span class="n">LPM0_bits</span>           <span class="o">//</span> <span class="n">Low</span> <span class="n">power</span> <span class="n">mode</span> <span class="n">to</span> <span class="n">use</span>
    <span class="p">);</span>
</pre></div>
</div>
<p>After the update is complete, results may be looked up in each element&#8217;s data structure. The following values are updated by this function:</p>
<ul class="simple">
<li>Composite Raw Count (The raw result after the specied multi-frequency processing or oversampling)</li>
<li>Previous Composite Raw Count (The composite raw result from the previous sample)</li>
<li>Noise Level (if the conversion was a multi-frequency conversion, the spread between data at frequencies)</li>
<li>Raw Count for Each Frequency (if the conversion was a multi-frequency conversion, else a single frequency)</li>
</ul>
<p>Below is an example of measuring a sensor named <em>keypad</em> without frequency hopping and with an oversampling level of 2. The composite output is read and used to perform some unknown task.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">tElement</span> <span class="n">keypadSensor_E00</span><span class="p">;</span>
<span class="n">uint16_t</span> <span class="n">rawSample</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">update</span>
<span class="n">CAPT_updateSensorRawCount</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">,</span>      <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">sensor</span> <span class="n">to</span> <span class="n">update</span>
        <span class="n">eStandard</span><span class="p">,</span>          <span class="o">//</span> <span class="n">Conversion</span> <span class="nb">type</span>
        <span class="n">e2xOversampling</span><span class="p">,</span>    <span class="o">//</span> <span class="n">Oversampling</span> <span class="nb">type</span>
        <span class="n">LPM0_bits</span>           <span class="o">//</span> <span class="n">Low</span> <span class="n">power</span> <span class="n">mode</span> <span class="n">to</span> <span class="n">use</span>
    <span class="p">);</span>

<span class="o">//</span> <span class="n">Read</span> <span class="n">out</span> <span class="n">the</span> <span class="n">data</span>
<span class="n">rawSample</span> <span class="o">=</span> <span class="n">keypadSensor_E00</span><span class="o">.</span><span class="n">ui16CompositeRawCount</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Do</span> <span class="n">Something</span> <span class="o">...</span>
</pre></div>
</div>
<!---
### Enable an IO as a Shield
In self-capacitance mode, it is possible to enable an extra CapTIvate&trade; sensing IO
to fire in phase with other IOs during a conversion. This provides a shielding effect that
can reduce the parasitic capacitance of the sensing IOs.

In order to realize a shield IO, the following must be true:
1. The sensor of interest must be a self-capacitance sensor
2. The shield must be connected to an IO on a CapTIvate&trade; block that is not shared with the sensor of interest.
For example, if the sensor of interest is a proximity sensor on CAP0.0 (block 0, pin 0), the shield may be connected
to any pin on CAP1.x, CAP2.x, or CAP3.x- but it may NOT be connected to any pin on CAP0.x, since the proximity sensor
(the sensor of interest) is on that block. If a shield is enabled on the same block as the sensor of interest,
the effect will be equivalent to a digital "OR" in which the shield and the sensor of interest appear to be connected.

To enable an IO as a shield, use the library function **CAPT_enableShieldIO()** as shown below. This enables CAP1.0
to be a shield structure.

~~~{.c}
// Enable shield IO before calibration:
CAPT_enableShieldIO(1, 0);

// If needed, the shield can be disabled:
CAPT_disableShieldIO(1, 0);
~~~
---></div>
<div class="section" id="create-a-custom-emc-configuration">
<h3>Create a Custom EMC Configuration<a class="headerlink" href="#create-a-custom-emc-configuration" title="Permalink to this headline">¶</a></h3>
<p>When noise immunity is enabled for a design, or when any of the *WithEMC() function calls are used, the EMC processing plug-ins from the ADVANCED module are applied. The EMC processing plug-ins are configured via a data structure. A default configuration is provided in the user configuration file that works well for most applications. However, if some customization is needed the default structure in the user configuration file may be overridden and a new structure may be provided in the application.</p>
<p>While it is possible to directly edit the structure in the user configuration file, it is best to make the changes elsewhere as the user configuration file is auto-generated by the CapTIvate™ Design Center, and any changes will be lost when an update is performed.</p>
<p>To add a custom EMC configuration, create a new EMC configuration data structure by copying the structure from the user configuration file and placing it in the application. It must be re-named with a unique name. The new structure may be placed in the CAPT_App.c file, if desired. Below is an example:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">tEMCConfig</span> <span class="n">myCustomEMCConfig</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Conversion</span> <span class="n">Style</span>
    <span class="o">.</span><span class="n">selfModeConversionStyle</span> <span class="o">=</span> <span class="n">eMultiFrequency</span><span class="p">,</span>
    <span class="o">.</span><span class="n">projModeConversionStyle</span> <span class="o">=</span> <span class="n">eMultiFrequencyWithOutlierRemoval</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">Oversampling</span> <span class="n">Style</span>
    <span class="o">.</span><span class="n">selfModeOversamplingStyle</span> <span class="o">=</span> <span class="n">eNoOversampling</span><span class="p">,</span>
    <span class="o">.</span><span class="n">projModeOversamplingStyle</span> <span class="o">=</span> <span class="n">eNoOversampling</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">Jitter</span> <span class="n">Filter</span> <span class="n">Enable</span>
    <span class="o">.</span><span class="n">bJitterFilterEnable</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">Noise</span> <span class="n">Thresholds</span> <span class="ow">and</span> <span class="n">Calibration</span> <span class="n">Noise</span> <span class="n">Limits</span>
    <span class="o">.</span><span class="n">ui8NoiseThreshold</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui16CalibrationNoiseLimit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8CalibrationTestSampleSize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">Dynamic</span> <span class="n">Threshold</span> <span class="n">Adjustment</span> <span class="n">Parameters</span>
    <span class="o">.</span><span class="n">bEnableDynamicThresholdAdjustment</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8MaxRelThreshAdj</span> <span class="o">=</span> <span class="mi">76</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8NoiseLevelFilterEntryThresh</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8NoiseLevelFilterExitThresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8NoiseLevelFilterDown</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8NoiseLevelFilterUp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">coeffA</span> <span class="o">=</span> <span class="n">_IQ31</span><span class="p">(</span><span class="mf">0.0065</span><span class="p">),</span>
    <span class="o">.</span><span class="n">coeffB</span> <span class="o">=</span> <span class="n">_IQ31</span><span class="p">(</span><span class="mf">0.050</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The structure is not modified at runtime, and thus may be declared as a <em>const</em> object.</p>
<p>In the <strong>CAPT_appStart()</strong> function, there is a call to <strong>CAPT_loadEMCConfig()</strong>. Replace the passed configuration structure with the custom configuration structure.</p>
<p><strong>Original</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Load</span> <span class="n">the</span> <span class="n">EMC</span> <span class="n">configuration</span><span class="p">,</span> <span class="k">if</span> <span class="n">this</span> <span class="n">design</span> <span class="n">has</span>
    <span class="o">//</span> <span class="n">noise</span> <span class="n">immunity</span> <span class="n">features</span> <span class="n">enabled</span><span class="o">.</span> <span class="n">This</span> <span class="n">function</span> <span class="n">call</span>
    <span class="o">//</span> <span class="n">associates</span> <span class="n">an</span> <span class="n">EMC</span> <span class="n">configuration</span> <span class="k">with</span> <span class="n">the</span> <span class="n">EMC</span> <span class="n">module</span><span class="o">.</span>
    <span class="o">//</span>
<span class="c1">##if (CAPT_CONDUCTED_NOISE_IMMUNITY_ENABLE==true)</span>
    <span class="n">CAPT_loadEMCConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_EMCConfig</span><span class="p">);</span>
<span class="c1">##endif</span>
</pre></div>
</div>
<p><strong>Modified</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Load</span> <span class="n">the</span> <span class="n">EMC</span> <span class="n">configuration</span><span class="p">,</span> <span class="k">if</span> <span class="n">this</span> <span class="n">design</span> <span class="n">has</span>
    <span class="o">//</span> <span class="n">noise</span> <span class="n">immunity</span> <span class="n">features</span> <span class="n">enabled</span><span class="o">.</span> <span class="n">This</span> <span class="n">function</span> <span class="n">call</span>
    <span class="o">//</span> <span class="n">associates</span> <span class="n">an</span> <span class="n">EMC</span> <span class="n">configuration</span> <span class="k">with</span> <span class="n">the</span> <span class="n">EMC</span> <span class="n">module</span><span class="o">.</span>
    <span class="o">//</span>
<span class="c1">##if (CAPT_CONDUCTED_NOISE_IMMUNITY_ENABLE==true)</span>
    <span class="n">CAPT_loadEMCConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myCustomEMCConfig</span><span class="p">);</span>
<span class="c1">##endif</span>
</pre></div>
</div>
<p>Now, the custom configuration may be modified to suit the needs of the application. For details on how to set the parameters in the EMC configuration structure, see the <a class="reference external" href="ch_library.html#emc">EMC Module</a> section.</p>
</div>
<div class="section" id="stream-unformatted-data-to-the-design-center-gui">
<h3>Stream Unformatted Data to the Design Center GUI<a class="headerlink" href="#stream-unformatted-data-to-the-design-center-gui" title="Permalink to this headline">¶</a></h3>
<p>In addition to the element and sensor data streaming to the CapTIvate™ Design Center customizer windows, a mechanism exists to stream miscellaneous user-defined data to a oscilloscope plot with logging capability.</p>
<ul class="simple">
<li>The data format is 16-bit unsigned integers.</li>
<li>Up to 29 values may be streamed.</li>
</ul>
<p>To stream data, insert a call to the <strong>CAPT_writeGeneralPurposeData()</strong> function.</p>
<p>The function expects a pointer to an array of 16-bit unsigned integers, and a length value that specifies how many values there are, up to the maximum of 29.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##define BUFFER_SIZE (8)</span>
<span class="n">uint16_t</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>

<span class="o">//</span> <span class="n">Transmit</span> <span class="n">the</span> <span class="n">packet</span> <span class="n">via</span> <span class="n">the</span> <span class="n">general</span> <span class="n">purpose</span> <span class="n">data</span> <span class="n">mechanism</span>
<span class="n">CAPT_writeGeneralPurposeData</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
</pre></div>
</div>
<p>This mechanism is very helpful during development of noise immunity applications, as it allows for streaming of raw data and multi-frequency data. The code snippet below may be registered as a callback function for a sensor. It streams the data of the first element in the sensor with the following format:</p>
<ol class="arabic simple">
<li>LTA</li>
<li>Filtered Count</li>
<li>Abs Thresh</li>
<li>Noise Level</li>
<li>F0 Raw Value</li>
<li>F1 Raw Value</li>
<li>F2 Raw Value</li>
<li>F3 Raw Value</li>
</ol>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##define NOISETEST_PACKET_SIZE (8)</span>

<span class="n">void</span> <span class="n">NoiseTest_callbackHandler</span><span class="p">(</span><span class="n">tSensor</span><span class="o">*</span> <span class="n">pSensor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="n">uint16_t</span> <span class="n">packet</span><span class="p">[</span><span class="n">NOISETEST_PACKET_SIZE</span><span class="p">];</span>
    <span class="n">tElement</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
    <span class="n">uint16_t</span> <span class="n">threshold</span><span class="p">;</span>
    <span class="n">uint8_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">uint8_t</span> <span class="n">j</span><span class="p">;</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Initialize</span> <span class="n">variables</span>
    <span class="o">//</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">pCycle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pElements</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Compute</span> <span class="n">the</span> <span class="n">touch</span> <span class="n">threshold</span>
    <span class="o">//</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">ui8TouchThreshold</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">SensingMethod</span> <span class="o">==</span> <span class="n">eSelf</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">threshold</span> <span class="o">+=</span> <span class="n">CAPT_computeRelNoiseComp</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">threshold</span> <span class="o">&gt;</span> <span class="n">CAPT_getMaxRelThreshold</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">CAPT_getMaxRelThreshold</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">CAPT_convertRelToAbs</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">LTA</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">,</span> <span class="n">threshold</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pSensor</span><span class="o">-&gt;</span><span class="n">DirectionOfInterest</span> <span class="o">==</span> <span class="n">eDOIDown</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">LTA</span><span class="o">.</span><span class="n">ui16Natural</span> <span class="o">-</span> <span class="n">threshold</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">LTA</span><span class="o">.</span><span class="n">ui16Natural</span> <span class="o">+</span> <span class="n">threshold</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Frame</span> <span class="n">the</span> <span class="n">packet</span>
    <span class="o">//</span>
    <span class="n">packet</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">LTA</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">;</span>
    <span class="n">packet</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">filterCount</span><span class="o">.</span><span class="n">ui16Natural</span><span class="p">;</span>
    <span class="n">packet</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">;</span>
    <span class="n">packet</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">ui16NoiseCount</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">packet</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">pRawCount</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Transmit</span> <span class="n">the</span> <span class="n">packet</span> <span class="n">via</span> <span class="n">the</span> <span class="n">general</span> <span class="n">purpose</span> <span class="n">data</span> <span class="n">mechanism</span>
    <span class="o">//</span>
    <span class="n">CAPT_writeGeneralPurposeData</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NOISETEST_PACKET_SIZE</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When communications are enabled, this data will appear in the CapTIvate™ Design Center&#8217;s user data plot. To view the streaming data, add a user data log bean, as shown below:</p>
<div class="figure" id="id37">
<img alt="User Data Plot" src="../_images/lib_howto_userdataplot.png" />
<p class="caption"><span class="caption-number">Fig. 189 </span><span class="caption-text">User Data Plot</span></p>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="technical-details">
<h2>Technical Details<a class="headerlink" href="#technical-details" title="Permalink to this headline">¶</a></h2>
<p>The pre-compiled library, ROM, and memory model technical setup details of the CapTIvate™ Software Library are described below. For a description of which devices are used with which ROM headers and precompiled libraries, see the <a class="reference external" href="ch_device.html#device-family">device family</a> chapter.</p>
<div class="section" id="pre-compiled-libraries">
<h3>Pre-Compiled Libraries<a class="headerlink" href="#pre-compiled-libraries" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate Software Library ships with pre-compiled object libraries to support the various device families. When setting up a project for a device, ensure that the correct device library is included in the project build.</p>
</div>
<div class="section" id="devices-with-captivate-software-in-rom">
<h3>Devices with CapTIvate™ Software in ROM<a class="headerlink" href="#devices-with-captivate-software-in-rom" title="Permalink to this headline">¶</a></h3>
<p>Some MSP devices have portions of the CapTIvate™ Software Library in ROM, reducing the amount of FRAM or flash memory required for an application. Refer to the device data sheet to determine if a given device has library components in ROM.</p>
<p>Calling library functions directly from ROM requires the use of two header files that are provided with the library, rom_captivate.h and rom_map_captivate.h. These header files provide a mapping between functions in the software library archive and the same function located in a device&#8217;s ROM image.</p>
<p>A detailed list of the available functions in ROM on a given device can be found in the <a class="reference external" href="../../../../api_guide/FR2633/html/md_imports_01_romtable.html">ROM table</a> of the API guide.</p>
<p>Use the function call technique described in the following example to simplify the procedure.</p>
<p><strong>Example:</strong></p>
<p>To call the library function &#8220;foo()&#8221;, it is recommended to make an implicit ROM call <em>MAP_foo()</em>. The complier parses through the rom_map_captivate.h file to determine if the function resides in ROM, and if it does, will make the ROM call. If this function does not exist in ROM then the compiler will make a call to the pre-compiled library version.</p>
<p>It is possible to explicitly call the function &#8220;foo()&#8221; from the pre-compiled library using <em>foo()</em>. The linker will pull this function from the pre-compiled library during the link process, adding the function to FRAM program memory. To explicitly call the function &#8220;foo()&#8221; from ROM, use <em>ROM_foo()</em>. This will force the compiler to make a call to ROM, with no impact on FRAM program memory.</p>
</div>
<div class="section" id="msp430-cpux-memory-model">
<h3>MSP430 CPUX Memory Model<a class="headerlink" href="#msp430-cpux-memory-model" title="Permalink to this headline">¶</a></h3>
<p>Smaller memory map devices with the TI MSP430 CPUX core (such as the MSP430FR2633 device) have a total memory map that is less than 64kB. Such a memory map is accessible in its entirety with 16 bit pointers. In order to improve execution speed and reduce memory requirements, the ROM functions and pre-compiled library functions are compiled using the small code small data (SCSD) memory model for that device. As such, all CapTIvate™ software library projects for those devices must be compiled using the small code small data memory model in order to be compatible with the ROM functions and the pre-compiled library. Using the incorrect memory model will result in a linker error.</p>
</div>
</div>
<div class="section" id="id3">
<h2>Base Module<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>The base module implements the core of the CapTIvate™ Software Library. It is responsible for providing the base feature set for initializing, calibrating, measuring and processing capacitive sensors.</p>
<p>The base module contains the following components:</p>
<ul class="simple">
<li>Hardware Abstraction Layer (HAL)</li>
<li>Touch Layer</li>
<li>Interrupt Service Routine (ISR)</li>
<li>CapTIvate™ Software Library Type Definitions</li>
</ul>
<div class="section" id="hal">
<h3>HAL<a class="headerlink" href="#hal" title="Permalink to this headline">¶</a></h3>
<p>The hardware abstraction layer provides access to the CapTIvate™ peripheral. This includes functions for performing the following tasks:</p>
<ul class="simple">
<li>Configuring the CapTIvate™ peripheral periodic timer</li>
<li>Handling CapTIvate™ peripheral interrupts</li>
<li>Configuring IO for CapTIvate™</li>
<li>Configuring conversion settings</li>
<li>Loading and storing conversion results</li>
</ul>
</div>
<div class="section" id="touch">
<h3>Touch<a class="headerlink" href="#touch" title="Permalink to this headline">¶</a></h3>
<p>The touch layer sits on top of the HAL layer and provides the sensor update routines, calibration algorithms, and basic sensor processing algorithms.</p>
<div class="section" id="sensor-update-routines">
<h4>Sensor Update Routines<a class="headerlink" href="#sensor-update-routines" title="Permalink to this headline">¶</a></h4>
<p>Several sensor update routines are available in the touch module:</p>
<ol class="arabic simple">
<li><strong>CAPT_updateSensor()</strong></li>
<li><strong>CAPT_updateSensorWithEMC()</strong></li>
<li><strong>CAPT_updateSensorRawCount()</strong></li>
</ol>
<div class="section" id="id4">
<h5>CAPT_updateSensor()<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>This is the standard, fundamental sensor update routine that is used in most applications. Calling this function will immediately measure all of the elements within the sensor, and perform all of the standard signal processing, including:</p>
<ol class="arabic simple">
<li>Applying any IIR count filtering as configured in the sensor structure. This function utilizes the hardware accelerated IIR filtering in the CapTIvate™ finite state machine.</li>
<li>Testing of touch, proximity, and negative touch thresholds. This function utilizes the detection capability of the CapTIvate™ finite state machine to detect proximity and negative touch events.</li>
<li>Processing of the long term average (LTA) as configured in the sensor structure. This function utilizes the hardware accelerated IIR filtering in the CapTIvate™ finite state machine to process the LTA.</li>
<li>Application of touch/proximity de-bounce as configured in the sensor structure.</li>
<li>Testing for re-calibration, if so configured in the sensor structure.</li>
</ol>
<p>The function takes two parameters:</p>
<ul class="simple">
<li>A pointer to the sensor structure to update</li>
<li>The low power mode to use during the conversion</li>
</ul>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">CAPT_updateSensor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mySensor</span><span class="p">,</span>  <span class="n">LPM3_bits</span><span class="p">);</span>
</pre></div>
</div>
<p>Low Power Mode</p>
<p>The low power mode may be LPM0 to LPM3. The function returns when all measurements and processing are complete.</p>
</div>
<div class="section" id="id5">
<h5>CAPT_updateSensorWithEMC()<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>This function is identical to <strong>CAPT_updateSensor()</strong>, with the addition of EMC processing components from the EMC module. See the <a class="reference external" href="ch_library.html#emc">EMC module</a> for more details.</p>
</div>
<div class="section" id="capt-updatesensorrawcount">
<h5>CAPT_updateSensorRawCount()<a class="headerlink" href="#capt-updatesensorrawcount" title="Permalink to this headline">¶</a></h5>
<p>This is a basic function that may be used if access to the raw conversion data if that is all that is desired. Using this function bypasses all of the higher-level processing. Filtered count, long term average, and status parameters are not maintained. Only the raw results are populated. However, the function does allow for some low-level signal processing algorithms to be applied.</p>
<p>The function takes 4 parameters:</p>
<ul class="simple">
<li>A pointer to the sensor structure to update</li>
<li>A conversion style specification</li>
<li>An oversampling specification</li>
<li>The low power mode to use during the conversion</li>
</ul>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">CAPT_updateSensorRawCount</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">,</span>      <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">sensor</span> <span class="n">to</span> <span class="n">update</span>
        <span class="n">eStandard</span><span class="p">,</span>          <span class="o">//</span> <span class="n">Conversion</span> <span class="nb">type</span>
        <span class="n">eNoOversampling</span><span class="p">,</span>    <span class="o">//</span> <span class="n">Oversampling</span> <span class="nb">type</span>
        <span class="n">LPM0_bits</span>           <span class="o">//</span> <span class="n">Low</span> <span class="n">power</span> <span class="n">mode</span> <span class="n">to</span> <span class="n">use</span>
    <span class="p">);</span>
</pre></div>
</div>
<p>Conversion Style</p>
<p>The conversion style control influences the type of conversion used to update the raw values. The output is stored in the <em>.ui16CompositeRawCount</em> parameter of each element.</p>
<table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Option</th>
<th class="head">tRawConversionStyle Enumeration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Standard</td>
<td>eStandard</td>
</tr>
<tr class="row-odd"><td>Multi-Frequency</td>
<td>eMultiFrequency</td>
</tr>
<tr class="row-even"><td>Multi-Frequency with Outlier Removal</td>
<td>eMultiFrequencyWithOutlierRemoval</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><strong>Standard conversion</strong>, in which each time cycle is measured once. This is the normal conversion style that should be used for most applications.</li>
<li><strong>Multi-frequency conversion</strong>, in which each time cycle is measured at 4 frequencies and the composite result is the average of the 4 frequencies.</li>
<li><strong>Multi-frequency conversion with outlier removal</strong>, in which each time cycle is measured at 4 frequencies and the composite result is the average of the 4 frequencies after the largest outlier is removed from the data set. This is useful for mutual capacitance sensors that require conducted noise immunity.</li>
</ul>
<p>Oversampling</p>
<p>The oversampling style control allows for the addition of oversampling in binary steps to a conversion. The available options are listed below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Option</th>
<th class="head">tOversamplingStyle Enumeration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>No Oversampling</td>
<td>eNoOversampling</td>
</tr>
<tr class="row-odd"><td>Double</td>
<td>e2xOversampling</td>
</tr>
<tr class="row-even"><td>Quadruple</td>
<td>e4xOversampling</td>
</tr>
<tr class="row-odd"><td>8x</td>
<td>e8xOversampling</td>
</tr>
<tr class="row-even"><td>16x</td>
<td>e16xOversampling</td>
</tr>
<tr class="row-odd"><td>32x</td>
<td>e32xOversampling</td>
</tr>
</tbody>
</table>
<p>When no oversampling is applied, each time cycle is sampled once and that value is used as the conversion result. When a level of oversampling is applied, each time cycle is sampled to the level of oversampling, and the results are averaged. This enables a basic averaging filter that helps with transient noise rejection.</p>
<p>Note that the measurement time increases 2x with each step.</p>
<p>Low Power Mode</p>
<p>The low power mode may be LPM0 to LPM3. The function returns when all measurements and processing are complete.</p>
</div>
</div>
<div class="section" id="environmental-drift-algorithms">
<h4>Environmental Drift Algorithms<a class="headerlink" href="#environmental-drift-algorithms" title="Permalink to this headline">¶</a></h4>
<p>Capacitive sensing measurement results will drift over time in response to environmental changes such as temperature and humidity. Humidity effects dielectric properties (specifically, the dielectric of air). Large temperature changes can effect on-chip circuitry by changing the resistance of a pathway in a circuit, or causing an oscillator frequency to drift. This is partially why capacitive sensing is a relative measurement and not an absolute measurement. A change in temperature, humidity, or both can appear to the system as a touch if not properly interpreted. In order to distinguish an environmental change from a touch, it is necessary to examine the rate of the change. A touch event occurs more quickly than a temperature drift in most applications, and the two changes may be distinguished from each other on that basis.</p>
<p>To ensure reliable operation, slow drift in a sensor&#8217;s measurement result due to temperature or humidity is handled by the CapTIvate Software Library in 3 ways:</p>
<ol class="arabic simple">
<li>First, the <a class="reference external" href="ch_glossary.html#lta-filter">long-term-average (LTA)</a> tracks measurement drift associated with slow environmental changes via a slow-moving IIR filter.</li>
<li>Second, the <a class="reference external" href="ch_glossary.html#touch-threshold">touch threshold</a> varies proportionally with the LTA, rather than as an absolute offset, to maintain sensitivity.</li>
<li>Third, if <a class="reference external" href="ch_glossary.html#run-time-recalibration">runtime recalibration</a> is enabled then the system will re-calibrate if the LTA drifts outside of a window set at +/- 1/8th of the specified <a class="reference external" href="ch_glossary.html#conversion-count">conversion count</a>. This re-normalizes the sensors to the specified <a class="reference external" href="ch_glossary.html#conversion-count">conversion count</a>.</li>
</ol>
<p>These three methods work together to ensure that the system behaves as designed across the lifetime of the product, even in different environments and climates.</p>
</div>
</div>
<div class="section" id="isr">
<h3>ISR<a class="headerlink" href="#isr" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate™ peripheral has a single interrupt vector with 5 possible interrupt sources. For details on the interrupts themselves, see the <a class="reference external" href="ch_technology.html#auxillary-digital-functions">auxiliary digital functions</a> section of the <a class="reference external" href="ch_technology.html">technology</a> chapter.</p>
<p>The software library uses the peripheral interrupts to set global status flags. The ISR is designed to quickly determine the cause of an interrupt, set the appropriate status flag, and exit. Upon exit, any low power mode is cleared so that the CPU remains alive after the interrupt. This is the mechanism that is used to wake up the application.</p>
<p>Of the 5 interrupts that are available, 2 are used solely by the library and 3 are left up to the application.</p>
<p>The following flags are used by the library, and generally do not need to be tested in the application:</p>
<ol class="arabic simple">
<li>End of Conversion Interrupt (<em>CAPT_END_OF_CONVERSION_INTERRUPT</em>, <em>CAPT_IV_END_OF_CONVERSION</em>). This interrupt is triggered when a time cycle conversion is complete. The ISR sets the <em>g_bEndOfConversionFlag</em>, which signals the library that the conversion is complete.</li>
<li>Max Count Error Interrupt (<em>CAPT_MAX_COUNT_ERROR_INTERRUPT</em>, <em>CAPT_IV_MAX_COUNT_ERROR</em>). This interrupt is triggered if a conversion exceeds the error threshold that was specified for a sensor. The ISR sets the <em>g_bMaxCountErrorFlag</em>, which signals the library that the error limit was reached and the conversion has stopped.</li>
</ol>
<p>The following flags are meant to be used by the application:</p>
<ol class="arabic simple" start="3">
<li>Conversion Timer Interrupt (<em>CAPT_TIMER_INTERRUPT</em>, <em>CAPT_IV_TIMER</em>). This interrupt is triggered when the CapTIvate™ interval timer has counted up to the compare register, indicating that it is time to trigger a conversion. The ISR sets the <em>g_bConvTimerFlag</em>. It is expected that the application is configuring and monitoring this interrupt.</li>
<li>Conversion Counter Interrupt (<em>CAPT_CONVERSION_COUNTER_INTERRUPT</em>, <em>CAPT_IV_CONVERSION_COUNTER</em>). This interrupt is triggered when conversion counter has reached the conversion counter interrupt threshold. This mechanism allows for an interrupt to be thrown after a certain number of conversions have taken place. In a wake-on-proximity application, this can be used to periodically wake up the CPU to ensure that the application is proceeding as expected and that all values are within range. This interrupt is enabled by the <strong>CAPT_startWakeOnProxMode()</strong> function, and is disabled by the <strong>CAPT_stopWakeOnProxMode()</strong> function.</li>
<li>Detection Interrupt (<em>CAPT_DETECTION_INTERRUPT</em>, <em>CAPT_IV_DETECTION</em>). This interrupt is triggered when any element in a time cycle has its proximity or negative touch thresholds exceeded at the end of a conversion. This mechanism allows for the CPU to wake up due to a threshold crossing. This interrupt is enabled by the <strong>CAPT_startWakeOnProxMode()</strong> function, and is disabled by the <strong>CAPT_stopWakeOnProxMode()</strong> function.</li>
</ol>
</div>
<div class="section" id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this headline">¶</a></h3>
<p>The type definitions file, <em>CAPT_Type.h</em>, contains the definitions for all of the data structures that are used in the library. It is important that the data structures are not modified! The library functions in ROM as well as the pre-compiled library are dependent upon the data structure configuration being consistent.</p>
</div>
</div>
<div class="section" id="id6">
<h2>Advanced Module<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>The advanced module serves two main purposes: It provides processing plug-ins to the base module, and it provides the top level API. The top level API is implemented by the manager module. Processing plug-ins include button processing, slider/wheel processing, and EMC processing.</p>
<div class="section" id="calibration">
<h3>Calibration<a class="headerlink" href="#calibration" title="Permalink to this headline">¶</a></h3>
<p>The calibration processing plug-in provides run-time sensor calibration services. These services take tuning parameter inputs from the sensor structure and tune the CapTIvate block independently for each sensing element within a sensor group (i.e. button group, slider, wheel) to achieve the desired performance. The calibration module contains top level functions for simple calibration of a sensor, as well as lower level calibration functions.</p>
<div class="section" id="calibration-background">
<h4>Calibration Background<a class="headerlink" href="#calibration-background" title="Permalink to this headline">¶</a></h4>
<p>The CapTIvate peripheral contains several unique features for controlling the resolution, sensitivity, and dynamic range of capacitive measurements. These features enable sensing solutions that are highly optimized for a wide variety of design careabouts, such as ultra low power, high sensitivity for thicker overlays, and large parasitic capacitances. The CapTIvate peripheral features are controlled by setting tuning values in the CapTIvate Design Center and CapTIvate Software Library.</p>
</div>
<div class="section" id="gain-and-offset">
<h4>Gain and Offset<a class="headerlink" href="#gain-and-offset" title="Permalink to this headline">¶</a></h4>
<p>Each CapTIvate measurement block on a device has adjustable gain and offset controls, as described in the <a class="reference external" href="ch_technology.html#signal-conditioning-sensitivity-related-functions">technology</a> chapter.</p>
<p>The controls that are available are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="50%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Function</th>
<th class="head">Min</th>
<th class="head">Max</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Coarse Gain</td>
<td>Coarse Input Scaling Knob</td>
<td>0</td>
<td>7</td>
</tr>
<tr class="row-odd"><td>Fine Gain</td>
<td>Fine Input Scaling Knob</td>
<td>0</td>
<td>19</td>
</tr>
<tr class="row-even"><td>Offset Scale</td>
<td>Offet Removal Scaling Knob</td>
<td>0</td>
<td>3</td>
</tr>
<tr class="row-odd"><td>Offset Level</td>
<td>Offset Removal Level</td>
<td>0</td>
<td>255</td>
</tr>
</tbody>
</table>
<p>These parameters control the signal conditioning applied during the transfer portion of each charge transfer phase during a conversion. The signal conditioning is applied when charge is transferred from the external capacitance to the internal sampling capacitor, per the diagram below.</p>
<div class="figure" id="id38">
<img alt="Charge Transfer Model" src="../_images/capblock_calibration.png" />
<p class="caption"><span class="caption-number">Fig. 190 </span><span class="caption-text">Charge Transfer Model</span></p>
</div>
<p>The four parameters influence the charge transfer process in the following way:</p>
<div class="figure" id="id39">
<img alt="Signal Conditioning Mathematical Model" src="../_images/calibration_parameter_formula.png" />
<p class="caption"><span class="caption-number">Fig. 191 </span><span class="caption-text">Signal Conditioning Mathematical Model</span></p>
</div>
<div class="section" id="gain-stage">
<h5>Gain Stage<a class="headerlink" href="#gain-stage" title="Permalink to this headline">¶</a></h5>
<p>The gain stage provides the ability to scale the size of the electrode capacitance as it appears to the integration capacitor. The charge associated with the input capacitance Q<sub>in</sub> is multiplied by the overall gain ratio gain<sub>coarse</sub> * gain<sub>fine</sub> to produce the amount of charge Q<sub>out</sub> that is actually transferred to the integration capacitor. This allows for a fixed size integration capacitor to be used on-chip, as the input capacitance is scaled with respect to it to control the measurement resolution.</p>
</div>
<div class="section" id="offset-subtraction-stage">
<h5>Offset Subtraction Stage<a class="headerlink" href="#offset-subtraction-stage" title="Permalink to this headline">¶</a></h5>
<p>The offset subtraction stage provides the ability to subtract a fixed amount of charge during each charge transfer, reducing the effect of the base parasitic capacitance. The charge associated with the input capacitance Q<sub>in</sub> is multiplied by the gain ratio (as discussed previously). Then a fixed amount of charge Q<sub>offset</sub> is scaled by offset<sub>scale</sub> and subtracted off during the transfer (and thus not brought over into the integration capacitor). This allows for a portion of the “DC” charge associated with an electrode’s parasitic capacitance to be subtracted out, increasing sensitivity to changes in capacitance.</p>
</div>
</div>
<div class="section" id="measurement-setup">
<h4>Measurement Setup<a class="headerlink" href="#measurement-setup" title="Permalink to this headline">¶</a></h4>
<p>Each sensing element that is measured must have a set of coarse gain, fine gain, offset scale, and offset level values assigned to it. Whenever a respective sensing element is updated, these values are loaded into the CapTIvate peripheral before measurement takes place. As a designer, you don’t need to select the parameters yourself. Instead, the CapTIvate Software Library contains runtime calibration algorithms that will automatically tune these parameters based on common inputs for all of the elements within the sensor. This calibration process occurs when a CapTIvate device first powers up (for instance, during the call to CAPT_calibrateUI() if the top level API is used). In some applications, it may also occur intermittently after startup if <a class="reference external" href="Runtime_ReCalibration.html">runtime recalibration</a> is enabled.</p>
</div>
<div class="section" id="calibration-routines">
<h4>Calibration Routines<a class="headerlink" href="#calibration-routines" title="Permalink to this headline">¶</a></h4>
<p>A calibration routine has the following responsibility:</p>
<p>Determine and save the coarse gain, fine gain, offset scale, and offset subtraction values that are needed for each element in a sensor based on the input parameters that are specified in the sensor structure.</p>
<div class="figure" id="id40">
<img alt="Calibration Algorithm Inputs and Outputs" src="../_images/calibration_alg_inputs_outputs.png" />
<p class="caption"><span class="caption-number">Fig. 192 </span><span class="caption-text">Calibration Algorithm Inputs and Outputs</span></p>
</div>
<p>As a software developer, you select the <em>inputs</em> to the calibration algorithm (conversion gain and conversion count), and the algorithm determines the coarse gain, fine gain, offset scale, and offset level.</p>
<p>There are two different conversion algorithms available for use: standard and max offset. Each of those algorithms has an equivalent algorithm for handling calibration when noise immunity features are enabled. This leads to a total of 4 different sensor calibration routines:</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Calibration Style</th>
<th class="head">Supports Noise Immunity Mode</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CAPT_calibrateSensor()</td>
<td>Standard</td>
<td>No</td>
</tr>
<tr class="row-odd"><td>CAPT_calibrateSensorWithEMC()</td>
<td>Standard</td>
<td>Yes</td>
</tr>
<tr class="row-even"><td>CAPT_calibrateSensorWithMaxOffset()</td>
<td>Max Offset</td>
<td>No</td>
</tr>
<tr class="row-odd"><td>CAPT_calibrateSensorWithMaxOffsetWithEMC()</td>
<td>Max Offset</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>Calibration routines are selected in the CapTIvate Design Center as a compile-time option in the controller customizer. The standard calibration method is the default method, and is recommended for most applications. If noise immunity is also selected in the controller customizer, then the respective &#8216;WithEMC&#8217; version of each algorithm will be used by the CapTIvate Software Library.</p>
<div class="figure" id="id41">
<img alt="Calibration Algorithm Selection" src="../_images/controller_customizer_calselect.png" />
<p class="caption"><span class="caption-number">Fig. 193 </span><span class="caption-text">Calibration Algorithm Selection</span></p>
</div>
<div class="section" id="standard-calibration-routine">
<h5>Standard Calibration Routine<a class="headerlink" href="#standard-calibration-routine" title="Permalink to this headline">¶</a></h5>
<p>The standard calibration routine is recommended for most applications. It provides moderate sensitivity with low temperature drift coefficients. The standard calibration process consists of the two-step procedure described below:</p>
<ol class="arabic simple">
<li>Calibrate Gain (implemented by the CAPT_calibrateGain() helper function)</li>
</ol>
<ul class="simple">
<li>Disable offset (offset level = 0)</li>
<li>Start with the smallest coarse gain and fine gain ratios</li>
<li>Increase coarse and fine gain ratios until the conversion result is as close to the specified conversion gain input parameter as possible</li>
</ul>
<ol class="arabic simple" start="2">
<li>Calibrate Offset (implemented by CAPT_calibrateOffset() helper function)</li>
</ol>
<ul class="simple">
<li>Start with the coarse and fine gain ratios selected during the gain calibration step</li>
<li>Set offset scale to lowest ratio of <em>very small</em> (0x00)</li>
<li>Increase offset level until the conversion result is as close as possible to the specified conversion count input parameter</li>
</ul>
</div>
<div class="section" id="max-offset-calibration-routine">
<h5>Max Offset Calibration Routine<a class="headerlink" href="#max-offset-calibration-routine" title="Permalink to this headline">¶</a></h5>
<p>The max offset calibration routine is recommended for applications that require higher sensitivity and/or lower scan times than what the standard calibration algorithm provides. This algorithm provides higher sensitivity at shorter scan times at the expense of higher temperature drift coefficients. It is not recommended for applications that are exposed to large temperature change rates (dT/dt). The max offset calibration process consists of the procedure described below:</p>
<ol class="arabic simple">
<li>Start with the maximum offset level (255)</li>
<li>Start with a maximum offset scale of <em>large</em> (0x02) for self capacitance, or <em>very small</em> (0x00) for mutual capacitance</li>
<li>Start with the smallest coarse gain and fine gain ratios</li>
<li>Increase coarse and fine gain ratios until the conversion result just exceeds the specified conversion count parameter</li>
<li>Decrease the offset level until the conversion result is as close as possible to the specified conversion count parameter</li>
</ol>
</div>
</div>
<div class="section" id="selecting-a-routine">
<h4>Selecting a Routine<a class="headerlink" href="#selecting-a-routine" title="Permalink to this headline">¶</a></h4>
<p>Selection of the correct calibration routine requires having an understanding of the application requirements. For most applications, the standard calibration algorithm is recommended, since it provides adequate sensitivity with good temperature drift characteristics. However, for applications that have minimal temperature changes or slow temperature changes, it is possible to increase sensitivity or reduce measurement times by using the max offset calibration routine.</p>
<div class="section" id="temperature-drift-rate-comparison">
<h5>Temperature Drift Rate Comparison<a class="headerlink" href="#temperature-drift-rate-comparison" title="Permalink to this headline">¶</a></h5>
<p>The plots below show typical temperature drift comparisons for standard calibration and max offset calibration. Drift rates for each are shown when calibrated for a 50-count delta as well as for a 100-count delta.</p>
<div class="figure" id="id42">
<img alt="Temperature Drift - Calibrated for 50 Counts of Delta" src="../_images/tempdrift_cal_50.png" />
<p class="caption"><span class="caption-number">Fig. 194 </span><span class="caption-text">Temperature Drift - Calibrated for 50 Counts of Delta</span></p>
</div>
<div class="figure" id="id43">
<img alt="Temperature Drift - Calibrated for 100 Counts of Delta" src="../_images/tempdrift_cal_100.png" />
<p class="caption"><span class="caption-number">Fig. 195 </span><span class="caption-text">Temperature Drift - Calibrated for 100 Counts of Delta</span></p>
</div>
<p>As can be seen from the plots, the max offset calibration algorithm achieves the same sensitivity to touch (50 counts or 100 counts) as the standard algorithm, but with a shorter measurement time (fewer charge transfers). This reduced measurement time enables faster scan rates or lower power consumption. For equivalent scan times, the max offset calibration algorithm provides higher sensitivity to touch.</p>
<p>Temperature drift in both cases is compensated for by the software library during operation. If needed, a re-calibration may take place at run-time to maintain a desired sensitivity and scan time range. The plot below shows how the library behaves when tracking temperature drift, using the standard calibration algorithm and the max offset calibration algorithm. For details on how the library compensates for temperature drift, see <a class="reference external" href="ch_library.html#environmental-drift-algorithms">Environmental Drift Algorithms</a> in the base module documentation.</p>
<div class="figure" id="id44">
<img alt="Temperature Drift - Calibrated for 50 Counts of Delta w/ Software Library Tracking" src="../_images/tempdrift_cal_50_lib.png" />
<p class="caption"><span class="caption-number">Fig. 196 </span><span class="caption-text">Temperature Drift - Calibrated for 50 Counts of Delta w/ Software Library Tracking</span></p>
</div>
<p>As can be seen from the plot above, the runtime re-calibration algorithm re-established the tuning parameters during the temperature sweep to maintain consistent sensitivity. In the standard calibration case, re-calibration was only needed one time. In the max offset case, it was needed several times.</p>
</div>
</div>
</div>
<div class="section" id="manager">
<h3>Manager<a class="headerlink" href="#manager" title="Permalink to this headline">¶</a></h3>
<p>The manager provides the top level API for the library. For details on how to use the top level API, see the <a class="reference external" href="ch_library.html#use-th-top-level-api">How to Use the Top Level API</a> section.</p>
</div>
<div class="section" id="buttons">
<h3>Buttons<a class="headerlink" href="#buttons" title="Permalink to this headline">¶</a></h3>
<p>The buttons processing plug-in is a dominant element computation. The dominant element computation compares the delta response from all elements within the sensor. The element with the highest delta response is reported as the dominant element. For details on how to use the dominant element feature, see the <a class="reference external" href="ch_library.html#access-the-dominant-button">How to Access the Dominant Button</a> section.</p>
</div>
<div class="section" id="sliders-and-wheels">
<h3>Sliders and Wheels<a class="headerlink" href="#sliders-and-wheels" title="Permalink to this headline">¶</a></h3>
<p>The slider processing plug-in provides a vector position computation to determine the location of a touch over a 1-dimensional array of elements. The same vector math is utilized for processing slider and wheel sensors. The slider is really just a special case of a wheel where the endpoints are disconnected.</p>
<div class="section" id="supported-sizes">
<h4>Supported Sizes<a class="headerlink" href="#supported-sizes" title="Permalink to this headline">¶</a></h4>
<p>A slider or wheel sensor must be composed of at least 3 elements, but no more than 12 elements.</p>
</div>
<div class="section" id="supported-resolution">
<h4>Supported Resolution<a class="headerlink" href="#supported-resolution" title="Permalink to this headline">¶</a></h4>
<p>The algorithm allows for up to 16 bits of resolution, although 5-10 bits is the typical use-case. Measurement results will be reported back from 0 to resolution-1.</p>
</div>
<div class="section" id="slider-endpoint-trim">
<h4>Slider Endpoint Trim<a class="headerlink" href="#slider-endpoint-trim" title="Permalink to this headline">¶</a></h4>
<p>The slider algorithm allows for &#8220;endpoint trim&#8221; to ensure that the beginning position is true 0 and the end position is the resolution-1. For details on how the endpoint trim works, see the <a class="reference external" href="ch_glossary.html#slider-trim">trim help section</a>.</p>
</div>
</div>
<div class="section" id="emc">
<h3>EMC<a class="headerlink" href="#emc" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate™ Software Library includes an EMC module in the advanced module. This module provides processing plug-ins to the touch layer to enhance robustness in the presence of noise. This section discusses how to configure that module. For a detailed noise immunity design guide, visit the <a class="reference external" href="ch_design_guide.html#noise-immunity">noise immunity</a> section of the design chapter.</p>
<div class="section" id="emc-module-background">
<h4>EMC Module Background<a class="headerlink" href="#emc-module-background" title="Permalink to this headline">¶</a></h4>
<p>While the CapTIvate™ peripheral provides a significant feature set for dealing with electromagnetic compatibility issues on its own, some amount of digital signal processing is still required to process the raw data into usable values. The EMC module in the CapTIvate™ Software Library fills that need by providing configurable algorithms to the base touch layer of the software library. It is not necessary to call EMC processing functions directly; rather, they are automatically called by the touch layer. The various EMC features are enabled, disabled, and configured via an EMC configuration structure.</p>
<p>The EMC module provides the following feature set:</p>
<ol class="arabic simple">
<li><strong>Multi Frequency Processing (MFP) Algorithm</strong> for resolving a raw measurement set of 4 frequencies into a single, usable measurement result</li>
<li><strong>Multi Frequency Calibration Algorithm</strong> for ensuring that accurate, usable calibration values are obtained during the sensor calibration process, even in a noisy environment</li>
<li><strong>Oversampling (Averaging) Filter</strong> to improve SNR</li>
<li><strong>Jitter Filter</strong> to remove small 1-count glitches</li>
<li><strong>Global Relative Noise Level Tracking</strong> to keep a global value of the noise level observed on all self-capacitance elements in the system for use in dynamic threshold adjustment</li>
<li><strong>Dynamic Threshold Adjustment (DTA) Algorithm</strong> for calculating a threshold adjustment factor to compensate for increased sensitivity of self-capacitance sensors in the presence of noise</li>
</ol>
</div>
<div class="section" id="using-the-emc-module">
<h4>Using the EMC Module<a class="headerlink" href="#using-the-emc-module" title="Permalink to this headline">¶</a></h4>
<p>When using the CapTIvate™ Software Library, the EMC module functions are not called by the application. Rather, noise immunity is enabled for a user configuration at a top level. When noise immunity is enabled in the library for a design, the top level library functions for calibration and sensor measurement are replaced with EMC versions of the same functions.</p>
<div class="section" id="enabling-noise-immunity-emc-features">
<h5>Enabling Noise Immunity (EMC) Features<a class="headerlink" href="#enabling-noise-immunity-emc-features" title="Permalink to this headline">¶</a></h5>
<p>It is best to enable noise immunity via the CapTIvate™ Design Center. The controller customizer has a compile-time option for <a class="reference external" href="ch_designcenter.html#device-configuration">noise immunity</a>. Selecting this option sets the <strong>CAPT_CONDUCTED_NOISE_IMMUNITY_ENABLE</strong> compile-time definition in the CAPT_UserConfig.h file to <strong>true</strong> when source code is generated.</p>
</div>
<div class="section" id="function-replacements-with-noise-immunity-enabled">
<h5>Function Replacements with Noise Immunity Enabled<a class="headerlink" href="#function-replacements-with-noise-immunity-enabled" title="Permalink to this headline">¶</a></h5>
<p>When the compile-time option is set, the manager layer will make calls to EMC versions of functions rather than the standard versions. Below is a mapping of which functions are replaced:</p>
<p>Top Level Functions</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="33%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Standard Function</th>
<th class="head">EMC Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Calibrate a Sensor</td>
<td>CAPT_calibrateSensor()</td>
<td>CAPT_calibrateSensorWithEMC()</td>
</tr>
<tr class="row-odd"><td>Update a Sensor</td>
<td>CAPT_updateSensor()</td>
<td>CAPT_updateSensorWithEMC()</td>
</tr>
</tbody>
</table>
<p>These top level functions are called by the application via abstractions in CAPT_Manager.</p>
<p>Supporting Functions</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="25%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Standard Function</th>
<th class="head">EMC Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Process a Cycle</td>
<td>CAPT_processFSMCycle()</td>
<td>CAPT_processCycleWithEMC()</td>
</tr>
<tr class="row-odd"><td>Update Prox/Touch Status</td>
<td>CAPT_updateProx, CAPT_updateTouch</td>
<td>CAPT_updateSelfElementProxTouchWithEMC(), CAPT_updateProjElementProxTouchWithEMC()</td>
</tr>
</tbody>
</table>
<p>These functions are called inside the touch layer, and are not directly called by the application.</p>
</div>
<div class="section" id="emc-module-configuration">
<h5>EMC Module Configuration<a class="headerlink" href="#emc-module-configuration" title="Permalink to this headline">¶</a></h5>
<p>The EMC Module is configured through the tEMCConfig structure. The EMC layer only reads from this structure, so the configuration may be kept in non-volatile read-only memory if desired. A default configuration is provided in the user configuration file, and is shown below:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">tEMCConfig</span> <span class="n">g_EMCConfig</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Conversion</span> <span class="n">Style</span>
    <span class="o">.</span><span class="n">selfModeConversionStyle</span> <span class="o">=</span> <span class="n">eMultiFrequency</span><span class="p">,</span>
    <span class="o">.</span><span class="n">projModeConversionStyle</span> <span class="o">=</span> <span class="n">eMultiFrequencyWithOutlierRemoval</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">Oversampling</span> <span class="n">Style</span>
    <span class="o">.</span><span class="n">selfModeOversamplingStyle</span> <span class="o">=</span> <span class="n">eNoOversampling</span><span class="p">,</span>
    <span class="o">.</span><span class="n">projModeOversamplingStyle</span> <span class="o">=</span> <span class="n">eNoOversampling</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">Jitter</span> <span class="n">Filter</span> <span class="n">Enable</span>
    <span class="o">.</span><span class="n">bJitterFilterEnable</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">Noise</span> <span class="n">Thresholds</span> <span class="ow">and</span> <span class="n">Calibration</span> <span class="n">Noise</span> <span class="n">Limits</span>
    <span class="o">.</span><span class="n">ui8NoiseThreshold</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui16CalibrationNoiseLimit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8CalibrationTestSampleSize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>

    <span class="o">//</span> <span class="n">Dynamic</span> <span class="n">Threshold</span> <span class="n">Adjustment</span> <span class="n">Parameters</span>
    <span class="o">.</span><span class="n">bEnableDynamicThresholdAdjustment</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8MaxRelThreshAdj</span> <span class="o">=</span> <span class="mi">76</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8NoiseLevelFilterEntryThresh</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8NoiseLevelFilterExitThresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8NoiseLevelFilterDown</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui8NoiseLevelFilterUp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">coeffA</span> <span class="o">=</span> <span class="n">_IQ31</span><span class="p">(</span><span class="mf">0.0065</span><span class="p">),</span>
    <span class="o">.</span><span class="n">coeffB</span> <span class="o">=</span> <span class="n">_IQ31</span><span class="p">(</span><span class="mf">0.050</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The default values were selected by bench characterization and have proven effective for several different sensing panels. However, for certain applications and/or certain noise environments, it may be necessary to adjust some of the parameters. To implement a custom configuration, simply create a new tEMCConfig structure with the desired values, and pass it&#8217;s address to CAPT_loadEMCConfig() when the application is initialized at start-up. Note that the CapTIvate™ starter project makes this call in CAPT_appStart() just before CAPT_calibrateUI().</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">CAPT_loadEMCConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_EMCConfig</span><span class="p">);</span>
</pre></div>
</div>
<p>The configuration parameters can be grouped into 5 different categories:</p>
<ul class="simple">
<li>Conversion Style Control</li>
<li>Oversampling Style Control</li>
<li>Jitter Filter Control</li>
<li>Noise Thresholds and Calibration Noise Limits</li>
<li>Dynamic Threshold Adjustment Parameters</li>
</ul>
<p>Each group will be discussed in detail below.</p>
</div>
<div class="section" id="conversion-style-control">
<h5>Conversion Style Control<a class="headerlink" href="#conversion-style-control" title="Permalink to this headline">¶</a></h5>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Conversion</span> <span class="n">Style</span>
<span class="o">.</span><span class="n">selfModeConversionStyle</span> <span class="o">=</span> <span class="n">eMultiFrequency</span><span class="p">,</span>
<span class="o">.</span><span class="n">projModeConversionStyle</span> <span class="o">=</span> <span class="n">eMultiFrequencyWithOutlierRemoval</span><span class="p">,</span>
</pre></div>
</div>
<p>The conversion style control influences the type of conversion used by EMC sensor update functions. Conversion style is specified separately for self and mutual capacitance sensors, enabling different algorithms to be applied to designs that have both self and mutual sensors. There are three possible conversion styles:</p>
<ul class="simple">
<li><strong>Standard conversion</strong>, in which each time cycle is measured once.</li>
<li><strong>Multi-frequency conversion</strong>, in which each time cycle is measured at 4 frequencies and the composite result is the average of the 4 frequencies</li>
<li><strong>Multi-frequency conversion with outlier removal</strong>, in which each time cycle is measured at 4 frequencies and the composite result is the average of the 4 frequencies after the largest outlier is removed from the data set.</li>
</ul>
<p>Conversion style is a data type that may be passed to the <strong>CAPT_updateSensorRawCount()</strong> function, which is what the EMC sensor update functions use to measure sensors. The enumeration options are shown below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Option</th>
<th class="head">tRawConversionStyle Enumeration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Standard</td>
<td>eStandard</td>
</tr>
<tr class="row-odd"><td>Multi-Frequency</td>
<td>eMultiFrequency</td>
</tr>
<tr class="row-even"><td>Multi-Frequency with Outlier Removal</td>
<td>eMultiFrequencyWithOutlierRemoval</td>
</tr>
<tr class="row-odd"><td>Multi-Frequency with Outlier Removal and Error Correction</td>
<td>eMultiFrequencyWithOutlierRemovalAndErrCorrection</td>
</tr>
</tbody>
</table>
<p>For mutual (projected) capacitance sensors, the recommended style is multi-frequency with outlier removal and error correction. The narrow-band susceptibility of mutual capacitance sensors suites them well to this approach. If noise exists at one of the conversion frequencies, that outlying sample is removed and the composite result is re-calculated with the remaining values. Error correction means that samples that do not converge before the max count threshold is crossed are processed as if they ended at the max count threshold, rather than being processed with a value of zero.</p>
<p>For self-capacitance sensors, the recommended style is multi-frequency. A multi-frequency conversion provides 4 data points from which a spread can be calculated and use as a noise level reference. That reference can then be used as an input to the dynamic threshold adjustment algorithm.</p>
</div>
<div class="section" id="oversampling-style-control">
<h5>Oversampling Style Control<a class="headerlink" href="#oversampling-style-control" title="Permalink to this headline">¶</a></h5>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Oversampling</span> <span class="n">Style</span>
<span class="o">.</span><span class="n">selfModeOversamplingStyle</span> <span class="o">=</span> <span class="n">eNoOversampling</span><span class="p">,</span>
<span class="o">.</span><span class="n">projModeOversamplingStyle</span> <span class="o">=</span> <span class="n">eNoOversampling</span><span class="p">,</span>
</pre></div>
</div>
<p>The oversampling style control allows for the addition of oversampling in binary steps to a conversion. Oversampling style is a data type that may be passed to the <strong>CAPT_updateSensorRawCount()</strong> function, which is what the EMC sensor update functions use to measure sensors.</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Option</th>
<th class="head">tOversamplingStyle Enumeration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>No Oversampling</td>
<td>eNoOversampling</td>
</tr>
<tr class="row-odd"><td>Double</td>
<td>e2xOversampling</td>
</tr>
<tr class="row-even"><td>Quadruple</td>
<td>e4xOversampling</td>
</tr>
<tr class="row-odd"><td>8x</td>
<td>e8xOversampling</td>
</tr>
<tr class="row-even"><td>16x</td>
<td>e16xOversampling</td>
</tr>
<tr class="row-odd"><td>32x</td>
<td>e32xOversampling</td>
</tr>
</tbody>
</table>
<p>When no oversampling is applied, each time cycle is sampled once and that value is used as the conversion result. When a level of oversampling is applied, each time cycle is sampled to the level of oversampling, and the results are averaged. This enables a basic averaging filter that helps with transient noise rejection.</p>
<p>Note that this oversampling is in addition to the multi-frequency scanning. For example, a mutual capacitance sensor with a multi-frequency conversion style and a 4x oversampling style is actually measured 16 times per update- 4 frequencies per sample, and a 4x oversample.</p>
<p>For designs that have a smaller number of buttons, more oversampling can be applied, which improves the overall SNR. Oversampling style is specified separately for self and mutual capacitance sensors.</p>
</div>
<div class="section" id="jitter-filter-control">
<h5>Jitter Filter Control<a class="headerlink" href="#jitter-filter-control" title="Permalink to this headline">¶</a></h5>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Jitter</span> <span class="n">Filter</span> <span class="n">Enable</span>
<span class="o">.</span><span class="n">bJitterFilterEnable</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
</pre></div>
</div>
<p>A basic 1-level jitter filter may be applied when sensors are updated with EMC features enabled. The jitter filter has a simple control (on or off). The filter looks at each new sample and determines if it is greater or less than the previous sample. If it is greater, the new sample is decremented by a value of 1. if it is less, the new sample is incremented by 1. This reduces low-level jitter in measurements, improving SNR. It is recommended that the jitter filter be enabled in most applications.</p>
</div>
<div class="section" id="noise-level-thresholds-and-calibration-noise-limits">
<h5>Noise Level Thresholds and Calibration Noise Limits<a class="headerlink" href="#noise-level-thresholds-and-calibration-noise-limits" title="Permalink to this headline">¶</a></h5>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Noise</span> <span class="n">Thresholds</span> <span class="ow">and</span> <span class="n">Calibration</span> <span class="n">Noise</span> <span class="n">Limits</span>
<span class="o">.</span><span class="n">ui8NoiseThreshold</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
<span class="o">.</span><span class="n">ui16CalibrationNoiseLimit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
<span class="o">.</span><span class="n">ui8CalibrationTestSampleSize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
</pre></div>
</div>
<p>These parameters primarily exist to enable alerting of the application to the fact that the amount of noise observed in the system is greater than a specified amount. In addition, they aid in calibration if noise is present during a calibration.</p>
<p>Noise Threshold</p>
<p>The <em>ui8NoiseThreshold</em> parameter specifies the relative noise level beyond which an element&#8217;s noise detected status flag should be set. This provides a mechanism to alert the application that there is a certain amount of noise present in the measurement. The parameter is specified is a <em>relative</em> value, not an absolute value. The value is defined as a percentage of the long term average (LTA), in which 0=0% and 128=100%. The absolute noise threshold would be calculated as the relative threshold multiplied by the LTA and divided by 128, as shown below.</p>
<div class="figure" id="id45">
<img alt="Relative/Absolute Noise Threshold Conversion" src="../_images/lib_advanced_rel_to_abs.png" />
<p class="caption"><span class="caption-number">Fig. 197 </span><span class="caption-text">Relative/Absolute Noise Threshold Conversion</span></p>
</div>
<p>Relative thresholds are used here so that they can be applied to an application that may have many sensors with different conversion count settings.</p>
<p>Note that this noise threshold only serves the purpose of setting the noise detected flag- it does not impact the processing of the library in any way.</p>
<p>Calibration in Noisy Environments</p>
<p>The <em>ui16CalibrationNoiseLimit</em> and <em>ui8CalibrationTestSampleSize</em> parameters are used to test the results of the calibration process when multi-frequency scanning is enabled. If the MCU powers up in an environment with noise at one of the conversion frequencies, it is possible that the calibration algorithm may produce invalid calibration values at that frequency. To determine if a calibration value may be corrupt, after the calibration process is complete each element is sampled <em>ui8CalibrationTestSampleSize</em> times. Out of that sample set, the peak-to-peak difference at each frequency in the set is compared with the <em>ui16CalibrationNoiseLimit</em>. If the peak-to-peak variation of the measurement results at a given conversion frequency is greater than the <em>ui16CalibrationNoiseLimit</em> parameter, that frequency&#8217;s calibration values are marked as invalid. When this happens, they are replaced with the calibration values of the nearest valid conversion frequency.</p>
<p>There are 3 possible outcomes from the multi-frequency calibration test:</p>
<ol class="arabic simple">
<li>All 4 conversion frequencies provided data that was noise-free. Thus, they retain their original calibration values.</li>
<li>1 to 3 conversion frequencies provided data that was noisy. the noisy frequencies have their calibration values replaced with the values from the nearest conversion frequency with valid, noise-free data.</li>
<li>All 4 conversion frequencies provided data that was noisy. In this scenario, there is no way to determine if the calibration values are valid or not. To alert the application, the sensor&#8217;s <em>bCalibrationError</em> status flag and <em>bSensorNoiseState</em> status flag are set. Applications should test these flags after the calibration process to determine if a usable calibration solution was obtained. If a valid calibration solution was not obtained, the application should stall and re-attempt the calibration process until a valid calibration is obtained.</li>
</ol>
</div>
<div class="section" id="dynamic-threshold-adjustment-parameters">
<h5>Dynamic Threshold Adjustment Parameters<a class="headerlink" href="#dynamic-threshold-adjustment-parameters" title="Permalink to this headline">¶</a></h5>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Dynamic</span> <span class="n">Threshold</span> <span class="n">Adjustment</span> <span class="n">Parameters</span>
<span class="o">.</span><span class="n">bEnableDynamicThresholdAdjustment</span> <span class="o">=</span> <span class="n">true</span><span class="p">,</span>
<span class="o">.</span><span class="n">ui8MaxRelThreshAdj</span> <span class="o">=</span> <span class="mi">76</span><span class="p">,</span>
<span class="o">.</span><span class="n">ui8NoiseLevelFilterEntryThresh</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
<span class="o">.</span><span class="n">ui8NoiseLevelFilterExitThresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="o">.</span><span class="n">ui8NoiseLevelFilterDown</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="o">.</span><span class="n">ui8NoiseLevelFilterUp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="o">.</span><span class="n">coeffA</span> <span class="o">=</span> <span class="n">_IQ31</span><span class="p">(</span><span class="mf">0.0065</span><span class="p">),</span>
<span class="o">.</span><span class="n">coeffB</span> <span class="o">=</span> <span class="n">_IQ31</span><span class="p">(</span><span class="mf">0.050</span><span class="p">)</span>
</pre></div>
</div>
<p>The dynamic threshold adjustment (DTA) parameters enable and configure the DTA algorithm. The parameters are introduced below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="77%" />
<col width="5%" />
<col width="5%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Member</th>
<th class="head">Description</th>
<th class="head">Default Value</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>bEnableDynamicThresholdAdjustment</td>
<td>Enable or disable dynamic threshold adjustment. Note that dynamic threshold adjustment only applies to self capacitance sensors in either case.</td>
<td>true</td>
<td>true, false</td>
</tr>
<tr class="row-odd"><td>ui8NoiseLevelFilterEntryThresh</td>
<td>If the noise level is increasing (low to high vector) and the new noise sample is below this value, the global and local value filters will be disabled to allow for rapid tracking. A value of &#8216;0&#8217; keeps the filters enabled at all times.</td>
<td>32</td>
<td>0-128</td>
</tr>
<tr class="row-even"><td>ui8NoiseLevelFilterExitThresh</td>
<td>If the noise level is decreasing (high to low vector) and the new noise sample is below this value, the global and local value filters will be disabled to allow for rapid tracking. A value of &#8216;0&#8217; keeps the filters enabled at all times.</td>
<td>0</td>
<td>0-128</td>
</tr>
<tr class="row-odd"><td>ui8NoiseLevelFilterDown</td>
<td>The filter beta applied to the global filtered noise value when the new noise sample is lower than the filtered noise value.</td>
<td>5</td>
<td>0-15</td>
</tr>
<tr class="row-even"><td>ui8NoiseLevelFilterUp</td>
<td>The filter beta applied to the global filtered noise value when the new noise sample is higher than the filtered noise value.</td>
<td>1</td>
<td>0-15</td>
</tr>
<tr class="row-odd"><td>coeffA</td>
<td>The &#8216;A&#8217; coefficient in the dynamic threshold adjustment algorithm calculation.</td>
<td>0.0065</td>
<td>0-0.999999999</td>
</tr>
<tr class="row-even"><td>coeffB</td>
<td>The &#8216;B&#8217; coefficient in the dynamic threshold adjustment algorithm calculation.</td>
<td>0.0100</td>
<td>0-0.999999999</td>
</tr>
</tbody>
</table>
<p>The <em>bEnableDynamicThresholdAdjustment</em> parameter enables and disables the DTA algorithm. The DTA algorithm only applies to self capacitance sensors. See the <a class="reference external" href="ch_library.html#dynamic-threshold-adjustment-dta-algorithm">DTA</a> section for an overview of how the DTA algorithm works.</p>
</div>
</div>
<div class="section" id="emc-module-algorithms">
<h4>EMC Module Algorithms<a class="headerlink" href="#emc-module-algorithms" title="Permalink to this headline">¶</a></h4>
<div class="section" id="multi-frequency-processing-mfp-algorithm">
<h5>Multi Frequency Processing (MFP) Algorithm<a class="headerlink" href="#multi-frequency-processing-mfp-algorithm" title="Permalink to this headline">¶</a></h5>
<p>The multi frequency processing algorithm is implemented in the <strong>CAPT_resolveMultiFreqSet()</strong> function. When noise immunity is enabled, each element is measured at four different conversion frequencies to gather more data in the presence of noise. The algorithm is then applied to the four raw measurements. The output of the algorithm is a single, composite measurement and a noise level. The composite measurement is then used by the higher levels of the library just like a raw sample normally would. The noise level is used to update each element&#8217;s filtered noise level.</p>
</div>
<div class="section" id="dynamic-threshold-adjustment-dta-algorithm">
<h5>Dynamic Threshold Adjustment (DTA) Algorithm<a class="headerlink" href="#dynamic-threshold-adjustment-dta-algorithm" title="Permalink to this headline">¶</a></h5>
<p>The dynamic threshold adjustment (DTA) algorithm is implemented in the <strong>CAPT_computeRelativeNoiseComp()</strong> function. The algorithm calculates threshold adjustments based on the amount of noise seen in a history of measurements. It relies on a filtered relative noise value as an input, and it calculates the corresponding threshold adjustment to be applied for proximity and touch detection. The threshold adjustment is calculated based on a polynomial model as shown below, where &#8216;x&#8217; is the relative noise value and &#8216;y&#8217; is the corresponding relative threshold adjustment. The polynomial allows for greater adjustment at higher noise levels.</p>
<div class="figure" id="id46">
<img alt="DTA Formula" src="../_images/lib_dta_formula.png" />
<p class="caption"><span class="caption-number">Fig. 198 </span><span class="caption-text">DTA Formula</span></p>
</div>
<p>This formula with the default values provides the adjustment curve shown below. A linear (A=0; B=0.5) curve is also shown for reference.</p>
<div class="figure" id="id47">
<img alt="DTA Default Value Response Curve" src="../_images/lib_dta_formula_plot.png" />
<p class="caption"><span class="caption-number">Fig. 199 </span><span class="caption-text">DTA Default Value Response Curve</span></p>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="communications-module">
<h2>Communications Module<a class="headerlink" href="#communications-module" title="Permalink to this headline">¶</a></h2>
<p>The CapTIvate™ Touch Library includes a communications module for connecting CapTIvate™ MCUs to the outside world. This section discusses the architecture, features, and specification for that communications module, as well as how it may be used in a variety of applications from development to production.</p>
<p>This section assumes that the reader is familiar with the following:</p>
<ul class="simple">
<li>Capacitive sensing as a user interface technology</li>
<li>The Captivate ecosystem and touch library</li>
<li>Basic MSP microcontroller architecture</li>
</ul>
<div class="section" id="background">
<h3>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h3>
<p>Designing a capacitive touch interface is an iterative process. Every sensor in the system must be individually tuned and optimized to achieve the desired sensitivity and &#8220;feel.&#8221; Having the ability to communicate in real-time between a PC GUI and the target MCU drastically reduces the amount of time needed to tune an interface, and can provide better tuning results as the features incorporated into the CapTIvate™ peripheral can quickly and easily be exercised to determine the best configuration.</p>
<p>Following the design and tuning phase, a capacitive touch microcontroller takes on one of two roles in a system. It may be a dedicated human-machine interface (HMI) that only serves to resolve a capacitive touch panel into usable information (like touch/no touch, or a slider position), or it may double as a host processor, integrating other functionality such as monitoring sensors or controlling other functions in the system. In the first case (the dedicated HMI case), the controller will almost always require a way to communicate the status of the interface to some other host, which may be another MCU or an MPU. This interface could be as simple as a GPIO that gets set when a button is pressed, or as complex as a full I2C protocol with addressable parameters.</p>
</div>
<div class="section" id="id7">
<h3>Overview<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate™ Software Library communications module provides a single solution to the two needs above. The communications module is a layered set of firmware with a simple top-level API, designed to link a CapTIvate™ MCU to the CapTIvate™ Design Center PC GUI or to a host processor of some kind via a standard, common serial interface.</p>
<p>In a capacitive touch application the MCU is responsible for measuring capacitive sensors, processing the measurement to interpret some kind of result, and transmitting that result either to the application locally or to a host processor. The communications layer provides the &#8220;transmission&#8221; part of the equation. The diagram below portrays how the communications module fits in with the rest of the firmware in a typical CapTIvate™ application.</p>
<p>The CapTIvate™ communications module is layered and contains several standalone features that are interlinked together. These features are introduced below. To use the communications module, it is only necessary to set up the configuration file and call the top-level APIs.</p>
<div class="section" id="layers">
<h4>Layers<a class="headerlink" href="#layers" title="Permalink to this headline">¶</a></h4>
<p>The communications module contains 4 layers. In order of decreasing abstraction, they are:</p>
<ul class="simple">
<li><a class="reference external" href="ch_library.html#interface-layer">Interface Layer</a> [COMM/CAPT_Interface.c/.h]<ul>
<li>The interface layer implements the top-level API.</li>
</ul>
</li>
<li><a class="reference external" href="ch_library.html#protocol-layer">Protocol Layer</a> [COMM/CAPT_Protocol.c/.h]<ul>
<li>The protocol layer implements Captivate protocol packet generation and packet interpretation.</li>
</ul>
</li>
<li>Serial Driver Layer [COMM/Serial_Drivers/*.c/.h]<ul>
<li>The serial driver layer contains several interchangeable serial driver options.</li>
<li>One and only one option may be selected at any given time.</li>
<li>Selection and configuration is handled in the configuration file.</li>
<li>The serial drivers are built on top of the MSP430 DriverLib API.</li>
<li><a class="reference external" href="ch_library.html#uart-driver">UART</a> and <a class="reference external" href="ch_library.html#i2c-slave-driver">I2C Slave</a> drivers are provided.</li>
</ul>
</li>
<li>Data Structure Layer [COMM/CAPT_ByteQueue.c/.h, COMM/CAPT_PingPongBuffer.c/.h]<ul>
<li>The data structure layer implements basic abstract data types, such as a FIFO queue and a ping pong buffer to aid serial communication.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="operating-modes">
<h4>Operating Modes<a class="headerlink" href="#operating-modes" title="Permalink to this headline">¶</a></h4>
<p>The communications module is designed to operate in one of three different modes. These modes are described below. When using the CapTIvate Software Library, the communications mode is selected by the compile time definition <em>CAPT_INTERFACE</em>, which is introduced in the interface layer documentation. The selection may be made in the CapTIvate Design Center when setting up a project, as shown below.</p>
<div class="figure" id="id48">
<img alt="Communication Interface Selection in CapTIvate Design Center" src="../_images/CAPT_INTERFACE__Select.png" />
<p class="caption"><span class="caption-number">Fig. 200 </span><span class="caption-text">Communication Interface Selection in CapTIvate Design Center</span></p>
</div>
<div class="section" id="none">
<h5>NONE<a class="headerlink" href="#none" title="Permalink to this headline">¶</a></h5>
<p>When &#8216;NONE&#8217; is selected, the communications interface is compiled out of the working project.</p>
</div>
<div class="section" id="uart-and-bulk-i2c">
<h5>UART and BULK I2C<a class="headerlink" href="#uart-and-bulk-i2c" title="Permalink to this headline">¶</a></h5>
<p>These modes are intended to be used during development with the CapTIvate Design Center. When &#8216;UART&#8217; is selected, the communications interface streams sensor and element packets (if enabled) out via the UART or I2C serial interface. It also accepts incoming parameter packets. UART and I2C are provided to give multiple connectivity options if a serial interface is needed elsewhere in the system. These modes are designed to work with the <a class="reference external" href="ch_evm.html#captivate-pgmr-programmer-pcb-overview">CAPTIVATE-PGMR</a> module when communicating with the CapTIvate Design Center. They may be re-purposed for communicating with a host processor in an end application, but this is not their intended usage. For communicating with a host processor, the recommended mode is REGISTER_I2C.</p>
</div>
<div class="section" id="register-i2c">
<h5>REGISTER_I2C<a class="headerlink" href="#register-i2c" title="Permalink to this headline">¶</a></h5>
<p>REGISTER_I2C mode is intended to be used for communicating with a host processor in system. It does not support communication with the CapTIvate Design Center. This mode provides a simple, register-like I2C interface that a host processor may poll to read out only the specific CapTIvate sensor and element information that it requires. For details on how to use REGISTER_I2C mode for communicating with host processor, see the <a class="reference external" href="ch_library.html#host-processor-communication">Host Processor Communication</a> section of this guide.</p>
</div>
</div>
</div>
<div class="section" id="host-processor-communication">
<h3>Host Processor Communication<a class="headerlink" href="#host-processor-communication" title="Permalink to this headline">¶</a></h3>
<p>The REGISTER_I2C mode exists to enable the easy connection of a CapTIvate MCU to a host processor or host MCU via an asynchronous I2C connection, where the host may query the status of a sensor whenever it would like to. This section is a how-to guide that discusses how to take advantage of that register I2C feature in the CapTIvate Software Library to connect a CapTIvate touch interface to a host processor.</p>
<div class="section" id="tutorial">
<h4>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h4>
<p>This guide will step through how to set up a CapTIvate project for REGISTER_I2C mode, and will show how to read packets from an example host processor. The example host is an MSP-EXP430FR2311LauchPad. The example target is the CAPTIVATE-FR2633 MCU module with the CAPTIVATE-BSWP evaluation panel, featuring buttons, sliders, wheels, and proximity.</p>
<p>This workshop assumes that you already have a CapTIvate Design Center project for your design, and that the sensors in your design have been tuned. If this has not been done, review the CapTIvate Workshop before going through this tutorial.</p>
<div class="section" id="setting-up-the-captivate-target-mcu">
<h5>Setting Up the CapTIvate Target MCU<a class="headerlink" href="#setting-up-the-captivate-target-mcu" title="Permalink to this headline">¶</a></h5>
<p><strong>Step 1</strong></p>
<p>To enable REGISTER_I2C communication, open the CapTIvate Design Center Controller Customizer (the MCU icon on the canvas) by double-clicking it. Then, select “REGISTER_I2C” as the communication interface.</p>
<div class="figure" id="id49">
<img alt="Register I2C Selection" src="../_images/REGI2C_CDCSelection.png" />
<p class="caption"><span class="caption-number">Fig. 201 </span><span class="caption-text">Register I2C Selection</span></p>
</div>
<div class="figure" id="id50">
<img alt="Register I2C Selection - Zoom" src="../_images/REGI2C_CDCSelection_Zoom.png" />
<p class="caption"><span class="caption-number">Fig. 202 </span><span class="caption-text">Register I2C Selection - Zoom</span></p>
</div>
<p><strong>Step 2</strong></p>
<p>Update your source code project to include this change by selecting Generate Source Code in the Controller Customizer, and browsing to your CCS project root directory.</p>
<p><strong>Step 3</strong></p>
<p>Re-build your CCS project containing the update. If you would like to see the source code that changed with this modification, view line 81 of CAPT_UserConfig.h (see below).</p>
<div class="figure" id="id51">
<img alt="REGISTER\_I2C Selection in CAPT\_UserConfig.h" src="../_images/REGI2C_ConfigHeader.png" />
<p class="caption"><span class="caption-number">Fig. 203 </span><span class="caption-text">REGISTER_I2C Selection in CAPT_UserConfig.h</span></p>
</div>
<p><strong>Step 4</strong></p>
<p>Re-program the CapTIvate target MCU with the update. Terminate any debug sessions.</p>
<p><strong>DONE!</strong> The target code configuration required to set up for REGISTERI2C access is now complete. The CapTIvate Software Library will take care of everything else.</p>
</div>
<div class="section" id="making-i2c-connections">
<h5>Making I2C Connections<a class="headerlink" href="#making-i2c-connections" title="Permalink to this headline">¶</a></h5>
<p>In this example, an MSP430FR2311 LaunchPad will act as a host processor. It will be the I2C master. The CapTIvate MCU will be an I2C slave, serving up responses to packet requests from the master.</p>
<p>To connect the MSP-EXP430FR2311 LaunchPad (or any other host processor) to the CAPTIVATE-FR2633 MCU module, simply connect the I2C bus pins between the two devices, as well as a ground connection. On both devices, SDA is P1.2 and SCL is P1.3. For this example, the MSP-EXP430FR2311 host LaunchPad is used to power the CAPTIVATE-FR2633 module as well. For this reason, 4 connections are made between the two boards as shown below. The P1.2, P1.3, and 3.3V LDO jumpers on the CAPTIVATE-FR2633 module are left in place to keep the onboard pullup resistors intact for SDA and SCL.</p>
<div class="figure" id="id52">
<img alt="REGISTER\_I2C Selection in CAPT\_UserConfig.h" src="../_images/REGI2C_Wiring.png" />
<p class="caption"><span class="caption-number">Fig. 204 </span><span class="caption-text">REGISTER_I2C Selection in CAPT_UserConfig.h</span></p>
</div>
</div>
<div class="section" id="starting-register-i2c-communication">
<h5>Starting REGISTER_I2C Communication<a class="headerlink" href="#starting-register-i2c-communication" title="Permalink to this headline">¶</a></h5>
<p>The MSP43FR2311 is acting as the host processor in this example. It can be programmed with MSP Driver Library software and the I2C Master driver used in CapTIvate examples for controlling the DRV26xx haptic actuators. A basic loop may be constructed as shown below to read data from the CapTIvate target device.</p>
<p>The I2C master driver calls shown here should be easy to translate to whichever host driver is being used in an end application. The I2CTOOLS utility on an embedded Linux host may be used in a similar fashion to perform writes to and reads from the I2C bus.</p>
<p>In this basic example, the sensor packet for sensor 0x00 was read. The first bit of the 6th (final) byte of the received data is used to turn on and of P1.0 on the MSP-EXP430FR2311 LaunchPad, which controls an LED. That bit in the received data corresponds to the global touch flag for the sensor with ID 0x00. This means that any touch on sensor 0 will cause the LED to illuminate. Sensor ID 0x00 corresponds to the button group sensor when using the CAPTIVATE-BSWP demo.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">loop</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="n">uint8_t</span> <span class="n">tx</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="n">static</span> <span class="n">uint8_t</span> <span class="n">rx</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">capture</span><span class="o">==</span><span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>

        <span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
        <span class="n">tx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
        <span class="n">I2CMaster_writeBuffer</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">I2CMaster_readBuffer</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">6</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BIT0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">P1OUT</span> <span class="o">|=</span> <span class="n">BIT0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">P1OUT</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The resulting logic trace from the I2C transaction may be seen below.</p>
<div class="figure" id="id53">
<img alt="REGISTER\_I2C Logic Trace" src="../_images/REGI2C_logic1.png" />
<p class="caption"><span class="caption-number">Fig. 205 </span><span class="caption-text">REGISTER_I2C Logic Trace</span></p>
</div>
<p>The I2C decoding is below:</p>
<div class="figure" id="id54">
<img alt="REGISTER\_I2C Logic Decoding" src="../_images/REGI2C_logic2.png" />
<p class="caption"><span class="caption-number">Fig. 206 </span><span class="caption-text">REGISTER_I2C Logic Decoding</span></p>
</div>
<p>Zoom-in of master write:</p>
<div class="figure" id="id55">
<img alt="REGISTER\_I2C Logic Write (Zoom)" src="../_images/REGI2C_logic3.png" />
<p class="caption"><span class="caption-number">Fig. 207 </span><span class="caption-text">REGISTER_I2C Logic Write (Zoom)</span></p>
</div>
<p>Zoom-in of master read:</p>
<div class="figure" id="id56">
<img alt="REGISTER\_I2C Logic Read (Zoom)" src="../_images/REGI2C_logic4.png" />
<p class="caption"><span class="caption-number">Fig. 208 </span><span class="caption-text">REGISTER_I2C Logic Read (Zoom)</span></p>
</div>
<p><strong>Make note of the following important things from this example:</strong></p>
<ol class="arabic simple">
<li>The master (host) requested a sensor packet by writing the first two bytes of the sensor packet it wanted. The first two bytes indicate to the slave device what data to fetch for the host. Sensor packets are fixed length packets (always 6 bytes) that indicate the general status of a sensor. For button sensors, this includes information such as the dominant button that is being touched. For slider and wheel sensors, this includes the calculated slider/wheel position. Review the CapTIvate Protocol Sensor Packet description for details on the packet structure. The basic format is shown below.</li>
</ol>
<div class="figure" id="id57">
<img alt="Sensor Packet Frame" src="../_images/lib_comm_protocol_sensorpacket.png" />
<p class="caption"><span class="caption-number">Fig. 209 </span><span class="caption-text">Sensor Packet Frame</span></p>
</div>
<p>The first two bytes (shaded darker) include the CMD byte and the Sensor ID byte. The CMD byte tells the slave to fetch a sensor packet. The command ID for a sensor packet is 0x00. The Sensor ID byte tells the slave which sensor to fetch the packet for. In this case, we asked for Sensor ID 0x00, which corresponds to the button group sensor. These are the two items that are needed for reading a sensor packet.</p>
<ol class="arabic simple" start="2">
<li>Following the host requesting the packet, the host performs a read of the data to retrieve the entire packet that was generated by the slave (CapTIvate) device. This means that all 6 bytes of the sensor packet are read out of the device. Note that the two request bytes (the CMD byte and sensor ID byte) are re-sent back to the host. This is done as a confirmation to the host that the correct data was retrieved. The protocol specification states that payload byte 3 (the last byte of the packet) contains the sensor status byte. This indicates global touch/prox/detect status, global previous touch status, and other global diagnostic information. The protocol specification also states that the first byte (byte 0) contains the dominant element that is being touched in the button group. This information may be used to extract the ID of the button that is being touched the most in the group.</li>
<li>Note that the host may poll the slave device at any time, regardless of where the CapTIvate MCU is in the process of running a conversion. Often times it may be ideal to read out data when a new sample is available. For this purpose, a digital GPIO pin may be used between the slave and host as a means for the slave to indicate to the host that it wants its attention. This is left up to the user to implement, since different applications have different requirements. Some systems may want the host to be flagged whenever new data is available; others may only want the host to be flagged if someone is near the panel. Still, others may only want the host flagged when a confirmed touch is detected.</li>
</ol>
</div>
</div>
<div class="section" id="examples">
<h4>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h4>
<p>This section contains several examples of the I2C communication pattern needed to extract data from the CapTIvate software library.</p>
<div class="section" id="sensor-packet-example-getting-dominant-element-and-using-the-checksum">
<h5>Sensor Packet Example: Getting Dominant Element and Using the Checksum<a class="headerlink" href="#sensor-packet-example-getting-dominant-element-and-using-the-checksum" title="Permalink to this headline">¶</a></h5>
<p>In this example, we will use the same sensor packet request as in the original example above, with two differences: we are going to extract the dominant element and we are going to read back the checksum as well to validate the transaction. To read the checksum, we just read an additional two bytes after the 6 bytes of the packet (8 bytes total). The checksum is 16 bits, lower byte first, and is calculated from byte 0 to byte 5 (the entire packet excluding the checksum itself). The data capture shown here was taken while a touch was present on element 2. This is to shown what data looks like when an actual touch is present.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">loop</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="n">uint8_t</span> <span class="n">tx</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="n">static</span> <span class="n">uint8_t</span> <span class="n">rx</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">capture</span><span class="o">==</span><span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>

        <span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
        <span class="n">tx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
        <span class="n">I2CMaster_writeBuffer</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">I2CMaster_readBuffer</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">8</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">rx</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BIT0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x02</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">Element</span> <span class="mi">2</span> <span class="ow">is</span> <span class="n">touched</span>
            <span class="n">P1OUT</span> <span class="o">|=</span> <span class="n">BIT0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">Element</span> <span class="mi">2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">touched</span>
            <span class="n">P1OUT</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Below is the logic trace for this execution.</p>
<div class="figure" id="id58">
<img alt="REGISTER\_I2C Logic Trace" src="../_images/REGI2C_logic5.png" />
<p class="caption"><span class="caption-number">Fig. 210 </span><span class="caption-text">REGISTER_I2C Logic Trace</span></p>
</div>
<div class="figure" id="id59">
<img alt="REGISTER\_I2C Logic Decoding" src="../_images/REGI2C_logic6.png" />
<p class="caption"><span class="caption-number">Fig. 211 </span><span class="caption-text">REGISTER_I2C Logic Decoding</span></p>
</div>
<p>In this example, 8 bytes are read to extract the checksum in addition to the 6 bytes of the sensor packet.</p>
<p>The master writes 0x00 0x00 to initiate the request (sensor packet, sensor ID 0x00). The master then reads the response. Byte 2 of the packet returns 0x02 (the dominant element) indicating that element 02 was the dominant element pressed. Byte 5 returns 0x0F, indicating that the following sensor status flags were set: global touch, previous touch, global proximity, and global detect. The checksum reports as 0x0011, which is equal to 0x02 + 0x0F.</p>
</div>
<div class="section" id="sensor-packet-example-getting-wheel-position">
<h5>Sensor Packet Example: Getting Wheel Position<a class="headerlink" href="#sensor-packet-example-getting-wheel-position" title="Permalink to this headline">¶</a></h5>
<p>In this example, we will modify the example above to read the position of the wheel and light the LED on P1.0 of the host only if the wheel position is greater than 50. The source code used to read this is shown below:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">loop</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="n">uint8_t</span> <span class="n">tx</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="n">static</span> <span class="n">uint8_t</span> <span class="n">rx</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="n">uint16_t</span> <span class="n">position</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">capture</span><span class="o">==</span><span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>

        <span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
        <span class="n">tx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>
        <span class="n">I2CMaster_writeBuffer</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">I2CMaster_readBuffer</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">8</span><span class="p">);</span>

        <span class="o">//</span> <span class="n">Get</span> <span class="n">the</span> <span class="n">position</span> <span class="p">(</span><span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">rx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">rx</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BIT0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">Wheel</span> <span class="ow">is</span> <span class="n">touched</span> <span class="ow">and</span> <span class="o">&gt;</span><span class="mi">50</span>
            <span class="n">P1OUT</span> <span class="o">|=</span> <span class="n">BIT0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">Wheel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">touched</span> <span class="ow">or</span> <span class="o">&lt;</span><span class="mi">50</span>
            <span class="n">P1OUT</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Below is the logic trace for this execution.</p>
<div class="figure" id="id60">
<img alt="REGISTER\_I2C Logic Trace" src="../_images/REGI2C_logic7.png" />
<p class="caption"><span class="caption-number">Fig. 212 </span><span class="caption-text">REGISTER_I2C Logic Trace</span></p>
</div>
<div class="figure" id="id61">
<img alt="REGISTER\_I2C Logic Decoding" src="../_images/REGI2C_logic8.png" />
<p class="caption"><span class="caption-number">Fig. 213 </span><span class="caption-text">REGISTER_I2C Logic Decoding</span></p>
</div>
<p>The master writes 0x00 0x03 to initiate the request (sensor packet, sensor ID 0x03). The master then reads the response. Byte 2 and Byte 3 return a wheel position of 0x0047, or ‘71’. Byte 5 is 0x0F, indicating that the following sensor status flags were set: global touch, previous touch, global proximity, and global detect. The checksum reports as 0x0059, which is equal to 0x03 + 0x47 + 0x0F.</p>
<p>This packet would trigger the LED to light on the host, because the reported position was above 50 (decimal) and the global sensor touch flag was set.</p>
</div>
<div class="section" id="cycle-packet-example-getting-touch-status-for-all-buttons-in-a-button-group">
<h5>Cycle Packet Example: Getting Touch Status for All Buttons in a Button Group<a class="headerlink" href="#cycle-packet-example-getting-touch-status-for-all-buttons-in-a-button-group" title="Permalink to this headline">¶</a></h5>
<p>The sensor packet for a button group only provides global sensor status data and the dominant element. It does not indicate the individual touch status for all elements in the sensor. This is to allow for a fixed packet size, simplifying the protocol when this is the only data that is needed. However, certain designs would like to know the multi-touch information for all buttons inside of a button group. To obtain this information, the cycle packets for the sensor must be read.</p>
<p>Cycles are groups of elements that may be measured in parallel. Each sensor has at least one cycle, and may have more than one cycle. To view the time cycles for a sensor, open the Controller Customizer in the CapTIvate Design Center and view the Configure Connections tab.</p>
<div class="figure" id="id62">
<img alt="CAPTIVATE-BSWP Cycle Map" src="../_images/REGI2C_cycleMap.png" />
<p class="caption"><span class="caption-number">Fig. 214 </span><span class="caption-text">CAPTIVATE-BSWP Cycle Map</span></p>
</div>
<p>In the CAPTIVATE-BSWP example above, the keypadSensor has two time cycles. Time cycles are shown as columns, with the column containing all channels that are measured in parallel together within that cycle. For the keypad, the first time cycle contains elements E00, E01, E02, and E03. The second time cycle contains elements E04, E05, E06, and E07.</p>
<p>The cycle packet contains the touch and proximity state information individually for each element in the cycle. Be sure to review the cycle packet detailed description. The packet format is shown below.</p>
<div class="figure" id="id63">
<img alt="Cycle Packet Frame" src="../_images/lib_comm_protocol_cyclepacket.png" />
<p class="caption"><span class="caption-number">Fig. 215 </span><span class="caption-text">Cycle Packet Frame</span></p>
</div>
<p>For the cycle packet, the master will write 3 bytes to request the correct cycle packet: the CMD byte (0x01), the sensor ID byte, and the cycle ID byte. Cycles are indexed starting at 0x00, just like sensors. The code sequence used to read both cycle packets of the keypad sensor is shown below:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">loop</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="n">uint8_t</span> <span class="n">tx</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="n">static</span> <span class="n">uint8_t</span> <span class="n">rx</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="n">uint32_t</span> <span class="n">c0State</span><span class="p">;</span>
    <span class="n">uint32_t</span> <span class="n">c1State</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">capture</span><span class="o">==</span><span class="n">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>

        <span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
        <span class="n">tx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
        <span class="n">tx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
        <span class="n">I2CMaster_writeBuffer</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">I2CMaster_readBuffer</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">6</span><span class="p">);</span>
        <span class="n">c0State</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint32_t</span><span class="p">)</span><span class="n">rx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="p">((</span><span class="n">uint32_t</span><span class="p">)</span><span class="n">rx</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">uint32_t</span><span class="p">)</span><span class="n">rx</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

        <span class="n">tx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="n">I2CMaster_writeBuffer</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">I2CMaster_readBuffer</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">6</span><span class="p">);</span>
        <span class="n">c1State</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint32_t</span><span class="p">)</span><span class="n">rx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="p">((</span><span class="n">uint32_t</span><span class="p">)</span><span class="n">rx</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">uint32_t</span><span class="p">)</span><span class="n">rx</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">c0State</span> <span class="o">&amp;</span> <span class="mh">0x00FFF000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3000</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">Elements</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">1</span> <span class="n">are</span> <span class="n">both</span> <span class="n">touched</span> <span class="n">together</span>
            <span class="n">P1OUT</span> <span class="o">|=</span> <span class="n">BIT0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">Some</span> <span class="n">other</span> <span class="n">combination</span> <span class="ow">is</span> <span class="n">present</span>
            <span class="n">P1OUT</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This yields the following logic traces:</p>
<div class="figure" id="id64">
<img alt="REGISTER\_I2C Logic Trace" src="../_images/REGI2C_logic9.png" />
<p class="caption"><span class="caption-number">Fig. 216 </span><span class="caption-text">REGISTER_I2C Logic Trace</span></p>
</div>
<div class="figure" id="id65">
<img alt="REGISTER\_I2C Logic Decoding" src="../_images/REGI2C_logic10.png" />
<p class="caption"><span class="caption-number">Fig. 217 </span><span class="caption-text">REGISTER_I2C Logic Decoding</span></p>
</div>
<p>Note that there are two write/read sequences. First, the master writes 0x01 0x00 0x00 to request cycle packet 0 of sensor 0. The second request is 0x01 0x00 0x01 for cycle packet 1 of sensor 0.</p>
</div>
</div>
<div class="section" id="commonly-asked-questions">
<h4>Commonly Asked Questions<a class="headerlink" href="#commonly-asked-questions" title="Permalink to this headline">¶</a></h4>
<p>Below are commonly asked questions about using REGISTERI2C communication.</p>
<div class="section" id="sensor-id-determination">
<h5>Sensor ID Determination<a class="headerlink" href="#sensor-id-determination" title="Permalink to this headline">¶</a></h5>
<p>You might be asking how you determine the Sensor ID. The Sensor ID is set based on the order of sensors in the global sensor pointer array on the CapTIvate target. This ordering can be seen in the generated /captivate_config/CAPT_UserConfig.c file by looking at the g_pCaptivateSensorArray[] (shown below). You can also determine the ID by sorting your sensor names alphabetically. When generating the array seen below, the CapTIvate Design Center sorts all of the sensors in the canvas alphabetically based on the name given to them. In this case, the keypadSensor has ID 0x00, the prox sensor has ID 0x01, the slider sensor has ID 0x02, and the wheel sensor has ID 0x03.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">tSensor</span><span class="o">*</span> <span class="n">g_pCaptivateSensorArray</span><span class="p">[</span><span class="n">CAPT_SENSOR_COUNT</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">keypadSensor</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">proximitySensor</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">sliderSensor</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">wheelSensor</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="i2c-bit-clock">
<h5>I2C Bit Clock<a class="headerlink" href="#i2c-bit-clock" title="Permalink to this headline">¶</a></h5>
<p>Bit clocks from the master up to 400kHz are supported. Appropriately sized pull-up resistors are required.</p>
</div>
<div class="section" id="clock-stretching">
<h5>Clock Stretching<a class="headerlink" href="#clock-stretching" title="Permalink to this headline">¶</a></h5>
<p>In the logic traces, you will notice that the slave stretches the clock in between the master write and master read. This time is required for the slave to go and fetch the requested packet for the master to read out. The master device must support clock stretching per the I2C specification, or appropriate delays to handle worst-case propagation must be added.</p>
</div>
</div>
</div>
<div class="section" id="interface-layer">
<h3>Interface Layer<a class="headerlink" href="#interface-layer" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate™ interface layer is the top-level communication layer. It provides the top-level function calls that are used by the application, and serves to marry together the protocol layer (which handles packet generation and interpretation) with the serial driver (which actually moves the data in and out of the microcontroller). The functionality provided is covered in this section below. All application access to the communications module should be through the interface layer.</p>
<div class="section" id="using-the-communications-module-initializing-the-interface">
<h4>Using the Communications Module: Initializing the Interface<a class="headerlink" href="#using-the-communications-module-initializing-the-interface" title="Permalink to this headline">¶</a></h4>
<p>The communications module must be initialized at startup by the application via a call to <strong>CAPT_initCommInterface()</strong>. This top-level init function handles opening the selected serial driver, as well as initializing any queues/buffers that are needed for communication.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Init the Communications Module</td>
<td>extern void CAPT_initCommInterface(tCaptivateApplication *pApp)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="using-the-communications-module-handling-incoming-data">
<h4>Using the Communications Module: Handling Incoming Data<a class="headerlink" href="#using-the-communications-module-handling-incoming-data" title="Permalink to this headline">¶</a></h4>
<p>Incoming raw data from a host is buffered by the serial driver to be serviced when the application is available to do so. The application must periodically call <strong>CAPT_checkForInboundPacket()</strong> to check to see if any packets have been received from the host. This top-level function will check for packets in the receive queue of the serial driver, and if any packets are found, they will be processed according to their type. Typically, this function is called in a background loop when the application is available. Note that the serial drivers will exit active from sleep if a data is arriving from the host, which can be used as a mechanism to wake up the background loop to call this function.</p>
<p>The <strong>CAPT_checkForRecalibrationRequest()</strong> function should also be called periodically to see if any of the packets received and handled by <strong>CAPT_checkForInboundPacket()</strong> require the application to re-calibrate the user interface. An example of this would be if a packet was received that changed the conversion count, requiring a re-calibration of the sensors in the system.</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Check for an Inbound Packet, and Process It</td>
<td>extern bool CAPT_checkForInboundPacket(void)</td>
</tr>
<tr class="row-odd"><td>Check for a Re-calibration Request</td>
<td>extern bool CAPT_checkForRecalibrationRequest(void)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="using-the-communications-module-writing-out-data">
<h4>Using the Communications Module: Writing Out Data<a class="headerlink" href="#using-the-communications-module-writing-out-data" title="Permalink to this headline">¶</a></h4>
<p>The interface layer provides 5 top-level constructs for transmitting data to the host. The five functions below handle generation of the appropriate packet, management of the transmit ping/pong buffers, and transmission over the serial interface. If the serial peripheral is available (not busy) these calls are non-blocking, and the packets that are generated are transmitted to the host via interrupt service routines in the serial driver.</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Write Element Data</td>
<td>extern bool CAPT_writeElementData(uint8_t ui8SensorID)</td>
</tr>
<tr class="row-odd"><td>Write Sensor Data</td>
<td>extern bool CAPT_writeSensorData(uint8_t ui8SensorID)</td>
</tr>
<tr class="row-even"><td>Write General Purpose Data</td>
<td>extern bool CAPT_writeGeneralPurposeData(uint16_t *pData, uint8_t ui8Cnt)</td>
</tr>
<tr class="row-odd"><td>Write String</td>
<td>extern bool CAPT_writeString(uint8_t *pString)</td>
</tr>
<tr class="row-even"><td>Write TrackPad Data</td>
<td>extern bool CAPT_writeTrackPadData(tSensor *pSensor)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="compile-time-configuration">
<h4>Compile-Time Configuration<a class="headerlink" href="#compile-time-configuration" title="Permalink to this headline">¶</a></h4>
<p>The compile-time configuration options are set in the CAPT_CommConfig.h file. The available compile-time options are described below.</p>
<div class="section" id="interface-selection-definition">
<h5>Interface Selection Definition<a class="headerlink" href="#interface-selection-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="14%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CAPT_INTERFACE</td>
<td>CAPT_UserConfig.h</td>
<td><strong>CAPT_NO_INTERFACE</strong>, <strong>CAPT_UART_INTERFACE</strong>, <strong>CAPT_BULKI2C_INTERFACE</strong>, <strong>CAPT_REGISTERI2C_INTERFACE</strong></td>
</tr>
</tbody>
</table>
<p>CAPT_INTERFACE, unlike the remaining definitions, is located in the User Config file (CAPT_UserConfig.h). It selects the interface that the communications module should be built for. If the communication module should be excluded from the build, then <strong>CAPT_NO_INTERFACE</strong> should be set. Otherwise, the desired communication mode should be set.</p>
<p>NOTE: This value is automatically populated in the CAPT_UserConfig.h file by the Design Center during source code generation.</p>
</div>
<div class="section" id="transmit-buffer-size-definition">
<h5>Transmit Buffer Size Definition<a class="headerlink" href="#transmit-buffer-size-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="30%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CAPT_TRANSMIT_BUFFER_SIZE</td>
<td>CAPT_CommConfig.h</td>
<td>Unsigned Integer</td>
</tr>
</tbody>
</table>
<p>CAPT_TRANSMIT_BUFFER_SIZE defines the size of the transmit buffer. Note that 2x this size will be allocated, since ping-pong buffering is used. This size should also be at least 2x the size of the largest packet, to allow for byte stuffing.</p>
</div>
<div class="section" id="receive-queue-buffer-size-definition">
<h5>Receive Queue Buffer Size Definition<a class="headerlink" href="#receive-queue-buffer-size-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="31%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CAPT_QUEUE_BUFFER_SIZE</td>
<td>CAPT_CommConfig.h</td>
<td>Unsigned Integer</td>
</tr>
</tbody>
</table>
<p>CAPT_QUEUE_BUFFER_SIZE defines the size of the receive queue. This is the queue that the serial driver uses to buffer received data until the data is processed by a call to <strong>CAPT_checkForInboundPacket()</strong>. If it seems like packets are being dropped, a good first step is to increase the size of this buffer.</p>
</div>
<div class="section" id="i2c-slave-serial-driver-receive-buffer-size-definition">
<h5>I2C Slave Serial Driver Receive Buffer Size Definition<a class="headerlink" href="#i2c-slave-serial-driver-receive-buffer-size-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="28%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CAPT_I2C_RECEIVE_BUFFER_SIZE</td>
<td>CAPT_CommConfig.h</td>
<td>Unsigned Integer</td>
</tr>
</tbody>
</table>
<p>CAPT_I2C_RECEIVE_BUFFER_SIZE defines the size of the receive buffer used by the I2C Slave driver, if that driver is selected. This buffer size should be at least as large as the maximum length I2C bus write transaction that is expected.</p>
</div>
<div class="section" id="i2c-slave-serial-driver-buffer-size-in-register-mode-definition">
<h5>I2C Slave Serial Driver Buffer Size in Register Mode Definition<a class="headerlink" href="#i2c-slave-serial-driver-buffer-size-in-register-mode-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="27%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CAPT_I2C_REGISTER_RW_BUFFER_SIZE</td>
<td>CAPT_CommConfig.h</td>
<td>Unsigned Integer</td>
</tr>
</tbody>
</table>
<p>CAPT_I2C_REGISTER_RW_BUFFER_SIZE defines the size of the buffer used by the I2C Slave driver when the communication interface is configured in register I2C mode. This buffer size should be at least as large as the maximum length I2C bus transaction that is expected.</p>
</div>
</div>
</div>
<div class="section" id="protocol-layer">
<h3>Protocol Layer<a class="headerlink" href="#protocol-layer" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate™ protocol is a communications specification for sending capacitive touch specific data. It enables MSP430 Captivate-equipped microcontrollers to communicate with design, debug, and tuning tools on host PCs. In addition to this function, it can also provide a mechanism for interfacing a Captivate MCU to another host MCU or SoC in the context of a larger system. This guide discusses the details of the protocol itself: packet types and packet structure.</p>
<p>The Captivate protocol is a packet-based serial messaging protocol. It includes provisions for passing real-time capacitive measurement data from a Captivate target MCU to another processor, as well as provisions for tuning parameter read and write.</p>
<div class="section" id="use-cases">
<h4>Use Cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h4>
<p>The various use cases for the protocol are described below.</p>
<ol class="arabic simple">
<li>Capacitive Touch Development and Tuning Capacitive touch development and tuning involves looking at real-time data from a touch panel and adjusting software parameters to achieve the desired response and feel from the sensors on that panel. For example: tuning a capacitive button involves looking at the raw data coming back from the microcontroller about that button, and adjusting thresholds, de-bounce, and filters accordingly to create a robust user interface. Having the ability to adjust all of these software parameters in real-time while looking at sensor data, without re-compiling code, is extremely powerful and reduces development time. The Captivate protocol was designed with the Captivate Design Center specifically to meet this need.</li>
<li>Interface to Host Processor Most capacitive touch user interfaces involve a dedicated microcontroller driving the touch panel, which communicates up to a host processor of some kind. The flexibility of the Captivate protocol allows for it to be re-used as an interface to a host processor; it can stream touch status, proximity status, and slider/wheel position up to a host.</li>
<li>In-Field / In-System Debug Interface and Tuning Since the Captivate protocol supports reading and writing of capacitive touch tuning parameters, as well as the streaming of real-time data, it could potentially be utilized as a diagnostic tool in the field when coupled with the Captivate Design Center PC tool.</li>
</ol>
</div>
<div class="section" id="introduction-to-packet-types">
<h4>Introduction to Packet Types<a class="headerlink" href="#introduction-to-packet-types" title="Permalink to this headline">¶</a></h4>
<p>The Captivate protocol supports five packet types: sensor packets, cycle packets, parameter packets, general purpose packets, and trackpad packets. In a capacitive touch system, there are two endpoints in the communication link: the target MCU itself, and the host. The host might be a PC tool or some kind of embedded processor. Sensor packets, cycle packets, general purpose packets, and trackpad packets carry information about the current state of the touch panel being driven by the target MCU. These packets are UNIDIRECTIONAL, and only travel from the target to the host. Parameter packets are BIDIRECTIONAL, and may travel from the target to the host or from the host to the target.</p>
<div class="figure" id="id66">
<img alt="Packet Directionality" src="../_images/lib_comm_protocol_packet_direction.png" />
<p class="caption"><span class="caption-number">Fig. 218 </span><span class="caption-text">Packet Directionality</span></p>
</div>
<div class="section" id="sensor-packets">
<h5>Sensor Packets<a class="headerlink" href="#sensor-packets" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="ch_library.html#format-sensor-packets">Sensor packets</a> are unidirectional packets from the Captivate MCU to the host. They provide information about the current state of a sensor. Sensor state information includes things like dominant button, slider or wheel position, sensor global proximity state, and sensor global touch/previous touch state.</p>
</div>
<div class="section" id="cycle-packets">
<h5>Cycle Packets<a class="headerlink" href="#cycle-packets" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="ch_library.html#format-cycle-packets">Cycle packets</a> are unidirectional packets from the Captivate MCU to the host. They provide low level element information, such as element touch status, element proximity status, element count, and element long term average for all of the elements within a cycle. These packets are typically used in the tuning phase, where it is desirable to have real-time views of count and long term average for setting thresholds and tuning filters.</p>
</div>
<div class="section" id="trackpad-packets">
<h5>Trackpad Packets<a class="headerlink" href="#trackpad-packets" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="ch_library.html#format-trackpad-packets">Trackpad packets</a> are unidirectional packets from trackpad MCUs to the host. They provide the X and Y coordinates of touches as well s gesture information.</p>
</div>
<div class="section" id="general-purpose-packets">
<h5>General Purpose Packets<a class="headerlink" href="#general-purpose-packets" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="ch_library.html#format-general-purpose-packets">General purpose packets</a> are unidirectional packets from a Captivate MCU to the host. They serve as a generic container to send any information that can be formatted as a 16-bit unsigned integer. This channel can serve as a debug tool for sending any kind of information that doesn&#8217;t fit into any of the other packet types. Up to 29 integers (58 bytes) may be sent in a single packet.</p>
</div>
<div class="section" id="parameter-packets">
<h5>Parameter Packets<a class="headerlink" href="#parameter-packets" title="Permalink to this headline">¶</a></h5>
<p><a class="reference external" href="ch_library.html#format-parameter-packets">Parameter packets</a> are bi-directional packets between a host and the Captivate MCU. <a class="reference external" href="ch_library.html#format-parameter-packets">Parameter packets</a> allow for the host to adjust a tuning parameter on the target at runtime. For example, the touch threshold for an element or the resolution of a slider could be adjusted by sending the appropriate parameter command. Parameters can be read or written. Parameter reads and writes from a host to a target MCU always result in a read-back of the most current value (the value after the write, in the case of a write).</p>
</div>
</div>
<div class="section" id="transmission-rules">
<h4>Transmission Rules<a class="headerlink" href="#transmission-rules" title="Permalink to this headline">¶</a></h4>
<p>The packet types discussed above are transmitted via a serial interface of some kind between the target and the host. Full-duplex UART is the typical interface. To provide reliable and accurate packet transmission, a set of transmission rules is applied to all packets when being transmitted. These rules are discussed in the <a class="reference external" href="ch_evm.html#operating-mode-packet-mode">HID Bridge Packet Mode</a> section.</p>
<p>The following functions aid in applying transmission rules:</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Stuff Sync Bytes in a Packet</td>
<td>extern uint16_t CAPT_stuffSyncBytes(uint8_t *pBuffer, uint16_t ui16Length)</td>
</tr>
<tr class="row-odd"><td>Verify a Checksum</td>
<td>extern bool CAPT_verifyChecksum(const uint8_t *pBuffer, const uint16_t ui16Length, const uint16_t ui16Checksum)</td>
</tr>
<tr class="row-even"><td>Get a Checksum</td>
<td>extern uint16_t CAPT_getChecksum(const uint8_t *pBuffer, const uint16_t ui16Length)</td>
</tr>
<tr class="row-odd"><td>Identify and Frame a Packet in a Receive Data Queue</td>
<td>extern bool CAPT_processReceivedData(tByteQueue *pReceiveQueue, tParameterPacket *pPacket, tTLProtocolProcessingVariables *pVariables)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="format-sensor-packets">
<h4>Format: Sensor Packets<a class="headerlink" href="#format-sensor-packets" title="Permalink to this headline">¶</a></h4>
<p>Sensor packets have a fixed length of 6 bytes. There are two control bytes and four data payload bytes.</p>
<div class="figure" id="id67">
<img alt="Sensor Packet Format" src="../_images/lib_comm_protocol_sensorpacket.png" />
<p class="caption"><span class="caption-number">Fig. 219 </span><span class="caption-text">Sensor Packet Format</span></p>
</div>
<ol class="arabic simple">
<li><strong>Command Byte [0]</strong> The command byte for a sensor packet is always 00h.</li>
<li><strong>Sensor ID Byte [1]</strong> The sensor ID byte contains an unsigned 8-bit integer that specifies the ID of the sensor whose data is being transmitted. Sensor ID on the target side is typically established by the order of sensor pointers in the global sensor pointer array. Sensors are sorted alphabetically by the Captivate Design Center PC GUI.</li>
<li><strong>Data Payload Bytes [2-5]</strong> The data payload bytes contain the sensor data that is being sent. The information contained in the payload is dependent upon the sensor type. The table below describes the payload on a sensor type basis.</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="31%" />
<col width="33%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Sensor Type</th>
<th class="head">Payload Byte 0</th>
<th class="head">Payload Byte 1</th>
<th class="head">Payload Byte 2</th>
<th class="head">Payload Byte 3</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Button Group</td>
<td>Dominant Element (256 elements max)</td>
<td>Previous Dominant Element (256 elements max)</td>
<td>Reserved</td>
<td>Sensor Status</td>
</tr>
<tr class="row-odd"><td>Slider</td>
<td>Slider Position (Lower 8 bits of 16 bits)</td>
<td>Slider Position (Upper 8 bits of 16 bits)</td>
<td>Reserved</td>
<td>Sensor Status</td>
</tr>
<tr class="row-even"><td>Wheel</td>
<td>Wheel Position (Lower 8 bits of 16 bits)</td>
<td>Wheel Position (Upper 8 bits of 16 bits)</td>
<td>Reserved</td>
<td>Sensor Status</td>
</tr>
<tr class="row-odd"><td>TrackPad</td>
<td>Reserved</td>
<td>Reserved</td>
<td>Reserved</td>
<td>Sensor Status</td>
</tr>
</tbody>
</table>
<p>Note - <a class="reference external" href="ch_library.html#format-trackpad-packets">Trackpad packets</a> are described in detail below.</p>
<p>The sensor status byte, included in button group, slider, and wheel sensor packets, provides additional data about the state of the sensor that is often meaningful. The status flags are all boolean flags, and are assigned to bit positions as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Bit Mask (Position)</th>
<th class="head">Sensor Status Flag</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Bit 0 (01h)</td>
<td>Global Sensor Touch Flag</td>
</tr>
<tr class="row-odd"><td>Bit 1 (02h)</td>
<td>Global Sensor Previous Touch Flag</td>
</tr>
<tr class="row-even"><td>Bit 2 (04h)</td>
<td>Global Sensor Proximity Flag</td>
</tr>
<tr class="row-odd"><td>Bit 3 (08h)</td>
<td>Global Sensor Detect Flag (Prox Detect Pre-Debounce)</td>
</tr>
<tr class="row-even"><td>Bit 4 (10h)</td>
<td>Global Sensor Negative Touch Flag (Reverse Touch)</td>
</tr>
<tr class="row-odd"><td>Bit 5 (20h)</td>
<td>Global Sensor Noise State</td>
</tr>
<tr class="row-even"><td>Bit 6 (40h)</td>
<td>Global Sensor Max Count Error Flag</td>
</tr>
<tr class="row-odd"><td>Bit 7 (80h)</td>
<td>Global Sensor Calibration Error Flag</td>
</tr>
</tbody>
</table>
<p><strong>NOTE:</strong> For slider / wheel sensors, the 16 position bits in the data payload will contain the valid slider or wheel position when the global sensor touch flag is true on that sensor. If there is not a global touch detection, the 16 position bits will all be set high (0xFFFF for the slider/wheel position value).</p>
<p><strong>NOTE:</strong> Reserved fields are still transmitted, but do not contain any meaningful data. Do not use or rely on any data transmitted in a reserved field.</p>
<p>Sensor packets are generated via a call into the protocol layer. The <strong>CAPT_getSensorPacket</strong>() function looks up the sensor at index ui8SensorID in the array sensorArray, and stores the generated packet in the buffer space pointed to by pBuffer. The length of the packet is returned by the function.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Get a Sensor Packet</td>
<td>extern uint16_t CAPT_getSensorPacket(tSensor **sensorArray, uint8_t ui8SensorID, uint8_t *pBuffer)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="format-cycle-packets">
<h4>Format: Cycle Packets<a class="headerlink" href="#format-cycle-packets" title="Permalink to this headline">¶</a></h4>
<p>Cycle packets have a variable length which is dependent upon the number of elements within the cycle. There are always 3 control bytes and 3 state bytes. In addition to those 6 bytes, there are 4 bytes per element in the cycle.</p>
<div class="figure" id="id68">
<img alt="Cycle Packet Format" src="../_images/lib_comm_protocol_cyclepacket.png" />
<p class="caption"><span class="caption-number">Fig. 220 </span><span class="caption-text">Cycle Packet Format</span></p>
</div>
<ol class="arabic simple">
<li><strong>Command Byte [0]</strong> The command byte for a cycle packet is always 01h.</li>
<li><strong>Sensor ID Byte [1]</strong> The sensor ID byte contains an unsigned 8-bit integer that specifies the ID of the sensor whose data is being transmitted. Sensor ID on the target side is typically established by the order of sensor pointers in the global sensor pointer array. Sensors are sorted alphabetically by the Captivate Design Center PC GUI.</li>
<li><strong>Cycle ID Byte [2]</strong> The cycle ID byte contains an unsigned 8-bit integer that specifies the ID of the cycle whose data is being transmitted, relative to the sensor. For example, in a sensor with 3 cycles, the first cycle would have an ID of 0, the second, an ID of 1, and the third, an ID of 2. The cycle ID should correspond to the index of the cycle in the sensor&#8217;s cycle pointer array.</li>
<li><strong>Cycle State Bytes [3-5]</strong> The cycle state bytes specify the touch and proximity detection flags for each element in the cycle. Up to 12 elements per cycle are supported. Bytes 3 through 5 of the cycle packet comprise a 24 bit cycle state section, where the lower 12 bits represent the proximity state for each element in a bitwise fashion, and the upper 12 bits represent the touch state for each element in a bitwise fashion.</li>
<li><strong>Element LTA and Element Count Bytes [6-n], n=5+4(number of elements)</strong> The remainder of the cycle packet is comprised of element LTA and count values. LTA and count are represented as 16 bit unsigned integers. As such, 32 bits are required for each element in the LTA/Count section. The packet shall increase in size in 32 bit (4 byte) increments for every additional element in the cycle, up to a maximum of 12 elements. The LTA is sent first, and the count second. Per the protocol, when sending values greater than one byte, the transmission sequence is lowest order byte to highest order byte.</li>
</ol>
<p>Cycle packets are generated via a call into the protocol layer. The <strong>CAPT_getCyclePacket</strong>() function looks up the cycle at index ui8Cycle in the sensor at index ui8SensorID in the array sensorArray, and stores the generated packet in the buffer space pointed to by pBuffer. The length of the packet is returned by the function.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Get a Cycle Packet</td>
<td>extern uint16_t CAPT_getCyclePacket(tSensor **sensorArray, uint8_t ui8SensorID, uint8_t ui8Cycle, uint8_t *pBuffer);</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="format-trackpad-packets">
<h4>Format: Trackpad Packets<a class="headerlink" href="#format-trackpad-packets" title="Permalink to this headline">¶</a></h4>
<p>Trackpad packets have a fixed length of 8 bytes where the last 5-bytes contain the gesture and position information. The packet format can be seen below.</p>
<!---
Trackpad packets have a variable length which is dependent upon the maximum number of simultaneous touches supported by the trackpad device.
There are 3 control bytes. Following the control bytes, there is a trackpad gesture byte for indicating the detection of a gesture and what the gesture was.
For each simultaneous touch the trackpad device supports, 4 additional payload bytes are added to the packet. The packet format can be seen below.
---><div class="figure" id="id69">
<img alt="Trackpad Packet Format" src="../_images/lib_comm_protocol_trackpadpacket.png" />
<p class="caption"><span class="caption-number">Fig. 221 </span><span class="caption-text">Trackpad Packet Format</span></p>
</div>
<ol class="arabic simple">
<li><strong>Command Byte [0]</strong> The command byte for trackpad packets is always 02h.</li>
<li><strong>Sensor ID Byte [1]</strong> The sensor ID byte contains an unsigned 8-bit integer that specifies the ID of the sensor whose data is being transmitted. In typical trackpad applications this is the only sensor, however, it is very possible to have additional senosrs, such as buttons or even sliders/wheels, depending on the number of available CapTIvate™ IO pins.</li>
<li><strong>Reserved Byte [2]</strong> At present, this byte is reserved and returns a value = 1.</li>
</ol>
<!---
3. **Max Touches Byte [2]**
The max touches byte contains an unsigned 8-bit integer that specifies the number of simultaneous touches supported by the trackpad device.
This also provides insight into the length of the remainder of the packet.

Following the max touches byte, there will be 4 bytes for each simultaneous touch
supported by the trackpad device.
---><ol class="arabic simple" start="4">
<li><strong>Gesture Status Byte [3]</strong> The trackpad gesture byte indicates whether a gesture was just detected, and what that gesture was. The value/gesture pairs are listed below. If no gesture was detected, the gesture byte will be set to FFh.</li>
<li><strong>Touch Coordinates Bytes[4-7]</strong> The touch coordinates indicate the presence and location of a touch on the trackpad. Touch locations are represented as two 16-bit unsigned integers: one for the coordinate on the X axis, and one for the coordinate on the Y axis. 16 bits is the maximum resolution in either the X or Y direction for the trackpad. Most applications will have a working resolution that is less than 16 bits per coordinate, but 16 bits are always sent regardless. If no touch is present, both the X and the Y coordinates will read as FFFFh.</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Value</strong></th>
<th class="head">Gesture</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>00h</td>
<td>Wake on Proximity Detection</td>
</tr>
<tr class="row-odd"><td>01h</td>
<td>Reserved</td>
</tr>
<tr class="row-even"><td>02h</td>
<td>Single Tap</td>
</tr>
<tr class="row-odd"><td>03h</td>
<td>Double Tap</td>
</tr>
<tr class="row-even"><td>04h</td>
<td>Reserved</td>
</tr>
<tr class="row-odd"><td>05h</td>
<td>Reserved</td>
</tr>
<tr class="row-even"><td>06h</td>
<td>Tap and Hold</td>
</tr>
<tr class="row-odd"><td>07h</td>
<td>Reserved</td>
</tr>
<tr class="row-even"><td>08h</td>
<td>Swipe Left</td>
</tr>
<tr class="row-odd"><td>09h</td>
<td>Swipe Right</td>
</tr>
<tr class="row-even"><td>0Ah</td>
<td>Swipe Up</td>
</tr>
<tr class="row-odd"><td>0Bh</td>
<td>Swipe Down</td>
</tr>
<tr class="row-even"><td>0Ch-FEh</td>
<td>Reserved</td>
</tr>
<tr class="row-odd"><td>FFh</td>
<td>No Gesture Detected</td>
</tr>
</tbody>
</table>
<!---
|0Ch|Arc CW|
|0Dh|Arc CCW|
|0Eh|Circle CW|
|0Fh|Circle CCW|
---><!---
5. **Touch Coordinates [4-n], n=4+4(Max Touches)**
The touch coordinates indicate the presence of and location of a touch on the trackpad. Touch locations are communicated via two 16-bit unsigned integers per touch:
one for the coordinate on the X axis, and one for the coordinate on the Y axis. 16 bits is the maximum resolution in either the X or Y direction for the trackpad.
Most applications will have a working resolution that is less than 16 bits per coordinate, but 16 bits are always sent regardless.
If no touch is present, both the X and the Y coordinates will read as FFFFh.
---><p><strong>NOTE:</strong> Trackpad packets only pertain to dedicated trackpad devices.</p>
</div>
<div class="section" id="format-general-purpose-packets">
<h4>Format: General Purpose Packets<a class="headerlink" href="#format-general-purpose-packets" title="Permalink to this headline">¶</a></h4>
<p>General purpose packets are unique in that they simply serve as a data streaming mechanism for any data an application wishes to send. Data is sent as an array of 16-bit unsigned integers. General purpose packets have variable length that is dependent upon the number of integers being sent. There are always 2 control bytes. Following the control bytes is the data payload (up to 29 entries), with 2 bytes (16 bits) per entry.</p>
<div class="figure" id="id70">
<img alt="General Purpose Packet Format" src="../_images/lib_comm_protocol_gppacket.png" />
<p class="caption"><span class="caption-number">Fig. 222 </span><span class="caption-text">General Purpose Packet Format</span></p>
</div>
<ol class="arabic simple">
<li><strong>Command Byte [0]</strong> The command byte for general purpose packets is always 10h.</li>
<li><strong>Valid Data Count Byte [1]</strong> The valid data count byte indicates how many valid data entries exist in the packet. This also implies the length of the packet: each valid entry implies two bytes of payload (each entry is a 16-bit unsigned integer). Valid values for this field are 1-29.</li>
<li><strong>Data Payload [2-n]</strong> The data payload section contains the generic data to be transmitted, formatted as unsigned 16-bit integers. Up to 29 payload items (58 bytes) are allowed.</li>
</ol>
<p>General purpose packets are generated via a call into the protocol layer. The <strong>CAPT_getGeneralPurposePacket</strong>() function generates a packet for the data array of length ui8Cnt pointed to by pData, and stores the generated packet in the buffer space pointed to by pBuffer.</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Get a General Purpose Packet</td>
<td>extern uint16_t CAPT_getGeneralPurposePacket(uint16_t *pData, uint8_t ui8Cnt, uint8_t *pBuffer)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="format-parameter-packets">
<h4>Format: Parameter Packets<a class="headerlink" href="#format-parameter-packets" title="Permalink to this headline">¶</a></h4>
<p>Parameter packets have a fixed length of 7 bytes. There are 3 control bytes and 4 data payload bytes. The packet format can be seen below.</p>
<div class="figure" id="id71">
<img alt="Parameter Packet Format" src="../_images/lib_comm_protocol_parameterpacket.png" />
<p class="caption"><span class="caption-number">Fig. 223 </span><span class="caption-text">Parameter Packet Format</span></p>
</div>
<ol class="arabic simple">
<li><strong>Command Byte [0]</strong> The command byte for parameter packets is variable, and indicates the ID of the parameter that is to be read or written to.</li>
<li><strong>Read/Write Byte [1]</strong> The read/write byte is a 1-bit Boolean value that indicates whether the operation is a parameter read or a parameter write. 1 = write, 0 = read.</li>
<li><strong>Sensor ID Byte [2]</strong> The sensor ID byte contains an unsigned 8-bit integer that specifies the ID of the sensor whose parameter is being read from or written to. Sensor ID on the target side is typically established by the order of sensor pointers in the global sensor pointer array. Sensors are sorted alphabetically by the Captivate Design Center PC tool. Note that parameters for controller commands (C-h commands) may not use the Sensor ID field.</li>
<li><strong>Data Bytes [3-6]</strong> The data bytes contain the information that is to be read or written to. In some cases, 1 or more of the data bytes are used for further ID (such as cycle ID or element ID).</li>
</ol>
<p>The protocol layer provides several functions for framing and interpreting parameter packets. Placing a call into <strong>CAPT_processReceivedData()</strong> causes the protocol layer to search for potential packets in a datastream that has been queued up by a serial driver. Once a valid packed has been framed, the parameter may be accessed and updated/read via calls to <strong>CAPT_accessSensorParameter()</strong> and <strong>CAPT_accessSpecialSensorParameter()</strong>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Access a Sensor Parameter</td>
<td>extern tTLParameterAccessResult CAPT_accessSensorParameter(tSensor **sensorArray, tParameterPacket *pPacket)</td>
</tr>
<tr class="row-odd"><td>Access a Special Sensor Parameter</td>
<td>extern tTLParameterAccessResult CAPT_accessSpecialSensorParameter(tSensor **sensorArray, tParameterPacket *pPacket)</td>
</tr>
<tr class="row-even"><td>Identify and Frame a Packet in a Receive Data Queue</td>
<td>extern bool CAPT_processReceivedData(tByteQueue *pReceiveQueue, tParameterPacket *pPacket, tTLProtocolProcessingVariables *pVariables)</td>
</tr>
<tr class="row-odd"><td>Verify a Checksum</td>
<td>extern bool CAPT_verifyChecksum(const uint8_t *pBuffer, const uint16_t ui16Length, const uint16_t ui16Checksum)</td>
</tr>
</tbody>
</table>
<p>The available parameters that can be adjusted through the use of parameter packets are listed below.</p>
<div class="section" id="sensor-parameters">
<h5>Sensor Parameters<a class="headerlink" href="#sensor-parameters" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="13%" />
<col width="13%" />
<col width="4%" />
<col width="9%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter Name</th>
<th class="head">Byte 0: CMD</th>
<th class="head">Byte 1: RW</th>
<th class="head">Byte 2: ID</th>
<th class="head">Byte 3</th>
<th class="head">Byte 4</th>
<th class="head">Byte 5</th>
<th class="head">Byte 6</th>
<th class="head">MCU Task</th>
<th class="head">SW Containing Structure</th>
<th class="head">SW Containing Variable</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#conversion-gain">Conversion Gain</a></td>
<td>80</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>ATI Base Lower Byte</td>
<td>ATI Base Upper Byte</td>
<td>Re-Cal</td>
<td>tSensor</td>
<td>ui16ConversionGain</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#conversion-count">Conversion Count</a></td>
<td>81</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>ATI Target Lower Byte</td>
<td>ATI Target Upper Byte</td>
<td>Re-Cal</td>
<td>tSensor</td>
<td>ui16ConversionCount</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#proximity-threshold">Prox Threshold</a></td>
<td>82</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Prox Threshold Lower Byte</td>
<td>Prox Threshold Upper Byte</td>
<td>NA</td>
<td>tSensor</td>
<td>ui16ProxThreshold</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#debounce">Prox Debounce-In Threshold</a></td>
<td>84</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Prox Db In</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>ProxDbThreshold .DbUp</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#debounce">Prox Debounce-Out Threshold</a></td>
<td>85</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Prox Db Out</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>ProxDbThreshold .DbDown</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#debounce">Touch Debounce-In Threshold</a></td>
<td>86</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Touch Db In</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>TouchDbThreshold .DbUp</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#debounce">Touch Debounce-Out Threshold</a></td>
<td>87</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Touch Db Out</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>TouchDbThreshold .DbDown</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#sensor-timeout-threshold">Sensor Timeout Threshold</a></td>
<td>88</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Sensor Timeout Lower Byte</td>
<td>Sensor Timeout Upper Byte</td>
<td>NA</td>
<td>tSensor</td>
<td>ui16TimeoutThreshold</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#count-filter">Count Filter Enable</a></td>
<td>89</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Count Filter Enable bit</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>bCountFilterSelect</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#count-filter">Count Filter Beta</a></td>
<td>8A</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Count Filter Beta</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>ui8CntBeta</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#lta-filter">LTA Filter Beta</a></td>
<td>8B</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>LTA Filter Beta</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>ui8LTABeta</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#lta-filter">Halt LTA Filter Immediately</a></td>
<td>8C</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>LTA Filter Halt</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>bSensorHalt</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#run-time-recalibration">Runtime Re-Calibration Enable</a></td>
<td>8D</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Runtime Re-Cal Enable</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>bReCalibrateEnable</td>
</tr>
<tr class="row-odd"><td>Force Re-Calibrate</td>
<td>8E</td>
<td>N/A</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Re-Cal</td>
<td>tSensor</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#bias_current">Bias Current</a></td>
<td>8F</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Bias Current</td>
<td>Don&#8217;t Care</td>
<td>Re-Cal</td>
<td>tSensor</td>
<td>ui8BiasControl</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#sample-capacitor-discharge">Sample Capacitor Discharge</a></td>
<td>95</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Cs Discharge</td>
<td>Don&#8217;t Care</td>
<td>Re-Cal</td>
<td>tSensor</td>
<td>bCsDischarge</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#modulation-enable">Modulation Enable</a></td>
<td>96</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Mod Enable</td>
<td>Don&#8217;t Care</td>
<td>Re-Cal</td>
<td>tSensor</td>
<td>bModEnable</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#frequency-divider">Frequency Divider</a></td>
<td>97</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Freq Div</td>
<td>Don&#8217;t Care</td>
<td>Re-Cal</td>
<td>tSensor</td>
<td>ui8FreqDiv</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#phase-lengths">Charge/Hold Phase Length</a></td>
<td>98</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Charge Length</td>
<td>Don&#8217;t Care</td>
<td>Re-Cal</td>
<td>tSensor</td>
<td>ui8ChargeLength</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#phase-lengths">Transfer/Sample Phase Length</a></td>
<td>99</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Transfer Length</td>
<td>Don&#8217;t Care</td>
<td>Re-Cal</td>
<td>tSensor</td>
<td>ui8TransferLength</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#error-threshold">Error Threshold</a></td>
<td>9A</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Error Threshold Lower Byte</td>
<td>Error Threshold Upper Byte</td>
<td>NA</td>
<td>tSensor</td>
<td>ui16ErrorThreshold</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#negative-touch-threshold">Negative Touch Threshold</a></td>
<td>9B</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Negative Touch Threshold Lower Byte</td>
<td>Negative Touch Threshold Upper Byte</td>
<td>NA</td>
<td>tSensor</td>
<td>ui16NegativeTouchThreshold</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#idle-state">Idle State</a></td>
<td>9C</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Idle State</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>bIdleState</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#sync-parameters">Input Sync</a></td>
<td>9D</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Input Sync</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>ui8InputSyncControl</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#sync-parameters">Timer Sync</a></td>
<td>9E</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Timer Sync</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>bTimerSyncControl</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#auto-power-down">Automatic Power-Down Enable</a></td>
<td>9F</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Power Down Control</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>bLpmControl</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#lta-filter">Halt LTA on Sensor Prox or Touch</a></td>
<td>A0</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Sensor Prox/Touch Halt</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>bPTSensorHalt</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#lta-filter">Halt LTA on Element Prox or Touch</a></td>
<td>A1</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Element Prox/Touch Halt</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSensor</td>
<td>bPTElementHalt</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="element-parameters">
<h5>Element Parameters<a class="headerlink" href="#element-parameters" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="4%" />
<col width="4%" />
<col width="4%" />
<col width="9%" />
<col width="22%" />
<col width="10%" />
<col width="4%" />
<col width="3%" />
<col width="8%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter Name</th>
<th class="head">Byte 0: CMD</th>
<th class="head">Byte 1: RW</th>
<th class="head">Byte 2: ID</th>
<th class="head">Byte 3</th>
<th class="head">Byte 4</th>
<th class="head">Byte 5</th>
<th class="head">Byte 6</th>
<th class="head">MCU Task</th>
<th class="head">SW Containing Structure</th>
<th class="head">SW Containing Variable</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#touch-threshold">Touch Threshold</a></td>
<td>83</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Cycle # (relative to sensor)</td>
<td>Lower 4 Bits: Element # (relative to cycle)</td>
<td>Touch Threshold</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tElement</td>
<td>ui8TouchThreshold [Element #]</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#engineering-parameters">Coarse Gain Ratio</a></td>
<td>A2</td>
<td>R</td>
<td>Sensor ID</td>
<td>Cycle # (relative to sensor)</td>
<td>[UPPER 4 Bits: Frequency #] [ LOWER 4 Bits: Element # relative to cycle]</td>
<td>Coarse Gain</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tCaptivateElementTuning</td>
<td>ui8GainRatioCoarse</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#engineering-parameters">Fine Gain Ratio</a></td>
<td>A3</td>
<td>R</td>
<td>Sensor ID</td>
<td>Cycle # (relative to sensor)</td>
<td>[UPPER 4 Bits: Frequency #] [ LOWER 4 Bits: Element # relative to cycle]</td>
<td>Fine Gain</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tCaptivateElementTuning</td>
<td>ui8GainRatioFine</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#engineering-parameters">Parasitic Offset Scale</a></td>
<td>D0</td>
<td>R</td>
<td>Sensor ID</td>
<td>Cycle # (relative to sensor)</td>
<td>[UPPER 4 Bits: Frequency #] [ LOWER 4 Bits: Element # relative to cycle]</td>
<td>Offset Scale (2 bit selection)</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tCaptivateElementTuning</td>
<td>ui16OffsetTap Upper Byte</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#engineering-parameters">Parasitic Offset Level</a></td>
<td>D1</td>
<td>R</td>
<td>Sensor ID</td>
<td>Cycle # (relative to sensor)</td>
<td>[UPPER 4 Bits: Frequency #] [ LOWER 4 Bits: Element # relative to cycle]</td>
<td>Offset Level (8 bit selection)</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tCaptivateElementTuning</td>
<td>ui16OffsetTap Lower Byte</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="slider-wheel-parameters">
<h5>Slider/Wheel Parameters<a class="headerlink" href="#slider-wheel-parameters" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="12%" />
<col width="12%" />
<col width="4%" />
<col width="10%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter Name</th>
<th class="head">Byte 0: CMD</th>
<th class="head">Byte 1: RW</th>
<th class="head">Byte 2: ID</th>
<th class="head">Byte 3</th>
<th class="head">Byte 4</th>
<th class="head">Byte 5</th>
<th class="head">Byte 6</th>
<th class="head">MCU Task</th>
<th class="head">SW Containing Structure</th>
<th class="head">SW Containing Variable</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#position-filter">Slider/Wheel Position Filter Enable</a></td>
<td>90</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Slider Filter Enable bit</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSliderSensorParams</td>
<td>SliderFilterEnable</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#position-filter">Slider/Wheel Position Filter Beta</a></td>
<td>91</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Slider Filter Beta</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tSliderSensorParams</td>
<td>SliderBeta</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#desired-resolution">Desired Slider/Wheel Resolution</a></td>
<td>92</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Slider Resolution Lower Byte</td>
<td>Slider Resolution Upper Byte</td>
<td>NA</td>
<td>tSliderSensorParams</td>
<td>ui16Resolution</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#slider-trim">Slider Lower Trim</a></td>
<td>93</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Slider Lower Trim Lower Byte</td>
<td>Slider Lower Trim Upper Byte</td>
<td>NA</td>
<td>tSliderSensorParams</td>
<td>SliderLower</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#slider-trim">Slider Upper Trim</a></td>
<td>94</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Slider Upper Trim Lower Byte</td>
<td>Slider Upper Trim Upper Byte</td>
<td>NA</td>
<td>tSliderSensorParams</td>
<td>SliderUpper</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="trackpad-parameters">
<h5>TrackPad Parameters<a class="headerlink" href="#trackpad-parameters" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="7%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="12%" />
<col width="11%" />
<col width="5%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter Name</th>
<th class="head">Byte 0: CMD</th>
<th class="head">Byte 1: RW</th>
<th class="head">Byte 2: ID</th>
<th class="head">Byte 3</th>
<th class="head">Byte 4</th>
<th class="head">Byte 5</th>
<th class="head">Byte 6</th>
<th class="head">MCU Task</th>
<th class="head">SW Containing Structure</th>
<th class="head">SW Containing Variable</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>[TrackPad Filter Enable]</td>
<td>60</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Filter Enable Bit</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>bTrackPadFilterEnable</td>
</tr>
<tr class="row-odd"><td>[TrackPad Filter Beta]</td>
<td>61</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Filter Beta Byte</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui8TrackPadSensorBeta</td>
</tr>
<tr class="row-even"><td>[Dynamic Filter Beta Top Speed]</td>
<td>63</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Speed Lower Byte</td>
<td>Speed Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16TopSpeed</td>
</tr>
<tr class="row-odd"><td>[Dynamic Filter Beta Bottom Speed]</td>
<td>64</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Speed Lower Byte</td>
<td>Speed Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16LowerBeta</td>
</tr>
<tr class="row-even"><td>[Dynamic Filter Beta Lower]</td>
<td>65</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Filter Lower Beta Byte</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16Beta</td>
</tr>
<tr class="row-odd"><td>[TrackPad Filter Type]</td>
<td>66</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Filter Type Bit</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16TrackPadFilterType</td>
</tr>
<tr class="row-even"><td>[TrackPad Resolution X-axis]</td>
<td>67</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Resolution Lower Byte</td>
<td>Resolution Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16Resolution_X</td>
</tr>
<tr class="row-odd"><td>[TrackPad Resolution Y-axis]</td>
<td>68</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Resolution Lower Byte</td>
<td>Resolution Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16Resolution_Y</td>
</tr>
<tr class="row-even"><td>[TrackPad Lower Trim X-axis]</td>
<td>69</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Trim Lower Byte</td>
<td>Trim Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16LowerTrim_X</td>
</tr>
<tr class="row-odd"><td>[TrackPad Upper Trim X-axis]</td>
<td>6A</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Trim Lower Byte</td>
<td>Trim Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16UpperTrim_X</td>
</tr>
<tr class="row-even"><td>[TrackPad Lower Trim Y-axis]</td>
<td>6B</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Trim Lower Byte</td>
<td>Trim Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16UpperTrim_Y</td>
</tr>
<tr class="row-odd"><td>[TrackPad Upper Trim Y-axis]</td>
<td>6C</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Trim Lower Byte</td>
<td>Trim Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16UpperTrim_Y</td>
</tr>
<tr class="row-even"><td>[TrackPad Tap Time Min]</td>
<td>70</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Min Lower Byte</td>
<td>Min Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16TapTime_Min</td>
</tr>
<tr class="row-odd"><td>[TrackPad Tap Time Max]</td>
<td>71</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Max Lower Byte</td>
<td>Max Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16TapTime_Max</td>
</tr>
<tr class="row-even"><td>[TrackPad Swipe Time Max]</td>
<td>72</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Max Lower Byte</td>
<td>Max Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16SwipeTime_Max</td>
</tr>
<tr class="row-odd"><td>[TrackPad Double Tap Time Max]</td>
<td>73</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Max Lower Byte</td>
<td>Max Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16DoubleTapTime_Max</td>
</tr>
<tr class="row-even"><td>[TrackPad Tap and Hold Time Min]</td>
<td>74</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Min Lower Byte</td>
<td>Min Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16TapHoldTime_Min</td>
</tr>
<tr class="row-odd"><td>[TrackPad Swipe Distance Min]</td>
<td>75</td>
<td>RW</td>
<td>Sensor ID</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Min Lower Byte</td>
<td>Min Upper Byte</td>
<td>NA</td>
<td>tTrackPadSensorParams</td>
<td>ui16SwipeDistance_Min</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="controller-management-parameters">
<h5>Controller/Management Parameters<a class="headerlink" href="#controller-management-parameters" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="13%" />
<col width="13%" />
<col width="4%" />
<col width="9%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter Name</th>
<th class="head">Byte 0: CMD</th>
<th class="head">Byte 1: RW</th>
<th class="head">Byte 2: ID</th>
<th class="head">Byte 3</th>
<th class="head">Byte 4</th>
<th class="head">Byte 5</th>
<th class="head">Byte 6</th>
<th class="head">MCU Task</th>
<th class="head">SW Containing Structure</th>
<th class="head">SW Containing Variable</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#communications">Element Data Transmit Enable</a></td>
<td>C0</td>
<td>RW</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Element Transmit Enable</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tCaptivateApplication</td>
<td>bElementDataTxEnable</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#communications">Sensor Data Transmit Enable</a></td>
<td>C1</td>
<td>RW</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Sensor Transmit Enable</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tCaptivateApplication</td>
<td>bSensorDataTxEnable</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#system-report-rate">Active Mode Scan Rate (ms)</a></td>
<td>C2</td>
<td>RW</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Active Report Period (ms) Lower Byte</td>
<td>Active Report Period (ms) Upper Byte</td>
<td>NA</td>
<td>tCaptivateApplication</td>
<td>ui16ActiveModeScanPeriod</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#system-wake-on-proximity-mode">Wake-on-Prox Mode Scan Rate (ms)</a></td>
<td>C3</td>
<td>RW</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>WoP Report Period (ms) Lower Byte</td>
<td>WoP Report Period (ms) Upper Byte</td>
<td>NA</td>
<td>tCaptivateApplication</td>
<td>ui16WakeOnProxModeScanPeriod</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="ch_glossary.html#system-wake-on-proximity_mode">Wakeup Interval</a></td>
<td>C4</td>
<td>RW</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Wakeup Interval</td>
<td>Don&#8217;t Care</td>
<td>NA</td>
<td>tCaptivateApplication</td>
<td>ui8WakeupInterval</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="ch_glossary.html#system-wake-on-proximity-mode">Inactivity Timeout</a></td>
<td>C5</td>
<td>RW</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Don&#8217;t Care</td>
<td>Timeout Lower Byte</td>
<td>Timeout Upper Byte</td>
<td>NA</td>
<td>tCaptivateApplication</td>
<td>ui16InactivityTimeout</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="uart-driver">
<h3>UART Driver<a class="headerlink" href="#uart-driver" title="Permalink to this headline">¶</a></h3>
<p>The MSP430 eUSCI_A UART Driver provides a simple UART API to MSP430 applications, enabling interrupt-driven transmit and receive operations as well as error handling. This section provides an overview of the driver&#8217;s features, architecture, and API. This document assumes that the reader is familiar with the MSP430 MCU architecture, as well as embedded C programming concepts.</p>
<div class="section" id="related-documents">
<h4>Related Documents<a class="headerlink" href="#related-documents" title="Permalink to this headline">¶</a></h4>
<p>This document should be used with the following additional supporting documentation. The MSP430 Driver Library API is not specific to this driver, and has its own documentation.</p>
<ul class="simple">
<li>MSP430 Driver Library (DriverLib) User&#8217;s Guide</li>
<li>The relevant MSP430 Family User&#8217;s Guide</li>
</ul>
</div>
<div class="section" id="purpose-of-the-driver">
<h4>Purpose of the Driver<a class="headerlink" href="#purpose-of-the-driver" title="Permalink to this headline">¶</a></h4>
<p>The eUSCI_A UART Driver enables developers to quickly get up and running with UART communication via an API that is similar to one used on a PC. The API provides simple functions such as UART_openPort() and UART_transmitBuffer(), and it allows the developer to register event handlers for received data and error conditions. To enable portability, the driver is built upon the MSP430 DriverLib register abstraction. This driver has been designed to work with MSP430 DriverLib build 1.90.00.00 and greater. Like any other serial interface, UART has benefits and drawbacks. Whether or not it is the best choice for an embedded interface depends on a number of factors. The benefits and drawbacks of UART are discussed below.</p>
<p>UART Benefits</p>
<ul class="simple">
<li>Ease of implementation. UART is one of the most common serial communication protocols around. While interfaces with higher speed and higher reliability exist, such as I2C and SPI, none match UART for ease of implementation. UART is easily interfaced to a host PC or another microcontroller, and as such it is well suited for use as a debug console.</li>
<li>Point-to-point simplicity. Since only two nodes exist, the interface is not a bus with multiple devices attached. This removes the need for addressing or chip-select overhead.</li>
<li>Full duplex communication. In this UART driver implementation, transmit and receive operations are decoupled and may occur concurrently. Each of the two connected nodes may consider itself a master, and may begin transmission to the other node at any time.</li>
</ul>
<p>UART Drawbacks</p>
<ul class="simple">
<li>Critical bit timing. Because UART transmission is asynchronous (there is no bit clock), accurate timing must be guaranteed on both sides of the interface.</li>
<li>Bit rate limitation. Due to the critical bit timing above, UART is typically more limited in maximum bit clock then when compared with a synchronous interface, such as SPI or I2C.</li>
<li>Critical ISR timing. This driver does not employ the use of a DMA channel for moving data from transmit and receive buffers into RAM, as not all devices are equipped with a DMA engine.</li>
</ul>
<p>Instead of DMA, all data transfers are handled via interrupt service routines. This means that the CPU must be available to service receive interrupts at least every byte period. A byte period is defined as the transmission time for one byte, which is equal to 10 times the bit period. Note that the byte transmission time increases if parity or more than one stop bit is used. For example, if the bit clock is 250 kHz, the transmission time of one byte is 4us times 10 bits, or 40us. With an 8MHz CPU clock, there are only 320 instruction cycles available every 40us. If the CPU is not available to service receive interrupts, received bytes may be lost. The driver provides an error detection mechanism to alert the application if and when data is being lost. - Asynchronous overhead. UART as configured in this driver requires at least one start bit and one stop bit. As such, each 8-bit byte requires that 10 bits be sent. This overhead would not be present in a SPI interface, although I2C does
impose an ACK/NACK bit as well as addressing overhead.</p>
</div>
<div class="section" id="driver-features">
<h4>Driver Features<a class="headerlink" href="#driver-features" title="Permalink to this headline">¶</a></h4>
<p>The key features implemented in the UART driver are listed below.</p>
<ul class="simple">
<li>Full duplex bi-directional communication</li>
<li>No flow control required</li>
<li>Fully interrupt-driven</li>
<li>Non-blocking transmit function</li>
<li>Receive event callback</li>
<li>Error event callback</li>
<li>Compile-time selection of which eUSCI_A instance to use</li>
</ul>
</div>
<div class="section" id="driver-overview">
<h4>Driver Overview<a class="headerlink" href="#driver-overview" title="Permalink to this headline">¶</a></h4>
<p>The UART driver is provided in source code. The driver consists of three source files:</p>
<ul class="simple">
<li>UART_Definitions.h (Configuration header file)</li>
<li>UART.h (API Header file)</li>
<li>UART.c (API Implementation file)</li>
</ul>
<p>The core driver is implemented in UART.h and UART.c. The UART_Definitions.h file allows the developer to adjust the driver&#8217;s compile-time options.</p>
<p>The UART driver requires the following hardware resources:</p>
<ul class="simple">
<li>One eUSCI_A peripheral instantiation</li>
<li>Two device pins (UCAxTXD and UCAxRXD), where &#8216;x&#8217; represents the selected eUSCI_A instance</li>
</ul>
<p>The UART driver API is composed of functions and data types. The sections below describe how to configure the UART driver and use it to perform transmit and receive operations.</p>
<p>The UART driver employs a basic software state machine to manage operations. The three driver states and their interconnection are shown in the diagram below.</p>
<div class="figure" id="id72">
<img alt="UART Driver State Machine" src="../_images/lib_comm_uartdriverstatemachine.png" />
<p class="caption"><span class="caption-number">Fig. 224 </span><span class="caption-text">UART Driver State Machine</span></p>
</div>
</div>
<div class="section" id="compile-time-driver-configuration-options">
<h4>Compile-time Driver Configuration Options<a class="headerlink" href="#compile-time-driver-configuration-options" title="Permalink to this headline">¶</a></h4>
<p>The UART driver has compile-time options as well as run-time configurable options. Certain things must be known at compile-time, such as which eUSCI_A peripheral instance is associated with the driver. Other options, such as baud rate, may be controlled at runtime.</p>
<p>The compile-time configuration options are set in the UART_Definitions.h file. The available compile-time options are described below.</p>
<div class="section" id="uart-enable-definition">
<h5>UART Enable Definition<a class="headerlink" href="#uart-enable-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="40%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UART__ENABLE</td>
<td>UART_Definitions.h</td>
<td>true, false</td>
</tr>
</tbody>
</table>
<p>The UART Enable compile-time option selects whether the UART Driver is enabled or disabled. This provides a mechanism to exclude the driver from the compilation process. To include the driver, define UART__ENABLE as true. Else, define it as false.</p>
</div>
<div class="section" id="uart-eusci-a-peripheral-selection-definition">
<h5>UART eUSCI_A Peripheral Selection Definition<a class="headerlink" href="#uart-eusci-a-peripheral-selection-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="25%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UART__EUSCI_A_PERIPHERAL</td>
<td>UART_Definitions.h</td>
<td>EUSCI_A0_BASE, EUSCI_A1_BASE</td>
</tr>
</tbody>
</table>
<p>The UART eUSCI_A peripheral selection allows easy selection of which eUSCI_A instance to associate with the UART driver. This provides flexibility during design if a pin-mux change is necessary. A valid base address must be provided.When a eUSCI_A peripheral selection is made, the UART driver ISR address is linked to the appropriate eUSCI interrupt vector automatically. If an invalid address is selected, a compiler error is thrown.</p>
</div>
<div class="section" id="uart-low-power-mode-lpmx">
<h5>UART Low Power Mode (LPMx)<a class="headerlink" href="#uart-low-power-mode-lpmx" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="23%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UART__LPMx_bits</td>
<td>UART_Definitions.h</td>
<td>0, LPM0_bits, LPM1_bits, LPM2_bits, LPM3_bits</td>
</tr>
</tbody>
</table>
<p>UART communications is often performed in a low power mode. The UART LPM Mode configuration is used in three ways, as described below.</p>
<ul class="simple">
<li>The receive callback and error callback functions may trigger an active exit from a low power mode to wake the CPU for further action. If a callback function returns a Boolean true, the UART driver will wake the CPU after returning from the callback. It does this by clearing the status register bits indicated in the UART LPM Mode configuration upon exit from the UART ISR.</li>
<li>A transmit operation will exit the low power mode specified by the UART LPM Mode configuration once the full transmission is complete, to allow the application to know that the transmission was completed.</li>
<li>The transmit function is normally a non-blocking function. Once transmission begins, the function returns. However, in the event that a previous transmission was still in progress when the transmit function was called, there is an option to wait for the previous transmission to complete inside of a low power mode. If that option is selected, the low power mode specified by the UART LPM Mode configuration will be entered while waiting. The transmit function will know to begin transmission when the previous transmission exits active (per number 2 above).</li>
</ul>
</div>
</div>
<div class="section" id="run-time-driver-configuration-options">
<h4>Run-time Driver Configuration Options<a class="headerlink" href="#run-time-driver-configuration-options" title="Permalink to this headline">¶</a></h4>
<p>The UART driver has compile-time options as well as run-time configurable options. The runtime configuration options are specified by populating a tUARTPort structure in the application, and passing this structure to the driver when opening the driver. A tUARTPort structure is required when opening the UART driver. The tUARTPort structure must be available in memory whenever the driver is open. This is a result of the fact that the UART driver references this structure at runtime to find the callback functions for receive handling and error handling. However, the driver does not modify the data in the structure at any time, and as such, the structure may be placed in a read-only memory section (such as C const memory). These parameters are considered runtime adjustable because the parameters may be modified by the application if the UART driver is closed first, then re-opened. For example, the application may change the UART baud rate by closing the port, changing the baud rate options
on the tUARTPort structure, and re-opening the port. Note that the .peripheralParameters member of the tUARTPort structure is a EUSCI_A_UART_initParam structure from the MSP430 Driver Library.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="41%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Member</th>
<th class="head">Description</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>bool (*pbReceiveCallback)(uint8_t)</td>
<td>pbReceiveCallback is a function pointer that may point to a receive event handler. If no receive handling is required, initialize this member to 0 (null).</td>
<td>Null, or a valid function address.</td>
</tr>
<tr class="row-odd"><td>bool (*pbErrorCallback)(uint8_t)</td>
<td>pbErrorCallback is a function pointer that may point to an error event handler. If no error handling is required, initialize this member to 0 (null).</td>
<td>Null, or a valid function address.</td>
</tr>
<tr class="row-even"><td>.peripheralParameters.selectClockSource</td>
<td>This member specifies the clock source for the eUSCI_A peripheral.</td>
<td>EUSCI_A_UART_CLOCKSOURCE_SMCLK, EUSCI_A_UART_CLOCKSOURCE_ACLK</td>
</tr>
<tr class="row-odd"><td>.peripheralParameters.clockPrescalar</td>
<td>This member specifies the eUSCI_A clock prescalar. This affects the baud rate.</td>
<td>0-65535</td>
</tr>
<tr class="row-even"><td>.peripheralParameters.firstModReg</td>
<td>This member specifies the eUSCI_A first stage modulation. This affects the baud rate.</td>
<td>0-15</td>
</tr>
<tr class="row-odd"><td>.peripheralParameters.secondModReg</td>
<td>This member specifies the eUSCI_A second stage modulation. This affects the baud rate.</td>
<td>0-255</td>
</tr>
<tr class="row-even"><td>.peripheralParameters.parity</td>
<td>This member specifies the UART parity mode.</td>
<td>EUSCI_A_UART_NO_PARITY, EUSCI_A_UART_ODD_PARITY, EUSCI_A_UART_EVEN_PARITY</td>
</tr>
<tr class="row-odd"><td>.peripheralParameters.msborLsbFirst</td>
<td>This member specifies the transmission bit order.</td>
<td>EUSCI_A_UART_LSB_FIRST, EUSCI_A_UART_MSB_FIRST</td>
</tr>
<tr class="row-even"><td>.peripheralParameters.numberofStopBits</td>
<td>This member specifies the number of stop bits.</td>
<td>EUSCI_A_UART_ONE_STOP_BIT, EUSCI_A_UART_TWO_STOP_BITS</td>
</tr>
<tr class="row-odd"><td>.peripheralParameters.uartMode</td>
<td>This member specifies the UART mode.</td>
<td>EUSCI_A_UART_MODE, EUSCI_A_UART_IDLE_LINE_MULTI_PROCESSOR_MODE, EUSCI_A_UART_ADDRESS_BIT_MULTI_PROCESSOR_MODE, EUSCI_A_UART_AUTOMATIC_BAUDRATE_DETECTION_MODE</td>
</tr>
<tr class="row-even"><td>.peripheralParameters.overSampling</td>
<td>This member specifies whether UART oversampling is enabled.</td>
<td>EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION, EUSCI_A_UART_LOW_FREQUENCY_BAUDRATE_GENERATION</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="using-the-driver-opening-and-closing-the-driver">
<h4>Using the Driver: Opening and Closing the Driver<a class="headerlink" href="#using-the-driver-opening-and-closing-the-driver" title="Permalink to this headline">¶</a></h4>
<p>Opening and closing of the UART driver is accomplished through the following function calls:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Open the UART Port</td>
<td>extern void UART_openPort(const tUARTPort *pPort)</td>
</tr>
<tr class="row-odd"><td>Close the UART Port</td>
<td>extern void UART_closePort(void)</td>
</tr>
</tbody>
</table>
<p>The UART driver is opened and initialized by a call to <strong>UART_openPort()</strong>, which is passed a completed tUARTPort structure. The tUARTPort structure must be populated by the application. It may be placed in read-only memory, as the UART API does not modify the structure at any time; rather, it only references it. It is important that the structure be left in memory at the address given when <strong>UART_openPort()</strong> is called, as the UART API will reference this structure to access callback functions when the port is open. If the memory must be freed, first close the UART port with a call to <strong>UART_closePort()</strong>.</p>
<p>A call to <strong>UART_closePort()</strong> will disable the UART port and its associated eUSCI_A peripheral, halting all Rx/Tx interrupt activity. After the port is closed, the event handlers will no longer be called, and the tUARTPort structure memory may be released to the application.</p>
<p><strong>Opening a Port</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span>
<span class="o">//</span> <span class="n">g_myUartPort</span> <span class="n">specifies</span> <span class="n">the</span> <span class="n">UART</span> <span class="n">port</span> <span class="n">configuration</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">passed</span>
<span class="o">//</span> <span class="n">to</span> <span class="n">the</span> <span class="n">UART</span> <span class="n">port</span> <span class="n">driver</span> <span class="n">during</span> <span class="n">init</span><span class="o">.</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">UART</span> <span class="n">configuration</span> <span class="ow">is</span> <span class="mi">9600</span><span class="n">B8N1</span><span class="p">,</span> <span class="n">sourced</span> <span class="n">by</span> <span class="n">a</span> <span class="mi">4</span><span class="n">MHz</span> <span class="n">SMCLK</span><span class="o">.</span>
<span class="o">//</span>
<span class="n">const</span> <span class="n">tUARTPort</span> <span class="n">g_myUartPort</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">.</span><span class="n">pbReceiveCallback</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">receiveHandler</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pbErrorCallback</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">errorHandler</span><span class="p">,</span>
    <span class="o">.</span><span class="n">peripheralParameters</span><span class="o">.</span><span class="n">selectClockSource</span> <span class="o">=</span> <span class="n">EUSCI_A_UART_CLOCKSOURCE_SMCLK</span><span class="p">,</span>
    <span class="o">.</span><span class="n">peripheralParameters</span><span class="o">.</span><span class="n">clockPrescalar</span> <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>
    <span class="o">.</span><span class="n">peripheralParameters</span><span class="o">.</span><span class="n">firstModReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">.</span><span class="n">peripheralParameters</span><span class="o">.</span><span class="n">secondModReg</span> <span class="o">=</span> <span class="mh">0xB6</span><span class="p">,</span>
    <span class="o">.</span><span class="n">peripheralParameters</span><span class="o">.</span><span class="n">parity</span> <span class="o">=</span> <span class="n">EUSCI_A_UART_NO_PARITY</span><span class="p">,</span>
    <span class="o">.</span><span class="n">peripheralParameters</span><span class="o">.</span><span class="n">msborLsbFirst</span> <span class="o">=</span> <span class="n">EUSCI_A_UART_LSB_FIRST</span><span class="p">,</span>
    <span class="o">.</span><span class="n">peripheralParameters</span><span class="o">.</span><span class="n">numberofStopBits</span> <span class="o">=</span> <span class="n">EUSCI_A_UART_ONE_STOP_BIT</span><span class="p">,</span>
    <span class="o">.</span><span class="n">peripheralParameters</span><span class="o">.</span><span class="n">uartMode</span> <span class="o">=</span> <span class="n">EUSCI_A_UART_MODE</span><span class="p">,</span>
    <span class="o">.</span><span class="n">peripheralParameters</span><span class="o">.</span><span class="n">overSampling</span> <span class="o">=</span> <span class="n">EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION</span>
<span class="p">};</span>

<span class="n">UART_openPort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_myUartPort</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-driver-transmitting-data">
<h4>Using the Driver: Transmitting Data<a class="headerlink" href="#using-the-driver-transmitting-data" title="Permalink to this headline">¶</a></h4>
<p>Data transmission is accomplished through the following function calls:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Transmit a Buffer</td>
<td>extern void UART_transmitBuffer(const uint8_t *pBuffer, uint16_t ui16Length)</td>
</tr>
<tr class="row-odd"><td>Transmit a Byte</td>
<td>extern void UART_transmitByteImmediately(uint8_t ui8Data)</td>
</tr>
<tr class="row-even"><td>Get Port Status</td>
<td>extern uint8_t UART_getPortStatus(void)</td>
</tr>
</tbody>
</table>
<p>Transmit operations are interrupt driven. To initiate a transmission after opening the UART port, make a call to <strong>UART_transmitBuffer()</strong>. This function is simply passed a pointer to the buffer to transmit, and the length of the buffer to transmit (specified in bytes). If the eUSCI_A peripheral is available, transmission will begin immediately and the function will return. If the peripheral is still busy sending a previous transmission, it will block (in a low power mode, if specified in UART_Definitions.h) until the previous transmission is complete.</p>
<p><strong>Transmitting a Buffer</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">UART_transmitBuffer</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\r</span><span class="s2">Hello World!</span><span class="se">\n\r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\r</span><span class="s2">Hello World!</span><span class="se">\n\r</span><span class="s2">&quot;</span><span class="p">));</span>
</pre></div>
</div>
<div class="figure" id="id73">
<img alt="UART Transmit Flow Diagram" src="../_images/lib_comm_uartdrivertxflow.png" />
<p class="caption"><span class="caption-number">Fig. 225 </span><span class="caption-text">UART Transmit Flow Diagram</span></p>
</div>
<p>The transmit operation uses the buffer memory that was pointed to in the <strong>UART_transmitBuffer()</strong> function - it does not perform a data copy in the name of efficiency. As such, that memory must not be modified during the transmission, or the transmission will be invalid. To detect when transmission has completed and the memory is again available, it is possible to check the UART port status via a call to <strong>UART_getPortStatus()</strong>. If an application will be re-using buffer space, it is best to employ a ping-pong buffer strategy so that a new packet may be assembled while a previous packet is being sent.</p>
<p>A call to <strong>UART_getPortStatus()</strong> returns one of the values enumerated by tUARTStates. The options are described below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Port Status Option</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>eUARTIsClosed</td>
<td>The UART driver is not currently open, and is neither receiving nor transmitting data.</td>
</tr>
<tr class="row-odd"><td>eUARTIsIdle</td>
<td>The UART driver is currently open, but is not in the process of transmitting a buffer.</td>
</tr>
<tr class="row-even"><td>eUARTIsTransmitting</td>
<td>The UART driver is currently open, and is in the process of transmitting a buffer.</td>
</tr>
</tbody>
</table>
<p>If only a single byte is going to be sent, it is possible to send it immediately via the <strong>UART_transmitByteImmediately()</strong> function. This function sends a single byte as soon as the eUSCI_A peripheral transmit buffer is available. It will block until the buffer is available. If a transmission started by a call to <strong>UART_transmitBuffer()</strong> is in progress, this transfer may finish first as it is interrupt-driven. The <strong>UART_transmitByteImmediately()</strong> function is mainly available to be used in terminal emulator applications, where sent ASCII characters are echoed back to be visible to the user.</p>
<p><strong>Transmitting a Single Byte</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">uint8_t</span> <span class="n">ui8Data</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
<span class="n">UART_transmitByteImmediately</span><span class="p">(</span><span class="n">ui8Data</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-driver-receiving-data">
<h4>Using the Driver: Receiving Data<a class="headerlink" href="#using-the-driver-receiving-data" title="Permalink to this headline">¶</a></h4>
<p>Received data is passed to the application through the use of the receive callback. The UART driver will call a user-defined function every time a new byte is received from the UART peripheral, passing that byte to the receive callback. It is then up to the application to decide how to handle the data. It is recommended to use a ring-buffer FIFO queue to handle buffering incoming data. The data may then be extracted and processed in a background process. The receive event handler is called from the UART ISR in the UART driver, and as such, the event handler should be kept as short as possible. It is recommended to follow the same practice used to write ISR&#8217;s when writing event handlers.</p>
<p>The receive callback function is linked to the driver by placing its address in the pbReceiveCallback member of the tUARTPort structure. If the application does not wish to listen for receive events, the receive callback pointer in the tUARTPort structure may be initialized to null. Receive operations are performed entirely out of the ISR. The receive operation ISR flow is shown below. <a class="reference external" href="ch_library.html#using-th-driver-error-handling">Errors</a> are checked for whenever a receive interrupt is serviced.</p>
<div class="figure" id="id74">
<img alt="UART Receive Flow Diagram" src="../_images/lib_comm_uartdriverrxflow.png" />
<p class="caption"><span class="caption-number">Fig. 226 </span><span class="caption-text">UART Receive Flow Diagram</span></p>
</div>
</div>
<div class="section" id="using-the-driver-error-handling">
<h4>Using the Driver: Error Handling<a class="headerlink" href="#using-the-driver-error-handling" title="Permalink to this headline">¶</a></h4>
<p>The UART driver employs basic UART error detection to alert the application when something has gone wrong. The two errors detected by the driver are:</p>
<ol class="arabic simple">
<li>UART Receive Buffer Overrun. This occurs if a new byte is placed into the eUSCI_A UART receive buffer before a previous byte was read out. This occurs when there is not enough CPU bandwidth to read out data at the rate data is coming into the peripheral. To resolve this error during development, it is necessary to either: slow down the rate at which data is received, whether through delays between bytes or a lower baud rate, or to increase the CPU availability by shortening interrupt handlers or increasing the CPU clock frequency. The enumerated error flag is eUARTOverrunError.</li>
<li>UART Framing Error. This typically occurs if there is a baud rate mismatch between devices. The enumerated error flag is eUARTFramingError. The driver alerts the application via the error callback function. This works similar to the receive callback, except the error code is passed rather than the received byte. The error callback function is called from the UART ISR, and as such, it should be kept as short as possible. The error callback function is linked to the driver by placing its address in the pbErrorCallback member of the tUARTPort structure. If the application does not wish to listen for error events, the error callback pointer in the tUARTPort structure may be initialized to null.</li>
</ol>
</div>
<div class="section" id="using-the-driver-example-application">
<h4>Using the Driver: Example Application<a class="headerlink" href="#using-the-driver-example-application" title="Permalink to this headline">¶</a></h4>
<p>This example listens for a ASCII line on eUSCI_A0. When a line is received, it is echoed back. The baud rate is 9600-8N1. The max line size is 64 bytes.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>##include &quot;driverlib.h&quot;
##include &quot;UART.h&quot;

//
// DCO_FREQ defines the MSP430 DCO frequency in Hz
//
##define DCO_FREQ               8000000

//
// REFO_FREQ defines the REFO frequency in Hz
//
##define REFO_FREQ              32768

//
// RECEIVE_BUFFER_SIZE defines the size of the UART receive buffer.
//
##define RECEIVE_BUFFER_SIZE        64

//
// g_ui8ReceiveBuffer is the UART receive buffer. It is filled with
// incoming characters via the UART receive event handler.
//
uint8_t g_ui8ReceiveBuffer[RECEIVE_BUFFER_SIZE];

//
// g_ui8ReceiveIndex is the UART receive buffer index. It defines the
// buffer index that the next received byte is placed into.
//
uint8_t g_ui8ReceiveIndex;

//
// g_bGotNewLine is a flag used by the UART receive event handler to
// signal the background loop (the main application thread) that a full
// ASCII line has been received in the buffer.
//
bool g_bGotNewLine = false;

//
// The UART receive handler is called by the UART port driver whenever a new
// character is received.
//
bool receiveHandler(uint8_t ui8Data)
{
    if (g_bGotNewLine == false)
    {
        if (g_ui8ReceiveIndex&lt;RECEIVE_BUFFER_SIZE)
        {
            //
            // It is safe to receive the new character into the buffer.
            // If the data is a ASCII return, signal the background app
            // and exit awake.
            //
            g_ui8ReceiveBuffer[g_ui8ReceiveIndex++] = ui8Data;
            if (ui8Data==&#39;\r&#39;)
            {
                g_bGotNewLine = true;
                return true;
            }
            else
            {
                UART_transmitByteImmediately(ui8Data);
            }
        }
        else
        {
            //
            // The buffer is full, return new line to print what
            // we have right now
            //
            g_bGotNewLine = true;
            return true;
        }
    }
    return false;
}

//
// The UART error handler is called by the UART port driver whenever an
// error on the UART port is detected.
// The application could handle errors here if desired (such as a UART buffer
// overrun or framing error).
//
//
bool errorHandler(uint8_t ui8Error)
{
    return false;
}

//
// g_myUartPort specifies the UART port configuration that is passed
// to the UART port driver during init.
// The UART configuration is 9600B8N1, sourced by SMCLK.
//
const tUARTPort g_myUartPort =
{
    .pbReceiveCallback = &amp;receiveHandler,
    .pbErrorCallback = &amp;errorHandler,
    .peripheralParameters.selectClockSource = EUSCI_A_UART_CLOCKSOURCE_SMCLK,
    .peripheralParameters.clockPrescalar = 26,
    .peripheralParameters.firstModReg = 0,
    .peripheralParameters.secondModReg = 0xB6,
    .peripheralParameters.parity = EUSCI_A_UART_NO_PARITY,
    .peripheralParameters.msborLsbFirst = EUSCI_A_UART_LSB_FIRST,
    .peripheralParameters.numberofStopBits = EUSCI_A_UART_ONE_STOP_BIT,
    .peripheralParameters.uartMode = EUSCI_A_UART_MODE,
    .peripheralParameters.overSampling = EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION
};

//
// Application main()
//
void main(void)
{
    //
    // Set up the MCU with a 8MHz MCLK, 4MHz SMCLK, and ~32.768kHz ACLK.
    //
    WDT_A_hold(WDT_A_BASE);
    CS_clockSignalInit(CS_FLLREF, CS_REFOCLK_SELECT, CS_CLOCK_DIVIDER_1);
    CS_initFLLSettle(DCO_FREQ/1000, DCO_FREQ/REFO_FREQ);
    CS_clockSignalInit(CS_MCLK, CS_DCOCLKDIV_SELECT, CS_CLOCK_DIVIDER_1);
    CS_clockSignalInit(CS_SMCLK, CS_DCOCLKDIV_SELECT, CS_CLOCK_DIVIDER_2);
    CS_clockSignalInit(CS_ACLK, CS_REFOCLK_SELECT, CS_CLOCK_DIVIDER_1);
    __delay_cycles(8000000);

    //
    // Set P1.0 and P1.1 to UCA0TXD and UCA0RXD, respectively.
    //
    PM5CTL0 &amp;= ~LOCKLPM5;
    GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P1, GPIO_PIN4, GPIO_PRIMARY_MODULE_FUNCTION);
    GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P1, GPIO_PIN5, GPIO_PRIMARY_MODULE_FUNCTION);

    //
    // Enable masked interrupts.
    //
    __bis_SR_register(GIE);

    //
    // Open the UART port and send the welcome message!
    //
    UART_openPort(&amp;g_myUartPort);
    UART_transmitBuffer(&quot;\n\rHello World!\n\r&quot;, sizeof(&quot;\n\rHello World!\n\r&quot;));
    UART_transmitBuffer(&quot;Waiting for a new line... &quot;, sizeof(&quot;Waiting for a new line... &quot;));

    //
    // Application background loop
    //
    while(1)
    {
        //
        // If a new line was received, echo it back!
        //
        if (g_bGotNewLine == true)
        {
            UART_transmitBuffer(&quot;\n\rReceived: &quot;, sizeof(&quot;\n\rReceived: &quot;));
            UART_transmitBuffer(g_ui8ReceiveBuffer, g_ui8ReceiveIndex);
            UART_transmitBuffer(&quot;\n\r&quot;, sizeof(&quot;\n\r&quot;));
            UART_transmitBuffer(&quot;Waiting for a new line: &quot;, sizeof(&quot;Waiting for a new line: &quot;));
            g_ui8ReceiveIndex = 0;
            g_bGotNewLine = false;
        }

        //
        // Sleep in LPM0 (CPU off, DCO on).
        // The UART receive event handler will
        // wake up the background loop if a line is received.
        //
        LPM0;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="using-the-driver-backchannel-uart-to-serial-terminal">
<h4>Using the Driver: Backchannel UART to Serial Terminal<a class="headerlink" href="#using-the-driver-backchannel-uart-to-serial-terminal" title="Permalink to this headline">¶</a></h4>
<p>This section shows the developers how to use the CAPTIVATE development kit to design using their own customizable UART data streaming format. Developers following this section can watch their device’s output directly in the serial terminal using UART.</p>
<p>This example outputs to the serial terminal which button was pressed, its raw count and it filtered count when a button is pressed. This example uses CAPTIVATE-BSWP board as the sensor board but you can apply the same implementation on any sensor designs.</p>
<p><strong>Hardware Setup:</strong></p>
<p>The hardware setup for using the backchannel UART requires the CAPTIVATE-BSWP, the CAPTIVATE-PGMR and the CAPTIVATE-FR2633, which are all included in the MSP CapTIvate MCU Development Kit. The user will also need a micro-USB cable to connect the CAPTIVATE-PGMR to the PC terminal and 4 male-female wires to connect the two boards for power and communication.</p>
<p><strong>CAPTIVATE-PGMR Connector (20 pin Male)</strong></p>
<div class="figure" id="id75">
<img alt="Programmer Connector pinout" src="../_images/evm_male_20P_connector.png" />
<p class="caption"><span class="caption-number">Fig. 227 </span><span class="caption-text">Programmer Connector pinout</span></p>
</div>
<p><strong>CAPTIVATE-FR2633 Connector (20 pin Female)</strong></p>
<div class="figure" id="id76">
<img alt="Programming and Communications Pinout" src="../_images/evm_female_20P_connector.png" />
<p class="caption"><span class="caption-number">Fig. 228 </span><span class="caption-text">Programming and Communications Pinout</span></p>
</div>
<p>The table below shows the relevant connection of CAPTIVATE-PGMR board and CAPTIVATE-FR2633 board for HID bridge communication. This is the default setting when you simply connect the CAPTIVATE-PGMR board together with the CAPTIVATE-FR2633 board using on board connector. This will enable the output of the FR2633 board to go through the HID bridge and to the CapTIvate Design Center GUI.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">CAPTIVATE-PGMR Board</th>
<th class="head">CAPTIVATE-FR2633 Board</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GND (20)</td>
<td>GND(2)</td>
</tr>
<tr class="row-odd"><td>+3.3v (18)</td>
<td>3.3V LDO(4)</td>
</tr>
<tr class="row-even"><td>HID BRIDGE UART RXD(8)</td>
<td>BRIDGE UART RXD (14)</td>
</tr>
<tr class="row-odd"><td>HID BRIDGE UART TXD(7)</td>
<td>BRIDGE UART TXD (13)</td>
</tr>
</tbody>
</table>
<p>The table below shows the relevant connection of CAPTIVATE-PGMR board and CAPTIVATE-FR2633 board for eZ-FET Backchannel UART communication.To enable backchannel UART communication, these pins must be connected with separate wires because the pins do not line up with each other with the onboard connector. Note the key difference is the pins that would be connected to the HID bridge are now connected to the eZ-FET lines instead.</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">CAPTIVATE-PGMR Board</th>
<th class="head">CAPTIVATE-FR2633 Board</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GND (20)</td>
<td>GND(2)</td>
</tr>
<tr class="row-odd"><td>+3.3v (18)</td>
<td>3.3V LDO(4)</td>
</tr>
<tr class="row-even"><td>eZ-FET UART RXD(12)</td>
<td>BRIDGE UART RXD (14)</td>
</tr>
<tr class="row-odd"><td>eZ-FET UART TXD(11)</td>
<td>BRIDGE UART TXD (13)</td>
</tr>
</tbody>
</table>
<p><strong>Software Setup:</strong></p>
<p>A software example project named &#8220;Backchannel_UART&#8221; is included in CapTIvate Design Center version 1.7 or later. On Windows 7, this would be C:/Users/”username”/CaptivateDesignCenter_1_XX_XX_XX/CaptivateDesignCenterWorkspace/Backchannel_UART</p>
<p>The project base code is generated from the CapTIvate Design Center Backchannel_UART project with additional application code added to configure the UART communication peripheral as well as transmitting the user defined sensor data.</p>
<p>In this software project, the communication to CapTIvate Design Center GUI is disabled but in order to leverage the UART peripheral driver library come with the project for backchannel UART communication we need to set the predefined symbols UART_ENABLE to True. To do that, go to CCS Project Properties -&gt; Build -&gt; MSP430 Compiler -&gt; Predefined Symbols -&gt; Add &#8220;UART__ENABLE=true&#8221; as the image shown below.</p>
<div class="figure" id="id77">
<img alt="Set Predefined Symbol UART\_\_ENABLE=true" src="../_images/uart_enable_true.png" />
<p class="caption"><span class="caption-number">Fig. 229 </span><span class="caption-text">Set Predefined Symbol UART__ENABLE=true</span></p>
</div>
<p>In this example, it uses a baud rate of 9600 bits/sec it can be modified in the application code. The data output format can also easily being customized in the application code.</p>
<p><strong>Output Example:</strong></p>
<p>Below is the example output to the serial terminal from the program when the sequence “5-4-4” was pressed on the CAPTIVATE-BSWP board.</p>
<p>Button Pressed: 5, Raw Count: 219, Filtered Count: 221</p>
<p>Button Pressed: 4, Raw Count: 224, Filtered Count: 225</p>
<p>Button Pressed: 4, Raw Count: 218, Filtered Count: 220</p>
<p>Upon start-up, when all of the hardware is configured correctly, the system should broadcast the data requested directly to the terminal, assuming the terminal is set up correctly. Ensure that the baud rate, parity bits, stop bits and character encoding are correct if data transmission does not happen as expected. Based on this example, the user can customize the output of the sensor data directly to a serial terminal using UART.</p>
</div>
</div>
<div class="section" id="i2c-slave-driver">
<h3>I2C Slave Driver<a class="headerlink" href="#i2c-slave-driver" title="Permalink to this headline">¶</a></h3>
<p>The MSP430 eUSCI_B I2C slave driver provides a simple I2C slave API to MSP430 applications, enabling interrupt-driven I2C read/write operations as well as bus timeout detection and driver error handling. This User&#8217;s Guide provides an overview of the driver&#8217;s features, architecture, and API. This document assumes that the reader is familiar with MSP430 MCU architecture, as well as embedded C programming concepts and basic I2C principles. Note: From this point forward, the I2C slave driver will simply be referred to as &#8220;the driver.&#8221;</p>
<div class="section" id="id8">
<h4>Related Documents<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>This guide should be used with the following additional supporting documentation. The MSP430 Driver Library API is not specific to this driver, and has its own documentation.</p>
<ul class="simple">
<li>MSP430 Driver Library (DriverLib) User&#8217;s Guide</li>
<li>The relevant MSP430 Family User&#8217;s Guide</li>
</ul>
</div>
<div class="section" id="id9">
<h4>Purpose of the Driver<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>The driver enables quick development of MSP430 applications where the MSP430 itself is a slave device to some other master in a larger embedded system. This is a common application, as MSP430 microcontrollers are often a secondary MCU to a larger host MCU or host MPU.</p>
<p>The driver is structured to be flexible, enabling many different applications. It is capable of providing a register-file interface to a host processor, similar to a sensor or an EEPROM. It may also be used as a bulk-transfer interface to a host.</p>
</div>
<div class="section" id="id10">
<h4>Driver Features<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>The key features provided by the driver are listed below.</p>
<ul class="simple">
<li>Interrupt-driven I2C slave software state machine</li>
<li>I2C Write (master transmitter, slave receiver) event callback</li>
<li>I2C Read (master receiver, slave transmitter) buffer assignment</li>
<li>Support for I2C start/stop/start as well as I2C start/repeated-start sequences</li>
<li>I2C error/warning reporting via an error callback function</li>
<li>Operation in LPM3 between I2C interrupts when timeout feature is used</li>
<li>Operation in LPM4 between I2C interrupts when timeout feature is not used</li>
<li>Open drain slave request signal (to alert the master to service the slave)</li>
<li>Slave request timeout capability to prevent an application stall</li>
<li>I2C bus transaction timeout capability to prevent an application stall</li>
</ul>
</div>
<div class="section" id="id11">
<h4>Driver Overview<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>The driver is provided in C source code. It consists of 3 base driver source files, plus an additional 3 source files related to the I2C timeout detection feature (which is a compile-time option).</p>
<p>Base Driver:</p>
<ul class="simple">
<li>I2CSlave_Definitions.h (Configuration header file)</li>
<li>I2CSlave.h (API header file)</li>
<li>I2CSlave.c (API implementation file)</li>
</ul>
<p>Function Timer (used for I2C timeout detection):</p>
<ul class="simple">
<li>FunctionTimer_Definitions.h (Configuration header file)</li>
<li>FunctionTimer.h (API header file)</li>
<li>FunctionTimer.c (API source file)</li>
</ul>
<p>The I2CSlave_Definitions.h and FunctionTimer_Definitions.h files contain the compile-time options for each component.</p>
<p>The driver requires the following MCU hardware resources:</p>
<p>Base Driver:</p>
<ul class="simple">
<li>One eUSCI_B peripheral instantiation</li>
<li>Two device pins (UCBxSDA and UCBxSCL), where &#8216;x&#8217; represents the selected eUSCI_B instance</li>
</ul>
<p>Slave Request Feature (Optional):</p>
<ul class="simple">
<li>One additional device pin (Any digital IO for the slave request line feature).</li>
</ul>
<p>Timeout Feature (Optional):</p>
<ul class="simple">
<li>One TIMER_A peripheral instantiation with at least 2 capture-compare units (CCR0 and CCR1)</li>
</ul>
<p>The driver operation is based upon a software state machine that keeps track of the current driver state. There are four possible states: closed, idle, read, and write. Since the driver implements an I2C slave, it is important to be clear on the naming conventions for read and write. An I2C bus write is a receive operation from the perspective of an I2C slave, as the bus master is writing to the slave. Similarly, an I2C bus read is a transmit operation from the perspective of the slave. The state machine implemented by the driver is depicted below.</p>
<div class="figure" id="id78">
<img alt="I2C Slave Driver State Machine" src="../_images/lib_comm_i2cslavestatemachine.png" />
<p class="caption"><span class="caption-number">Fig. 230 </span><span class="caption-text">I2C Slave Driver State Machine</span></p>
</div>
<p>As shown, state changes between idle, read, and write are controlled solely by the I2C bus master. It is possible for the slave to close the driver at any time, however.</p>
<div class="section" id="driver-overview-i2c-receive-operations-i2c-bus-write">
<h5>Driver Overview: I2C Receive Operations (I2C Bus Write)<a class="headerlink" href="#driver-overview-i2c-receive-operations-i2c-bus-write" title="Permalink to this headline">¶</a></h5>
<p>The driver enters the &#8220;write&#8221; state (eI2CSlaveIsBeingWrittenTo) whenever the bus master sends a start or restart condition to the driver&#8217;s 7-bit I2C address with the R/_W bit cleared. In this state, the driver is receiving data. Data is received into the buffer memory that was specified by the user when the driver was opened. If the bus master attempts to write data beyond the length of the receive buffer, the data is ignored and an error callback alerts the application. The write state is cleared when a stop condition or a restart condition is issued. When this happens, the driver calls a user-specified callback function for the received data to be handled.</p>
</div>
<div class="section" id="driver-overview-i2c-transmit-operations-i2c-bus-read">
<h5>Driver Overview: I2C Transmit Operations (I2C Bus Read)<a class="headerlink" href="#driver-overview-i2c-transmit-operations-i2c-bus-read" title="Permalink to this headline">¶</a></h5>
<p>The driver enters the &#8220;read&#8221; state (eI2CSlaveIsBeingRead) whenever the bus master sends a start or restart condition to the driver&#8217;s 7-bit I2C address with the R/_W bit set. In this state, the driver is transmitting data to the master by loading data from the latest transmit buffer memory that was linked to the driver. Note that the buffer memory must have been pre-loaded before the read state was entered. If the bus master attempts to read data before any buffer was specified or if it attempts to read out more data than was made available in the buffer, the driver will clock out an invalid byte, which may be specified as a compile-time option. The read state is cleared when a stop condition or a restart condition is issued. When this happens, the driver wakes the CPU from any low power modes in case it was pending on the completion of a read operation.</p>
</div>
<div class="section" id="driver-overview-slave-request-feature">
<h5>Driver Overview: Slave Request Feature<a class="headerlink" href="#driver-overview-slave-request-feature" title="Permalink to this headline">¶</a></h5>
<p>The driver provides a mechanism for alerting the bus master that it wishes to communicate. This is helpful in many applications, as the slave has no way to initiate communication on the I2C bus. The slave request feature is implemented as an open-drain request line. The request line may be any digital IO on the MCU. The request line should be pulled up to VCC via a pull-up resistor, just like an I2C bus line. The driver controls whether the request line IO is left tri-stated (Hi-Z), or whether it is pulled to a logic low (sinking current to ground through the pullup resistor and the digital IO). The driver API contains a function for &#8220;pulling&#8221; the request line, which waits for a I2C bus response from the master (or a timeout) before returning.</p>
</div>
<div class="section" id="driver-overview-timeout-feature-function-timer">
<h5>Driver Overview: Timeout Feature (Function Timer)<a class="headerlink" href="#driver-overview-timeout-feature-function-timer" title="Permalink to this headline">¶</a></h5>
<p>The driver provides a timeout mechanism for preventing application lock-ups. To enable timeouts in a low-power way, a dedicated hardware timer is used to set limits on how long specific driver operations may take. The operations that may have timeouts placed on them are:</p>
<ol class="arabic simple">
<li><strong>I2C Slave Request Timeout.</strong> The slave request feature described in section 2.3.3 signals the bust master to communicate with the slave. That slave request API function is designed to block until the master starts communication (via a I2C bus read start condition). If the timeout feature is enabled, the slave request function will time out automatically if the master does not start a read within the specified timeout period.</li>
<li><strong>I2C Transaction Timeout.</strong> The transaction timeout places a limit on how long any I2C bus transaction may take. An I2C transaction time is defined between a start or restart condition until a restart or stop condition is issued. The goal of the transaction timeout is to detect scenarios where the bus master went down in the middle of transmission, or an I2C bus disconnection.</li>
</ol>
<p>The timeout feature is implemented by the Function Timer module, which is a completely independent software module. As transaction monitoring may be a part of the application layer (perhaps with a standard watchdog timer), the timeout feature may be excluded completely at compile time. The Function Timer module essentially calls a predefined function in the foreground after a defined delay in timer cycles. That function can then take actions such as cancelling a slave request or resetting the driver.</p>
</div>
</div>
<div class="section" id="id12">
<h4>Compile-time Driver Configuration Options<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>The compile-time configuration options are set in the I2CSlave_Definitions.h and FunctionTimer_Definitions.h files. These options are described below.</p>
<div class="section" id="i2c-slave-enable-definition">
<h5>I2C Slave Enable Definition<a class="headerlink" href="#i2c-slave-enable-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="42%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>I2CSLAVE__ENABLE</td>
<td>I2CSlave_Definitions.h</td>
<td>true, false</td>
</tr>
</tbody>
</table>
<p>The I2C Slave Enable compile-time option selects whether the driver is enabled or disabled. This provides a mechanism to exclude the driver from the compilation process. To include the driver, define I2CSlave__ENABLE as true. Else, define it as false.</p>
</div>
<div class="section" id="i2c-eusci-b-peripheral-selection-definition">
<h5>I2C eUSCI_B Peripheral Selection Definition<a class="headerlink" href="#i2c-eusci-b-peripheral-selection-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="33%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>I2CSLAVE__EUSCI_B_PERIPHERAL</td>
<td>I2CSlave_Definitions.h</td>
<td>EUSCI_B0_BASE</td>
</tr>
</tbody>
</table>
<p>The I2C eUSCI_B peripheral selection allows easy selection of which eUSCI_B instance to associate with the I2C driver. This provides flexibility during design if a pin-mux change is necessary. A valid base address must be provided.</p>
</div>
<div class="section" id="i2c-slave-address-definition">
<h5>I2C Slave Address Definition<a class="headerlink" href="#i2c-slave-address-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="41%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>I2CSLAVE__ADDRESS</td>
<td>I2CSlave_Definitions.h</td>
<td>0x00 to 0x7F</td>
</tr>
</tbody>
</table>
<p>The I2C slave address specifies the 7-bit I2C bus address associated with this device.</p>
</div>
<div class="section" id="i2c-slave-lpm-mode-definition">
<h5>I2C Slave LPM Mode Definition<a class="headerlink" href="#i2c-slave-lpm-mode-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="23%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>I2CSLAVE__LPMx_bits</td>
<td>I2CSlave_Definitions.h</td>
<td>LPM0_bits, LPM1_bits, LPM2_bits, LPM3_bits, LPM4_bits</td>
</tr>
</tbody>
</table>
<p>I2C communication may be performed in a low power mode. No clocks need to be enabled on the MSP430 to send or receive bytes on a eUSCI_B peripheral when in I2C slave mode. This is a benefit of the bit clock being provided by the bus master. The I2C Slave LPM mode control is used in the following ways.</p>
<ol class="arabic simple">
<li>Receive callback functions may trigger an active exit from the I2C ISR after the completion of a receive event (triggered by either a re-start or a stop condition). If a receive callback returns true to the driver, the status register bits specified by the I2C slave LPM mode will be cleared when exiting.</li>
<li>A call to I2CSlave_setTransmitBuffer() will block if a previous read is requested or in progress. If a low power mode is specified via the I2C Slave LPM Mode definition, the block will take place in that low power mode- otherwise, it will block in active mode.</li>
</ol>
</div>
<div class="section" id="i2c-slave-invalid-byte-definition">
<h5>I2C Slave Invalid Byte Definition<a class="headerlink" href="#i2c-slave-invalid-byte-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="38%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>I2CSLAVE__INVALID_BYTE</td>
<td>I2CSlave_Definitions.h</td>
<td>0x00 to 0xFF</td>
</tr>
</tbody>
</table>
<p>The invalid byte specifies the byte that is transmitted to the master (during an I2C read) if the master attempts to read beyond the length of the transmit buffer provided to the driver.</p>
</div>
<div class="section" id="i2c-slave-timeout-enable-definition">
<h5>I2C Slave Timeout Enable Definition<a class="headerlink" href="#i2c-slave-timeout-enable-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="36%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>I2CSLAVE__TIMEOUT_ENABLE</td>
<td>I2CSlave_Definitions.h</td>
<td>true, false</td>
</tr>
</tbody>
</table>
<p>The slave timeout enable controls whether the timeout feature of the driver is included. The timeout feature provides the ability to set a maximum amount of time a certain I2C slave task may take before it fails. The two tasks that may be monitored with a timeout is the I2C slave request and any I2C transaction. Note that enabling the timeout feature requires the inclusion of the FunctionTimer source files, a Timer_A instance, and additional memory.</p>
</div>
<div class="section" id="i2c-slave-request-timeout-cycles-definition">
<h5>I2C Slave Request Timeout Cycles Definition<a class="headerlink" href="#i2c-slave-request-timeout-cycles-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="33%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>I2CSLAVE__REQ_TIMEOUT_CYCLES</td>
<td>I2CSlave_Definitions.h</td>
<td>0x0000 - 0xFFFF</td>
</tr>
</tbody>
</table>
<p>The I2C slave request timeout cycles specifies the timeout period for the I2C request timeout, in units of the function timer clock period. This is the amount of time the driver will wait after pulling the slave request line low before the transaction fails out. The bus master must respond to the slave request within this amount of time.</p>
</div>
<div class="section" id="i2c-slave-transfer-timeout-cycles-definition">
<h5>I2C Slave Transfer Timeout Cycles Definition<a class="headerlink" href="#i2c-slave-transfer-timeout-cycles-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="33%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>I2CSLAVE__TXFR_TIMEOUT_CYCLES</td>
<td>I2CSlave_Definitions.h</td>
<td>0x0000 - 0xFFFF</td>
</tr>
</tbody>
</table>
<p>The I2C slave transfer timeout cycles specifies the timeout period for any I2C transaction, in units of the function timer clock period. I2C transactions are timed from start condition to stop condition, or start condition to re-start condition.</p>
</div>
<div class="section" id="i2c-slave-request-enable-definition">
<h5>I2C Slave Request Enable Definition<a class="headerlink" href="#i2c-slave-request-enable-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="39%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>I2CSLAVE__REQ_ENABLE</td>
<td>I2CSlave_Definitions.h</td>
<td>true, false</td>
</tr>
</tbody>
</table>
<p>The request enable controls whether the I2C request line feature is included in the driver build. The I2C request line provides a mechanism for the slave to signal the master that it would like to communicate.</p>
</div>
<div class="section" id="i2c-slave-request-line-definition">
<h5>I2C Slave Request Line Definition<a class="headerlink" href="#i2c-slave-request-line-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="40%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>I2CSLAVE__REQ_POUT</td>
<td>I2CSlave_Definitions.h</td>
<td>PxOUT</td>
</tr>
<tr class="row-odd"><td>I2CSLAVE__REQ_PDIR</td>
<td>I2CSlave_Definitions.h</td>
<td>PxDIR</td>
</tr>
<tr class="row-even"><td>I2CSLAVE__REQ_MASK</td>
<td>I2CSlave_Definitions.h</td>
<td>BIT0 - BIT7</td>
</tr>
</tbody>
</table>
<p>The I2C slave request line is defined by three values- the port output register, the port direction register, and the pin mask. These do not need to be defined if the slave request enable is set to false.</p>
</div>
<div class="section" id="function-timer-enable-definition">
<h5>Function Timer Enable Definition<a class="headerlink" href="#function-timer-enable-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="43%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FUNCTIONTIMER__ENABLE</td>
<td>FunctionTimer_Definitions.h</td>
<td>true, false</td>
</tr>
</tbody>
</table>
<p>The function timer enable controls whether the function timer is included in the driver build. If the I2C slave timeout feature is not used, memory is conserved when the function timer is disabled (set to false).</p>
</div>
<div class="section" id="function-timer-peripheral-definition">
<h5>Function Timer Peripheral Definition<a class="headerlink" href="#function-timer-peripheral-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="24%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FUNCTIONTIMER__PERIPHERAL</td>
<td>FunctionTimer_Definitions.h</td>
<td>TIMER_A0_BASE, TIMER_A1_BASE, TIMER_A2_BASE, TIMER_A3_BASE</td>
</tr>
</tbody>
</table>
<p>The function timer peripheral stores the base address of the Timer_A instance that should be associated with the function timer. This instance must have at least two capture compare units (CCR0 and CCR1).</p>
</div>
<div class="section" id="function-timer-clock-source-definition">
<h5>Function Timer Clock Source Definition<a class="headerlink" href="#function-timer-clock-source-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="34%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FUNCTIONTIMER__CLOCK</td>
<td>FunctionTimer_Definitions.h</td>
<td>TASSEL__SMCLK, TASSEL__ACLK</td>
</tr>
</tbody>
</table>
<p>The function timer clock determines the resolution of the function timer, as well as the maximum delay. Sources include SMCLK and ACLK. Note that if the clock source is changed, the effective function timer delay may change.</p>
</div>
<div class="section" id="function-timer-clock-divider-definition">
<h5>Function Timer Clock Divider Definition<a class="headerlink" href="#function-timer-clock-divider-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="33%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FUNCTIONTIMER__DIVIDER</td>
<td>FunctionTimer_Definitions.h</td>
<td>ID__1, ID__2, ID__4, ID__8</td>
</tr>
</tbody>
</table>
<p>The function timer clock divider divides down the source clock (which was specified above). Note that if the clock divider is changed, the effective function timer delay may change.</p>
</div>
<div class="section" id="function-timer-extended-clock-divider-definition">
<h5>Function Timer Extended Clock Divider Definition<a class="headerlink" href="#function-timer-extended-clock-divider-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="36%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FUNCTIONTIMER__EXDIVIDER</td>
<td>FunctionTimer_Definitions.h</td>
<td>TAIDEX_0 to TAIDEX_7</td>
</tr>
</tbody>
</table>
<p>The function timer extended divider allows an additional second divider to be added in series with the standard divider. Note that if the extended clock divider is changed, the effective function timer delay may change.</p>
</div>
<div class="section" id="function-timer-lpm-clear-definition">
<h5>Function Timer LPM Clear Definition<a class="headerlink" href="#function-timer-lpm-clear-definition" title="Permalink to this headline">¶</a></h5>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="26%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">File</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FUNCTIONTIMER__LPM_CLEAR</td>
<td>FunctionTimer_Definitions.h</td>
<td>LPM0_bits, LPM1_bits, LPM2_bits, LPM3_bits, LPM4_bits</td>
</tr>
</tbody>
</table>
<p>The function timer LPM clear controls which LPM bits are cleared upon exit from a function called in the foreground by the function timer. This should be set to enable CPU wake-up after a timeout event. The function timer feature will never use these bits to enter into a low power mode- it will only use them to exit.</p>
</div>
</div>
<div class="section" id="id13">
<h4>Run-time Driver Configuration Options<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>The driver&#8217;s runtime configuration options are specified by populating a tI2CSlavePort structure in the application, and passing this structure to the driver when opening the driver. The tI2CSlavePort structures are discussed below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="79%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Member</th>
<th class="head">Description</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>bool (*pbReceiveCallback)(uint16_t)</td>
<td>pbReceiveCallback is a function pointer that may point to a receive event handler in the application. If no receive handling is required, initialize this member to 0 (null).</td>
<td>Null, or a valid function address.</td>
</tr>
<tr class="row-odd"><td>void (*pvErrorCallback)(uint8_t)</td>
<td>pvErrorCallback is a function pointer that may point to an error event handler in the application. If no error handling is required, initialize this member to 0 (null).</td>
<td>Null, or a valid function address</td>
</tr>
<tr class="row-even"><td>ui16ReceiveBufferSize</td>
<td>This member stores the size of the receive buffer pointed to by pReceiveBuffer.</td>
<td>0x00 to 0xFF</td>
</tr>
<tr class="row-odd"><td>pReceiveBuffer</td>
<td>This member is a pointer to the I2C receive buffer.</td>
<td>A valid pointer</td>
</tr>
<tr class="row-even"><td>bSendReadLengthFirst</td>
<td>When set to true, this flag configures the driver to always load the length of the transmit buffer as the first data byte read by the bus master. This is useful when variable length bulk packets are being read out by the master, and the master needs to know how many bytes to read from the slave.</td>
<td>true, false</td>
</tr>
</tbody>
</table>
<p>If the timeout feature is included in the driver build, a function timer run-time configuration also happens- but it is handled automatically by the driver when the I2C port is opened. The function timer runtime configuration structure (tFunctionTimer) is outlined below for completeness, but application does not need to know any of the function timer details.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="59%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Member</th>
<th class="head">Description</th>
<th class="head">Valid Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ui16FunctionDelay_A</td>
<td>This member specifies the length of the delay (in timer clock cycles) before function A is called.</td>
<td>0x0000 to 0xFFFF</td>
</tr>
<tr class="row-odd"><td>bool (*pbFunction_A)(void)</td>
<td>pbFunction_A is a function pointer to function A.</td>
<td>A valid function pointer, else null.</td>
</tr>
<tr class="row-even"><td>ui16FunctionDelay_B</td>
<td>This member specifies the length of the delay (in timer clock cycles) before function B is called.</td>
<td>0x0000 to 0xFFFF</td>
</tr>
<tr class="row-odd"><td>bool (*pbFunction_B)(void)</td>
<td>pbFunction_B is a function pointer to function B.</td>
<td>A valid function pointer, else null.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id14">
<h4>Using the Driver: Opening and Closing the Driver<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>Opening and closing of the I2C slave driver is accomplished through the following function calls:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Open the I2C Slave Port</td>
<td>extern void I2CSlave_openPort(const tI2CSlavePort *pPort)</td>
</tr>
<tr class="row-odd"><td>Close the I2C Slave Port</td>
<td>extern void I2CSlave_closePort(void)</td>
</tr>
</tbody>
</table>
<p>The driver is initialized and made ready for use by placing a call to <strong>I2CSlave_openPort()</strong>, which is passed a completed tI2CSlavePort structure. The tI2CSlavePort structure must be populated by the application. This structure is not modified by the driver at any time, and as such, it may be placed in read-only memory such as a C const memory section. It is important that the structure be left in memory at the original address that is passed to <strong>I2CSlave_openPort()</strong>, as the driver will reference this structure to access callback functions when the port is open. If the memory must be freed, first close the driver with a call to <strong>I2CSlave_closePort()</strong>. A call to <strong>I2CSlave_closePort()</strong> will disable the driver and its associated eUSCI_B peripheral, halting all I2C slave activity. If the timeout feature was included in the build, <strong>I2C_closePort()</strong> disables the function timer module that drives the timeout feature. After the port is closed, the event handlers will no longer
be called and the tI2CSlave structure memory may be released to the application.</p>
<p><strong>Open the I2C Slave Port</strong> <sub>[STRIKEOUT:{.c} // // Open the I2C slave port // I2CSlave_openPort(&amp;g_myI2CPort);]</sub></p>
</div>
<div class="section" id="using-the-driver-transmitting-data-i2c-read-operation">
<h4>Using the Driver: Transmitting Data (I2C Read Operation)<a class="headerlink" href="#using-the-driver-transmitting-data-i2c-read-operation" title="Permalink to this headline">¶</a></h4>
<p>Data transmission is accomplished through the following function calls:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Declaration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Set Transmit Buffer</td>
<td>extern void I2CSlave_setTransmitBuffer(uint8_t *pBuffer, uint16_t ui16Length)</td>
</tr>
<tr class="row-odd"><td>Set Request Flag</td>
<td>extern void I2CSlave_setRequestFlag(void)</td>
</tr>
<tr class="row-even"><td>Get Port Status</td>
<td>extern uint8_t I2CSlave_getPortStatus(void)</td>
</tr>
</tbody>
</table>
<p>An I2C slave cannot push data out onto the bus on its own- rather, a master must address the slave and clock out the data. Therefore, the data buffer must be made available to the driver before the bus master attempts to read it. The application may pass a pointer and a length (in bytes) to the <strong>I2CSlave_setTransmitBuffer</strong>() function. This function will block if a current transaction is in progress, and will return when the transmit buffer pointer and length have been updated. If no transmit buffer is provided and the bus master attempts to read from the slave, it will read out the invalid character (a compile-time option).</p>
<p>The <strong>I2CSlave_setTransmitBuffer</strong>() function does not perform a copy of the buffer- rather, it just stores its location and length. This is very valuable for &#8220;register&#8221; applications, where the application just updates the buffer, and <strong>I2CSlave_setTransmitBuffer</strong>() only needs to be called once during initialization. Repeated reads from the bus master will re-read the same buffer until <strong>I2CSlave_setTransmitBuffer</strong>() is called again. On the flipside, it is important that the application does not overwrite the transmit buffer space until transmission is complete.</p>
<p>If the slave request feature is enabled, the master may be signaled by calling the <strong>I2CSlave_setRequestFlag</strong>() function. This function immediately pulls the request line, then waits for the master to begin performing a read operation before it returns (or times out).</p>
<p>The driver state may be obtained by the application at any time by calling <strong>I2CSlave_getPortStatus</strong>(). This function returns the current I2C Slave state. The possible states are enumerated by tI2CSlaveStates. The possible enumerations are listed below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Port Status Option</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>eI2CSlaveIsClosed</td>
<td>The driver is closed. All functions besides <strong>I2CSlave_openPort</strong>() and <strong>I2CSlave_getPortStatus</strong>() are invalid.</td>
</tr>
<tr class="row-odd"><td>eI2CSlaveIsIdle</td>
<td>The driver is open, but no I2C transactions are currently in progress.</td>
</tr>
<tr class="row-even"><td>eI2CSlaveIsBeingRead</td>
<td>The driver is open and the bus master is reading data. The driver loads data from the transmit buffer until all data has been sent, then it loads the invalid byte.</td>
</tr>
<tr class="row-odd"><td>eI2CSlaveIsBeingWrittenTo</td>
<td>The driver is open and the bus master is writing data. The written data is placed into the receive buffer if there is space. At the end of this state, the receive callback in the application is called.</td>
</tr>
</tbody>
</table>
<p><strong>Setting the I2C Slave Transmit Buffer</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">uint8_t</span> <span class="n">g_ui8MemoryArray</span><span class="p">[</span><span class="n">MEMORY_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">I2CSlave_setTransmitBuffer</span><span class="p">(</span><span class="n">g_ui8MemoryArray</span><span class="p">,</span> <span class="n">MEMORY_SIZE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-driver-receiving-data-i2c-write-operation">
<h4>Using the Driver: Receiving Data (I2C Write Operation)<a class="headerlink" href="#using-the-driver-receiving-data-i2c-write-operation" title="Permalink to this headline">¶</a></h4>
<p>The bus master may start a write operation at any time. The driver will buffer incoming data into the receive buffer. When the transaction is complete, the application receive callback is called. The callback is passed the size of the data received from the master (in bytes). Since it is called from the driver interrupt service routine, no other interrupts will be processed and the eUSCI_B may be stretching the bus clock line until the driver returns from the receive callback. This provides the callback function the opportunity to process any received data and update the transmit buffer before the master may continue with communication.</p>
</div>
<div class="section" id="id15">
<h4>Using the Driver: Error Handling<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>The driver provides an error callback to alert the application if there is a problem with the driver. The error callback, when called, passes a value indicating the error that occurred. The possible errors are listed below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Error Code</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>eI2CSlaveTransmitRequestTimeout</td>
<td>This code indicates that a slave request to the bus master was not serviced within the timeout window, and the request timed out.</td>
</tr>
<tr class="row-odd"><td>eI2CSlaveTransactionTimeout</td>
<td>This code indicates that an I2C transaction was taking longer than the timeout window, and the transaction timed out. This error also results in a driver reset.</td>
</tr>
<tr class="row-even"><td>eI2CSlaveReceiveBufferFull</td>
<td>This code indicates that the receive buffer was full during the last read transaction, and data from the bus master was lost.</td>
</tr>
<tr class="row-odd"><td>eI2CSlaveWasReadBeyondTransmitBuffer</td>
<td>This code indicates that the bus master attempted to read data from the slave beyond the valid transmit buffer length (indicating the master was reading invalid bytes).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id16">
<h4>Using the Driver: Example Application<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>This is an I2C Slave Driver 512B Embedded Memory IC example. This example project configures the MSP430FR2633 as a 512B RAM device with an I2C interface. The master may write up to 128 bytes to the 8kB memory at a time. The master may read from any memory address until the end of the memory section at any time. The read/write format is as follows: I2C-START / ADDRESS+RW / MEMORY ADDR UPPER BYTE / MEMORY ADDR LOWER BYTE / DATA.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">##include &quot;driverlib.h&quot;</span>
<span class="c1">##include &quot;I2CSlave.h&quot;</span>
<span class="c1">##include &quot;string.h&quot;</span>

<span class="o">//</span>
<span class="o">//</span> <span class="n">MEMORY_SIZE</span> <span class="n">defines</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">array</span> <span class="ow">in</span> <span class="nb">bytes</span>
<span class="o">//</span>
<span class="c1">##define MEMORY_SIZEDepart Dallas/Fort Worth, TX to Roanoke, VA</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">g_ui8MemoryArray</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">array</span><span class="o">.</span>
<span class="o">//</span>
<span class="n">uint8_t</span> <span class="n">g_ui8MemoryArray</span><span class="p">[</span><span class="n">MEMORY_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="o">//</span>
<span class="o">//</span> <span class="n">I2C_RECEIVE_BUFFER_SIZE</span> <span class="n">defines</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">I2C</span> <span class="n">receive</span> <span class="n">buffer</span>
<span class="o">//</span>
<span class="c1">##define I2C_RECEIVE_BUFFER_SIZE        130</span>

<span class="o">//</span>
<span class="o">//</span> <span class="n">g_ui8I2CReceiveBuffer</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">buffer</span> <span class="n">space</span> <span class="n">used</span> <span class="k">for</span> <span class="n">I2C</span> <span class="n">receive</span> <span class="n">ops</span><span class="o">.</span>
<span class="o">//</span>
<span class="n">uint8_t</span> <span class="n">g_ui8I2CReceiveBuffer</span><span class="p">[</span><span class="n">I2C_RECEIVE_BUFFER_SIZE</span><span class="p">];</span>

<span class="o">//</span>
<span class="o">//</span> <span class="n">REQ_LOW_ADDR</span> <span class="n">defines</span> <span class="n">a</span> <span class="n">macro</span> <span class="n">to</span> <span class="n">get</span> <span class="n">the</span> <span class="n">low</span> <span class="n">address</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">I2C</span>
<span class="o">//</span> <span class="n">receive</span> <span class="n">buffer</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">REQ_HIGH_ADDR</span> <span class="n">defines</span> <span class="n">a</span> <span class="n">macro</span> <span class="n">to</span> <span class="n">get</span> <span class="n">the</span> <span class="n">high</span> <span class="n">address</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">I2C</span>
<span class="o">//</span> <span class="n">receive</span> <span class="n">buffer</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">REQ_FULL_ADDR</span> <span class="n">defines</span> <span class="n">a</span> <span class="n">macro</span> <span class="n">to</span> <span class="n">access</span> <span class="n">the</span> <span class="n">full</span> <span class="mi">13</span><span class="o">-</span><span class="n">bit</span> <span class="n">address</span> <span class="ow">in</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">receive</span> <span class="n">buffer</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">REMAINING_MEMORY</span> <span class="n">defines</span> <span class="n">macro</span> <span class="n">to</span> <span class="n">get</span> <span class="n">the</span> <span class="n">remaining</span> <span class="n">memory</span> <span class="kn">from</span> <span class="nn">the</span>
<span class="o">//</span><span class="n">current</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">receive</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">memory</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">DATA_TO_WRITE</span> <span class="n">defines</span> <span class="n">a</span> <span class="n">macro</span> <span class="n">to</span> <span class="n">get</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">data</span> <span class="n">to</span> <span class="n">write</span>
<span class="o">//</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">I2C</span> <span class="n">receive</span> <span class="n">register</span>
<span class="o">//</span>
<span class="c1">##define REQ_LOW_ADDR                                 (g_ui8I2CReceiveBuffer[1])</span>
<span class="c1">##define REQ_HIGH_ADDR                                (g_ui8I2CReceiveBuffer[0])</span>
<span class="c1">##define REQ_FULL_ADDR ((uint16_t)REQ_LOW_ADDR | ((uint16_t)REQ_HIGH_ADDR &lt;&lt; 8))</span>
<span class="c1">##define REMAINING_MEMORY                            (MEMORY_SIZE-REQ_FULL_ADDR)</span>
<span class="c1">##define DATA_TO_WRITE                               (&amp;g_ui8I2CReceiveBuffer[2])</span>

<span class="o">//</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">receive</span> <span class="n">handler</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">by</span> <span class="n">the</span> <span class="n">I2C</span> <span class="n">port</span> <span class="n">driver</span> <span class="n">whenever</span> <span class="n">a</span> <span class="n">new</span>
<span class="o">//</span> <span class="n">packet</span> <span class="n">was</span> <span class="n">received</span><span class="o">.</span>
<span class="o">//</span>
<span class="nb">bool</span> <span class="n">receiveHandler</span><span class="p">(</span><span class="n">uint16_t</span> <span class="n">ui16Length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Update</span> <span class="n">the</span> <span class="n">current</span> <span class="n">memory</span> <span class="n">location</span>
    <span class="o">//</span>
    <span class="n">uint8_t</span> <span class="o">*</span><span class="n">pCurrMemoryLocation</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">g_ui8MemoryArray</span><span class="p">[</span><span class="n">REQ_FULL_ADDR</span><span class="p">];</span>
    <span class="n">I2CSlave_setTransmitBuffer</span><span class="p">(</span><span class="n">pCurrMemoryLocation</span><span class="p">,</span> <span class="n">REMAINING_MEMORY</span><span class="p">);</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">If</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">packet</span><span class="p">,</span> <span class="n">write</span> <span class="n">it</span> <span class="n">into</span> <span class="n">the</span> <span class="n">memory</span>
    <span class="o">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ui16Length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">pCurrMemoryLocation</span><span class="p">,</span> <span class="n">DATA_TO_WRITE</span><span class="p">,</span> <span class="p">(</span><span class="n">ui16Length</span><span class="o">-</span><span class="mi">2</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">No</span> <span class="n">need</span> <span class="n">to</span> <span class="n">wake</span> <span class="n">the</span> <span class="n">CPU</span><span class="p">,</span> <span class="k">return</span> <span class="n">false</span> <span class="n">to</span> <span class="n">exit</span> <span class="n">asleep</span>
    <span class="o">//</span>
    <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">errorHandler</span><span class="p">(</span><span class="n">uint8_t</span> <span class="n">ui8Error</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span>
<span class="o">//</span> <span class="n">g_myI2CPort</span> <span class="n">specifies</span> <span class="n">the</span> <span class="n">I2C</span> <span class="n">Slave</span> <span class="n">port</span> <span class="n">configuration</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">passed</span>
<span class="o">//</span> <span class="n">to</span> <span class="n">I2CSlave_openPort</span><span class="p">()</span><span class="o">.</span>
<span class="o">//</span>
<span class="n">const</span> <span class="n">tI2CSlavePort</span> <span class="n">g_myI2CPort</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">.</span><span class="n">pbReceiveCallback</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">receiveHandler</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pvErrorCallback</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">errorHandler</span><span class="p">,</span>
    <span class="o">.</span><span class="n">ui16ReceiveBufferSize</span> <span class="o">=</span> <span class="n">I2C_RECEIVE_BUFFER_SIZE</span><span class="p">,</span>
    <span class="o">.</span><span class="n">pReceiveBuffer</span> <span class="o">=</span> <span class="n">g_ui8I2CReceiveBuffer</span><span class="p">,</span>
    <span class="o">.</span><span class="n">bSendReadLengthFirst</span> <span class="o">=</span> <span class="n">false</span>
<span class="p">};</span>

<span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">WDT_A_hold</span><span class="p">(</span><span class="n">WDT_A_BASE</span><span class="p">);</span>
    <span class="n">PMM_unlockLPM5</span><span class="p">();</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Set</span> <span class="n">P1</span><span class="o">.</span><span class="mi">6</span> <span class="ow">and</span> <span class="n">P1</span><span class="o">.</span><span class="mi">7</span> <span class="n">to</span> <span class="n">UCB0SDA</span> <span class="ow">and</span> <span class="n">UCB0SCL</span><span class="p">,</span> <span class="n">respectively</span>
    <span class="o">//</span>
    <span class="n">GPIO_setAsPeripheralModuleFunctionOutputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN2</span><span class="p">,</span> <span class="n">GPIO_SECONDARY_MODULE_FUNCTION</span><span class="p">);</span>
    <span class="n">GPIO_setAsPeripheralModuleFunctionInputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN3</span><span class="p">,</span> <span class="n">GPIO_SECONDARY_MODULE_FUNCTION</span><span class="p">);</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Enable</span> <span class="n">masked</span> <span class="n">interrupts</span>
    <span class="o">//</span>
    <span class="n">__bis_SR_register</span><span class="p">(</span><span class="n">GIE</span><span class="p">);</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Open</span> <span class="n">the</span> <span class="n">I2C</span> <span class="n">slave</span> <span class="n">port</span>
    <span class="o">//</span>
    <span class="n">I2CSlave_openPort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_myI2CPort</span><span class="p">);</span>
    <span class="n">I2CSlave_setTransmitBuffer</span><span class="p">(</span><span class="n">g_ui8MemoryArray</span><span class="p">,</span> <span class="n">MEMORY_SIZE</span><span class="p">);</span>

    <span class="o">//</span>
    <span class="o">//</span> <span class="n">Application</span> <span class="n">background</span> <span class="n">loop</span>
    <span class="o">//</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span>
        <span class="o">//</span> <span class="n">Enter</span> <span class="n">LPM3</span>
        <span class="o">//</span>
        <span class="n">LPM3</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="benchmarks">
<h2>Benchmarks<a class="headerlink" href="#benchmarks" title="Permalink to this headline">¶</a></h2>
<p>This section contains benchmarks the CapTIvate™ Software Library as used in different applications.</p>
<div class="section" id="memory-requirements">
<h3>Memory Requirements<a class="headerlink" href="#memory-requirements" title="Permalink to this headline">¶</a></h3>
<p>The CapTIvate Software Library is just one component of an application. At a minimum, an application will also require the following:</p>
<ul class="simple">
<li>MCU port muxing configuration (requires code space)</li>
<li>MCU clock configuration (requires code space)</li>
<li>CapTIvate configuration (requires code space)</li>
<li>A main routine (requires code space)</li>
<li>A call stack (requires data space)</li>
</ul>
<p>Therefore, when selecting the correct device it is important to consider the memory needs for the entire application and not just for CapTIvate.</p>
<div class="section" id="code-fram-and-data-ram-requirements">
<h4>CODE (FRAM) and DATA (RAM) Requirements<a class="headerlink" href="#code-fram-and-data-ram-requirements" title="Permalink to this headline">¶</a></h4>
<p>The following table illustrates the typical memory requirements for several different use-cases of the CapTIvate Software Library to aid in selecting the correct device for an application.</p>
<p>For each of these examples, the following assumptions were taken:</p>
<ul class="simple">
<li>CapTIvate Software Library and Starter Project v1.60.00.00 (November 2017)</li>
<li>A 256B call stack (CapTIvate examples default to a 256B call stack for application safety, this may be reduced)</li>
<li>MCU initialization via the CAPT_BSP module (configures GPIO and clocks)</li>
<li>CCS v7.2.0 toolchain (Compiler 16.9.0.LTS)</li>
<li>Optimization set to level 3 with emphasis on size rather than speed</li>
</ul>
<p><strong>NOTE: Enabling UART communications adds 1664B of FRAM and 389B of RAM with the default CapTIvate COMM configuration.</strong></p>
<p>Below are example memory requirements for devices utilizing the <em>rom_captivate_msp430fr2633_family</em> ROM image. This includes the MSP430FR2633, MSP430FR2533, MSP430FR2632, and MSP430FR2532.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="12%" />
<col width="6%" />
<col width="5%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Example Case</th>
<th class="head">Sensor Configuration</th>
<th class="head">FRAM (B)</th>
<th class="head">RAM (B)</th>
<th class="head">Comments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Basic touch button</td>
<td>1 button</td>
<td>3768</td>
<td>362</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Basic touch button with noise immunity</td>
<td>1 button</td>
<td>6306</td>
<td>388</td>
<td>When adding noise immunity, RAM and FRAM increase. Some optimizations are required when communications are enabled.</td>
</tr>
<tr class="row-even"><td>Basic touch button with wake-on-prox</td>
<td>1 button</td>
<td>4082</td>
<td>365</td>
<td>When adding wake-on-touch, FRAM increases.</td>
</tr>
<tr class="row-odd"><td>Numeric Keypad</td>
<td>12 buttons</td>
<td>3900</td>
<td>726</td>
<td>When adding buttons, the main increase is RAM.</td>
</tr>
<tr class="row-even"><td>Numeric Keypad with noise immunity</td>
<td>12 buttons</td>
<td>6436</td>
<td>950</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Numeric Keypad with wake-on-prox</td>
<td>12 buttons, 1 prox</td>
<td>4242</td>
<td>803</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>32 button UI</td>
<td>32 buttons</td>
<td>4126</td>
<td>1396</td>
<td>&gt;16 buttons requires an FR2533 or FR2633</td>
</tr>
<tr class="row-odd"><td>32 button UI with noise immunity</td>
<td>32 buttons</td>
<td>6670</td>
<td>1980</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>64 button UI</td>
<td>64 buttons</td>
<td>4494</td>
<td>2468</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>64 button UI with noise immunity</td>
<td>64 buttons</td>
<td>7036</td>
<td>3628</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>Below are example memory requirements for devices utilizing the <em>rom_captivate_msp430fr2522_family</em> ROM image. This includes both the MSP430FR2522 and MSP430FR2512. The <em>rom_captivate_msp430fr2522_family</em> ROM image contains more functionality than the <em>rom_captivate_msp430fr2633_family</em> ROM image, which means that the memory requirements for most applications are lower accordingly.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="17%" />
<col width="8%" />
<col width="8%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Example Case</th>
<th class="head">Sensor Configuration</th>
<th class="head">FRAM (B)</th>
<th class="head">RAM (B)</th>
<th class="head">Comments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Basic touch button</td>
<td>1 button</td>
<td>2196</td>
<td>358</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Basic touch button with noise immunity</td>
<td>1 button</td>
<td>4184</td>
<td>384</td>
<td>When adding noise immunity, RAM and FRAM increase.</td>
</tr>
<tr class="row-even"><td>Basic touch button with wake-on-prox</td>
<td>1 button</td>
<td>2516</td>
<td>361</td>
<td>When adding wake-on-touch, FRAM increases.</td>
</tr>
<tr class="row-odd"><td>Numeric Keypad</td>
<td>12 buttons</td>
<td>2342</td>
<td>740</td>
<td>When adding buttons, the main increase is RAM.</td>
</tr>
<tr class="row-even"><td>Numeric Keypad with noise immunity</td>
<td>12 buttons</td>
<td>4328</td>
<td>964</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Numeric Keypad with wake-on-prox</td>
<td>12 buttons, 1 prox</td>
<td>2694</td>
<td>817</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>**NOTE: For a full list of which functions are available in ROM for a given device family, see the <a class="reference external" href="../../../../api_guide/FR2633/html/md_imports_01_romtable.html">ROM table</a> in the API Guide.</p>
</div>
<div class="section" id="stack-requirements">
<h4>Stack Requirements<a class="headerlink" href="#stack-requirements" title="Permalink to this headline">¶</a></h4>
<p>The worst-case stack usage for most applications running only the CapTIvate Touch Library is approximately 100B, with 30B of additional space required for interrupt service routines. Therefore, applications should have a minimum stack size of 100B+30B=130B. If callback functions are used, these may potentially increase the stack size requirement. A good, conservative estimate that is safe for many applications is a 256B stack. Every application will have its own unique stack requirements, with interrupt service routines being the largest unknown factor. Therefore it is recommended that each designer perform a worst-case stack usage analysis to determine the required stack size.</p>
</div>
</div>
<div class="section" id="execution-times">
<h3>Execution Times<a class="headerlink" href="#execution-times" title="Permalink to this headline">¶</a></h3>
<p>It is often of interest to understand the amount of time required to set up a measurement, perform the measurement, and process the measurement results. This total time (setup+measure+process) determines the overall scan rate that is achievable for a system. This section is intended to provide general guidance on typical execution times for the setup+measure+process sequence.</p>
<div class="section" id="top-level-capt-updateui">
<h4>Top Level - CAPT_updateUI()<a class="headerlink" href="#top-level-capt-updateui" title="Permalink to this headline">¶</a></h4>
<p><strong>CAPT_updateUI()</strong> is the top level user-interface update application. It handles the setup+measure+process sequence for all sensors in the user interface, and will transmit data via a serial interface if configured to do so. This is the easiest function to use as it includes all of the required processing. Below are several examples of execution times for the setup+measure+process sequence.</p>
<p>Test conditions:</p>
<ul class="simple">
<li>One button, one time cycle, one sensor</li>
<li>CAPTIVATE-BSWP demo panel</li>
<li>250 counts of measurement resolution at a 2 MHz conversion frequency for a 145us measurement time.</li>
<li>CPU frequency is 8 MHz</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="10%" />
<col width="10%" />
<col width="14%" />
<col width="13%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Total Time</th>
<th class="head">Setup Time</th>
<th class="head">Measurement Time</th>
<th class="head">Processing Time</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CAPT_updateUI(&amp;g_uiApp);</td>
<td>0.723ms</td>
<td>0.388ms</td>
<td>0.145ms</td>
<td>0.190ms</td>
<td>LPM3 during conversion, bLpmControl=false</td>
</tr>
<tr class="row-odd"><td>CAPT_updateUI(&amp;g_uiApp);</td>
<td>0.632ms</td>
<td>0.297ms</td>
<td>0.145ms</td>
<td>0.190ms</td>
<td>LPM3 during conversion, bLpmControl=true</td>
</tr>
<tr class="row-even"><td>CAPT_updateUI(&amp;g_uiApp);</td>
<td>0.626ms</td>
<td>0.297ms</td>
<td>0.145ms</td>
<td>0.184ms</td>
<td>LPM0 during conversion, bLpmControl=true</td>
</tr>
</tbody>
</table>
<p>In the first case, the CapTIvate peripheral was configured to turn off after each conversion. This means that before each conversion starts, there is an extra start-up time for the peripheral. Here that time measures to be approximately 0.1ms. Also note the difference between LPM3 and LPM0 in the second and third cases. It takes up to 0.010ms to wake up from LPM3 to active, whereas the LPM0 to active transition is less than 0.001ms.</p>
</div>
<div class="section" id="sensor-level-capt-updatesensor">
<h4>Sensor Level - CAPT_updateSensor()<a class="headerlink" href="#sensor-level-capt-updatesensor" title="Permalink to this headline">¶</a></h4>
<p><strong>CAPT_updateSensor()</strong> is the sensor-level update function. It handles the setup+measure+process sequence for a single sensor at time. It does not transmit data. This is an easy function to use if you want to control when a specific sensor is measured.</p>
<p>Test conditions:</p>
<ul class="simple">
<li>One button, one time cycle, one sensor</li>
<li>CAPTIVATE-BSWP demo panel</li>
<li>250 counts of measurement resolution at a 2 MHz conversion frequency for a 145us measurement time.</li>
<li>CPU frequency is 8 MHz</li>
<li>LPM0 during conversion, bLpmControl=false</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="7%" />
<col width="7%" />
<col width="11%" />
<col width="10%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Total Time</th>
<th class="head">Setup Time</th>
<th class="head">Measurement Time</th>
<th class="head">Processing Time</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CAPT_updateSensor(&amp;BTN00, CPUOFF);</td>
<td>0.603ms</td>
<td>0.293ms</td>
<td>0.145ms</td>
<td>0.165ms</td>
<td>Full element and sensor processing performed</td>
</tr>
<tr class="row-odd"><td>CAPT_updateSensorRawCount(&amp;BTN00, eStandard, eNoOversampling, CPUOFF);</td>
<td>0.514ms</td>
<td>0.296ms</td>
<td>0.145ms</td>
<td>0.073ms</td>
<td>No element or sensor processing performed</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="low-level-capt-startconversionandwaituntildone">
<h4>Low Level - CAPT_startConversionAndWaitUntilDone()<a class="headerlink" href="#low-level-capt-startconversionandwaituntildone" title="Permalink to this headline">¶</a></h4>
<p>Low level functions may be used to extract raw data. This is the most time efficient way to measure if there is only one sensor, because the sensor&#8217;s parameters do not need to be re-loaded each time it is measured. This type of low-level conversion is only valuable for systems that have only 1 time cycle and are only looking to extract raw data with no post-processing.</p>
<p>The sequence to set up the sensor for measurement is as follows (run once):</p>
<ul class="simple">
<li>MAP_CAPT_applySensorParams(&amp;BTN00);</li>
<li>MAP_CAPT_applySensorFreq(CAPT_OSC_FREQ_DEFAULT, &amp;BTN00);</li>
</ul>
<p>The sequence to load the cycle, run, and extract the cycle&#8217;s measurement data is as follows (run for each measurement):</p>
<ul class="simple">
<li>CAPT_loadCycle(&amp;BTN00, 0, CAPT_OSC_FREQ_DEFAULT, false);</li>
<li>CAPT_startConversionAndWaitUntilDone(CPUOFF);</li>
<li>CAPT_unloadCycle(&amp;BTN00, 0, CAPT_OSC_FREQ_DEFAULT, false);</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="14%" />
<col width="14%" />
<col width="20%" />
<col width="19%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Total Time</th>
<th class="head">Setup Time</th>
<th class="head">Measurement Time</th>
<th class="head">Processing Time</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Low Level</td>
<td>0.243ms</td>
<td>0.066</td>
<td>0.145</td>
<td>.032</td>
<td>3 function calls</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ch_evm.html" class="btn btn-neutral float-right" title="MSP-CAPT-FR2633 Development Kit" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ch_device.html" class="btn btn-neutral" title="Device Family" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2018</a>, Texas Instruments Incorporated. All rights reserved. <br>
      <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.70.00.03',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
        });

      var menuHeight = window.innerHeight;

      var contentOffset = $(".wy-nav-content-wrap").offset();
      var contentHeight = $(".wy-nav-content-wrap").height();
      var contentBottom = contentOffset.top + contentHeight;

      function setNavbarTop() {
          var scrollTop = $(window).scrollTop();
          var maxTop = scrollTop + menuHeight;

          // If past the header
          if (scrollTop > contentOffset.top && maxTop < contentBottom) {
            stickyTop = scrollTop - contentOffset.top;
          } else if (maxTop > contentBottom) {
            stickyTop = scrollTop - contentOffset.top - (maxTop - contentBottom);
          } else {
            stickyTop = 0;
          }

          $(".wy-nav-side").css("top", stickyTop);
      }

      $(document).ready(function() {
        setNavbarTop();
        $(window).scroll(function () {
          setNavbarTop();
        });

        $('body').on("mousewheel", function () {
            // Remove default behavior
            event.preventDefault();
            // Scroll without smoothing
            var wheelDelta = event.wheelDelta;
            var currentScrollPosition = window.pageYOffset;
            window.scrollTo(0, currentScrollPosition - wheelDelta);
        });
      });
  </script>
   

</body>
</html>