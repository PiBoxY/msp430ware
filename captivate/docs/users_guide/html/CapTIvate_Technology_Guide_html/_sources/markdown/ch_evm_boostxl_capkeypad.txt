BOOSTXL-CAPKEYPAD Development Kit
=================================

The BOOSTXL-CAPKEYPAD is an easy-to-use evaluation module (EVM) for the MSP430FR2522 capacitive touch sensing microcontroller (MCU) with CapTIvate technology. The BOOSTXL-CAPKEYPAD enables you to extend your LaunchPad design by adding a 12-key capacitive touch numeric keypad with LED backlighting and proximity wake-up. Don't have a LaunchPad? The BOOSTXL-CAPKEYPAD may be used as a simple CapTIvate technology evaluation module when coupled with the `CAPTIVATE-PGMR <ch_evm.html#captivate-pgmr-programmer-pcb-overview>`__ for interfacing to a host PC running the `CapTIvate Design Center <http://www.ti.com/tool/MSPCAPTDSNCTR>`__. It is even possible to bypass the onboard keypad and connect up to 3 external capacitive sensors to the BOOSTXL-CAPKEYPAD to test out your own sensor design concepts.

This chapter of the CapTIvate Technology Guide contains the following sections:

1. `Overview <ch_evm_boostxl_capkeypad.html#overview>`__
2. `Getting Started <ch_evm_boostxl_capkeypad.html#getting-started>`__
3. `Hardware <ch_evm_boostxl_capkeypad.html#hardware>`__
4. `Software Examples <ch_evm_boostxl_capkeypad.html#software-examples>`__
5. `Resources <ch_evm_boostxl_capkeypad.html#resources>`__
6. `Schematics <ch_evm_boostxl_capkeypad.html#schematics>`__
7. `Layout <ch_evm_boostxl_capkeypad.html#layout>`__

To order a BOOSTXL-CAPKEYPAD, visit the `tool folder <http://www.ti.com/tool/boostxl-capkeypad>`__.

Overview
--------

Out of the box, the BOOSTXL-CAPKEYPAD powers up as a 12-key numeric keypad capacitive touch interface with proximity wake-up. The status of the keypad may be easily read by a host LaunchPad via a 3-pin I2C-bus interface (SDA, SCL, and IRQ). In addition to the host I2C interface, sensor data streaming is enabled out of the box to the CapTIvate Design Center via the UART interface in the 20-pin CapTIvate programming connector. The BOOSTXL-CAPKEYPAD may also be programmed and debugged via the 20-pin CapTIvate programming connector and the use of a `CAPTIVATE-PGMR <ch_evm.html#captivate-pgmr-programmer-pcb-overview>`__ module.

.. figure:: images/evm_boostxl_capkeypad/Photo_Top.png
   :alt: BOOSTXL-CAPKEYPAD

   BOOSTXL-CAPKEYPAD

Key Features
~~~~~~~~~~~~

The BOOSTXL-CAPKEYPAD has the following key features:

-  12-key numeric keypad for entering values to a host MCU
-  Short-range proximity wake-up option to detect when a user is close to the touch panel
-  Guard channel rejection algorithm to prevent invalid touches from being reported due to a palm resting on the keypad
-  LED backlighting of electrodes with fade-in/fade-out capability
-  3-wire I2C interface to a host processor (SDA, SCL, IRQ)
-  2-wire UART interface to a `CAPTIVATE-PGMR <ch_evm.html#captivate-pgmr-programmer-pcb-overview>`__ for capacitive touch tuning and evaluation
-  3-pin prototyping header allows 3 touch sensing lines from the keypad to be re-purposed for general purpose capacitive touch prototyping
-  Power selection jumper for external current measurement or current measurement using EnergyTrace technology. For EnergyTrace support, the BOOSTXL-CAPKEYPAD must be used with a `CAPTIVATE-PGMR <ch_evm.html#captivate-pgmr-programmer-pcb-overview>`__ module.

Key Devices
~~~~~~~~~~~

The BOOSTXL-CAPKEYPAD features the following integrated circuit devices:

-  `MSP430FR2522 <http://www.ti.com/product/msp430fr2522>`__ ultra-low-power MCU with noise-tolerant CapTIvate technology
-  `LP3943 <http://www.ti.com/product/lp3943>`__ 16-channel LED driver with independent string control via SMBUS/I2C

What's Included
~~~~~~~~~~~~~~~

The BOOSTXL-CAPKEYPAD comes with the following hardware and software:

Kit Contents
^^^^^^^^^^^^

-  1 *BOOSTXL-CAPKEYPAD* Development Board
-  1 Quick Start Guide

BOOSTXL-CAPKEYPAD Software Examples
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following software examples are available to run on the MSP430FR2522 MCU on the BOOSTXL-CAPKEYPAD:

-  **BOOSTXL-CAPKEYPAD** out-of-box demonstration (pre-programmed on a new BOOSTXL-CAPKEYPAD)
-  **BOOSTXL-CAPKEYPAD-EMC** conducted noise immunity demonstration
-  **BOOSTXL-CAPKEYPAD-Prototyping** self-capacitance prototyping example

Host LaunchPad MCU Software Examples
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following software examples are available to run on a variety of host LaunchPads, demonstrating how the BOOSTXL-CAPKEYPAD could be used to extend a LaunchPad design by adding keypad functionality.

-  **MSP-EXP430FR6989** LaunchPad host processor demonstration
-  **MSP-EXP430F5529LP** LaunchPad + Kentec QVGA LCD host processor demonstration

Block Diagram
~~~~~~~~~~~~~

The functional block diagram for the BOOSTXL-CAPKEYPAD is shown below.

.. figure:: images/evm_boostxl_capkeypad/bd.gif
   :alt: BOOSTXL-CAPKEYPAD

   BOOSTXL-CAPKEYPAD

Getting Started
---------------

This section outlines how to get started with the kit. There are two ways to get started with the BOOSTXL-CAPKEYPAD:

1. `Using the BOOSTXL-CAPKEYPAD with the CAPTIVATE-PGMR and CapTIvate Design Center <ch_evm_boostxl_capkeypad.html#out-of-box-experience-with-captivate-pgmr-and-captivate-design-center>`__
2. Using the BOOSTXL-CAPKEYPAD with a LaunchPad Host MCU

   a. `MSP-EXP430FR6989 Host LaunchPad with Segmented LCD <ch_evm_boostxl_capkeypad.html#out-of-box-experience-with-msp-exp430fr6989-segmented-lcd>`__
   b. `MSP-EXP430F5529LP Host LaunchPad with QVGA BoosterPack <ch_evm_boostxl_capkeypad.html#out-of-box-experience-with-msp-exp430f5529lp-qvga-host-demo>`__
   c. `MSP-EXP430F5529LP Host LaunchPad as a USB Keyboard <ch_evm_boostxl_capkeypad.html#out-of-box-experience-with-msp-exp430f5529lp-as-a-usb-keyboard>`__

Out-of-Box Experience with CAPTIVATE-PGMR and CapTIvate Design Center
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This out-of-box experience describes how to use the BOOSTXL-CAPKEYPAD with the CAPTIVATE-PGMR module and CapTIvate Design Center.

**Required Tools**

-  The latest `CapTIvate Design Center <http://www.ti.com/tool/MSPCAPTDSNCTR>`__ PC GUI Tool must be installed on a host PC, Mac, or Linux machine
-  A `CAPTIVATE-PGMR <http://www.ti.com/tool/msp-capt-fr2633>`__ module is required to interface the BOOSTXL-CAPKEYPAD to the host PC
-  A `BOOSTXL-CAPKEYPAD <http://www.ti.com/tool/boostxl-capkeypad>`__ programmed with the BOOSTXL-CAPKEYPAD-Demo firmware example
-  A micro-USB cable is required to connect the CAPTIVATE-PGMR to the host PC

**Assumptions**

-  This guide assumes that CapTIvate Design Center is already installed on the host PC. For installation instructions, see the `CapTIvate Design Center <ch_designcenter.html>`__ chapter.

Step 1: Connect Hardware
^^^^^^^^^^^^^^^^^^^^^^^^

Connect the BOOSTXL-CAPKEYPAD to a CAPTIVATE-PGMR module via the 20-pin programming interface connector at the top of the BOOSTXL-CAPKEYPAD, as shown below. Then, connect the CAPTIVATE-PGMR to a host computer with a micro-USB cable. When the board combo is connected to the host computer, the power-good LED should be lit, and the enumeration LED should be blinking. When communication activity is occurring, the red communications LED will illuminate.

.. figure:: images/evm_boostxl_capkeypad/evm_demo_setup_boostxl.png
   :alt: BOOSTXL-CAPKEYPAD with CAPTIVATE-PGMR and Host Computer

   BOOSTXL-CAPKEYPAD with CAPTIVATE-PGMR and Host Computer

Step 2: Board Wake-Up
^^^^^^^^^^^^^^^^^^^^^

With the BOOSTXL-CAPKEYPAD powered up, bring your hand close the BOOSTXL-CAPKEYPAD touch panel. The buttons should transition from dark to illuminated as shown. When you remove your hand from the keypad area, the keypad will time out after a period of inactivity and return to the wake-on-proximity mode. At that point, the LED backlighting will fade off. The **AWAKE** status LED on the BOOSTXL-CAPKEYPAD will also illuminate when the board is running in active mode.

.. figure:: images/evm_boostxl_capkeypad/Top_PGMR_Dark.png
   :alt: BOOSTXL-CAPKEYPAD in Wake-on-Prox Mode

   BOOSTXL-CAPKEYPAD in Wake-on-Prox Mode

.. figure:: images/evm_boostxl_capkeypad/Top_PGMR_Lit.png
   :alt: BOOSTXL-CAPKEYPAD in Active Mode

   BOOSTXL-CAPKEYPAD in Active Mode

The wake-on-proximity functionality allows for power savings when the keypad is not used. The electrodes are not lit when no one is near the electrodes, and only the proximity sensor is scanned. When a user is detected close to the panel, all touch electrodes become active.

Step 3: Keypad Touch Detection
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Bring a hand near the keypad area again, and touch one of the keypad buttons. The **DETECT** LED illuminates what a button is touched.

.. figure:: images/evm_boostxl_capkeypad/Top_PGMR_Lit_DetectLit.png
   :alt: BOOSTXL-CAPKEYPAD in Active Mode

   BOOSTXL-CAPKEYPAD in Active Mode

The BOOSTXL-CAPKEYPAD will pass individual touches on electrodes, but it rejects a palm across the keypad. this feature enables the touch panel area to be cleaned while powered up, without reporting invalid touches. To test this feature, place a palm across the keypad, and note that the **DETECT** LED does not illuminate.

.. figure:: images/evm_boostxl_capkeypad/BOOSTXL-CAPKEYPAD_Top_PGMR_Lit_DetectGuarded.png
   :alt: BOOSTXL-CAPKEYPAD in Active Mode

   BOOSTXL-CAPKEYPAD in Active Mode

Step 4: Using CapTIvate Design Center
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Open CapTIvate Design Center on the host computer.

.. figure:: images/designcenter/cdc_quickstart_desktop_shortcut.png
   :alt: CapTIvate Design Center Shortcut

   CapTIvate Design Center Shortcut

Select *File* -> *Project Open* from the menu bar. Then select the *BOOSTXL-CAPKEYPAD-Demo* project folder, and select *Open*.

.. figure:: images/evm_boostxl_capkeypad/project_open_basic.png
   :alt: BOOSTXL-CAPKEYPAD-Demo Project Open

   BOOSTXL-CAPKEYPAD-Demo Project Open

When the project opens, the design canvas should match the image below. There are three objects in this design:

1. MSP430FR2522IRHL20 controller
2. keypadSensor button group
3. proximitySensor proximity sensor

.. figure:: images/evm_boostxl_capkeypad/project_canvas_basic.png
   :alt: BOOSTXL-CAPKEYPAD-Demo Project Canvas

   BOOSTXL-CAPKEYPAD-Demo Project Canvas

With the BOOSTXL-CAPKEYPAD and CAPTIVATE-PGMR assembly connected to the host computer via USB, select *Communications* -> *Connect* from the menu bar in CapTIvate Design Center to enable target communications. At this point, when you touch a button, the button status is reflected in the CapTIvate Design Center.

.. figure:: images/evm_boostxl_capkeypad/project_canvas_basic_touched.png
   :alt: BOOSTXL-CAPKEYPAD-Demo Project Canvas, Buttons 1 and 2 Touched

   BOOSTXL-CAPKEYPAD-Demo Project Canvas, Buttons 1 and 2 Touched

Open the keypadSensor customizer by double-clicking the keypadSensor icon on the canvas. The *Channel Bar Chart* view will open by default. Touch any of the keys on the BOOSTXL-CAPKEYPAD to view the response in the customizer. All sensors on the BOOSTXL-CAPKEYPAD are mutual capacitance sensors. This means that touching a sensor reduces the capacitance of the electrode, causing the conversion result (in charge transfer counts) to increase. The capture below shows the response on button 1 when it is pressed. The default *Channel Bar Chart* tab is ideal for examining threshold levels.

.. figure:: images/evm_boostxl_capkeypad/project_customizer_basic_touched.png
   :alt: BOOSTXL-CAPKEYPAD-Demo Project Canvas, Button 1 Touched

   BOOSTXL-CAPKEYPAD-Demo Project Canvas, Button 1 Touched

To view a histogram of a touch, switch to the *Channel Oscilloscope Plot*. The oscilloscope plot is ideal for examining filter performance and noise immunity.

.. figure:: images/evm_boostxl_capkeypad/project_customizer_basic_touched_osc.png
   :alt: BOOSTXL-CAPKEYPAD-Demo Project Canvas, Button 1 Touched

   BOOSTXL-CAPKEYPAD-Demo Project Canvas, Button 1 Touched

Close the keypadSensor customizer, and open the proximitySensor customizer by double-clicking it. Then, bring a hand near the keypad area and observe the proximity sensing response. Note that the response increases rapidly as the distance between the hand and the keypad area is reduced. The proximity sensor also doubles as a guard channel. The prox threshold (drawn in orange in the CapTIvate Design Center) is used as the wake-up threshold. The touch threshold (drawn in green) is used as the guard channel threshold. The guard channel is used as a mask to prevent false touch detections from a palm resting on the keypad or a cloth wiping down the keypad.

.. figure:: images/evm_boostxl_capkeypad/project_customizer_basic_prox.png
   :alt: BOOSTXL-CAPKEYPAD-Demo Project Canvas, Button 1 Touched

   BOOSTXL-CAPKEYPAD-Demo Project Canvas, Button 1 Touched

This concludes the out-of-box demonstration of the BOOSTXL-CAPKEYPAD with the CAPTIVATE-PGMR and CapTIvate Design Center.

Out-of-Box Experience with MSP-EXP430FR6989 + Segmented LCD
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example demonstrates how to mate the `BOOSTXL-CAPKEYPAD <http://www.ti.com/tool/boostxl-capkeypad>`__ to an `MSP-EXP430FR6989 LaunchPad <http://www.ti.com/tool/msp-exp430fr6989>`__.

**Required Tools**

-  The latest `CapTIvate Design Center <http://www.ti.com/tool/MSPCAPTDSNCTR>`__ PC GUI Tool must be installed on a host PC, Mac, or Linux machine
-  A `BOOSTXL-CAPKEYPAD <http://www.ti.com/tool/boostxl-capkeypad>`__ programmed with the BOOSTXL-CAPKEYPAD-Demo firmware example
-  A `MSP-EXP430FR6989 LaunchPad <http://www.ti.com/tool/msp-exp430fr6989>`__
-  A micro-USB cable is required to connect the MSP-EXP430FR6989 to the host computer

**Assumptions**

-  This guide assumes that CapTIvate Design Center is already installed on the host PC. For installation instructions, see the `CapTIvate Design Center <ch_designcenter.html>`__ chapter.

Step 1: Program LaunchPad
^^^^^^^^^^^^^^^^^^^^^^^^^

Before connecting the LaunchPad to the BoosterPack, it is good practice to program it first to ensure that there are no IO assignment conflicts. The LaunchPad software example is stored in the CapTIvate Design Center workspace in the BOOSTXL-CAPKEYPAD project directory. Within the BOOSTXL-CAPKEYPAD project directory, there is a sub folder named *hostmcu\_demo\_src*. This contains the LaunchPad example projects. For this demo, the host project is *MSP-EXP430FR6989\_KeypadHostDemo\_SEGLCD*. If you are using the default installation directories, this location would be as follows:

    *C:/Users/USERNAME/CapTIvateDesignCenter\_X\_XX\_XX\_XX/CapTIvateDesignCenterWorkspace/BOOSTXL-CAPKEYPAD/hostmcu\_demo\_src/MSP-EXP430FR6989\_KeypadHostDemo\_SEGLCD*

Import this example project into Code Composer Studio or IAR Embedded Workbench. Then, compile and build the project and load it onto the LaunchPad. For instructions on how to import a project into CCS or IAR, view the `loading and running generated projects <ch_designcenter.html#loading-and-running-generated-projects>`__ guide in the CapTIvate Design Center chapter.

Step 2: Assemble Hardware
^^^^^^^^^^^^^^^^^^^^^^^^^

Next, disconnect the LaunchPad from the USB cable in order to remove power. Then, connect the LaunchPad to the BOOSTXL-CAPKEYPAD to create a 2-board stack, as shown below. This uses headers J1-J4 on the BOOSTXL-CAPKEYPAD, as well as J1-J4 on the LaunchPad. The assembled stack is shown below.

.. figure:: images/evm_boostxl_capkeypad/FR6989LP_BP.png
   :alt: BOOSTXL-CAPKEYPAD w/ MSP-EXP430FR6989

   BOOSTXL-CAPKEYPAD w/ MSP-EXP430FR6989

Step 3: Power Up and Test
^^^^^^^^^^^^^^^^^^^^^^^^^

Reconnect power to the LaunchPad by reconnecting the USB cable. Then, touch any of the buttons on the BOOSTXL-CAPKEYPAD to see the keystrokes logged onto the LCD. Up to 6 keystrokes may be entered at a time. Touching the enter or cancel keys displays enter or cancel on the LCD display, respectively. If the keypad is not touched for a period of time, it will shut down into is wake-on-proximity mode, and the LCD display will clear.

**DONE!** This concludes the BOOSTXL-CAPKEYPAD + MSP-EXP430FR6989 + Segmented LCD demo. Feel free to build your own code on top of the examples!

Troubleshooting
^^^^^^^^^^^^^^^

If the BoosterPack is not responsive after providing power, it may not have the default BOOSTXL-CAPKEYPAD-Demo software programmed on it. This can happen if it was reprogrammed with a different application at some point. If you experience this issue, ensure that the correct demo software is programmed to the BOOSTXL-CAPKEYPAD. Programming the BOOSTXL-CAPKEYPAD requires the use of a CAPTIVATE-PGMR module.

Out-of-Box Experience with MSP-EXP430F5529LP + QVGA Host Demo
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example demonstrates how to mate the `BOOSTXL-CAPKEYPAD <http://www.ti.com/tool/boostxl-capkeypad>`__ to an `MSP-EXP430F5529LP LaunchPad <http://www.ti.com/tool/msp-exp430f5529lp>`__ as well as a `BOOSTXL-K350QVG-S1 <http://www.ti.com/tool/boostxl-k350qvg-s1>`__ 3.5" 320x240 QVGA LCD display panel.

**Required Tools**

-  The latest `CapTIvate Design Center <http://www.ti.com/tool/MSPCAPTDSNCTR>`__ PC GUI Tool must be installed on a host PC, Mac, or Linux machine
-  A `BOOSTXL-CAPKEYPAD <http://www.ti.com/tool/boostxl-capkeypad>`__ programmed with the BOOSTXL-CAPKEYPAD-Demo firmware example
-  A `BOOSTXL-K350QVG-S1 <http://www.ti.com/tool/boostxl-k350qvg-s1>`__
-  A `MSP-EXP430F5529LP LaunchPad <http://www.ti.com/tool/msp-exp430f5529lp>`__
-  A micro-USB cable is required to connect the MSP-EXP430F5529LP to the host computer

**Assumptions**

-  This guide assumes that CapTIvate Design Center is already installed on the host PC. For installation instructions, see the `CapTIvate Design Center <ch_designcenter.html>`__ chapter.

Step 1: Program LaunchPad
^^^^^^^^^^^^^^^^^^^^^^^^^

Before connecting the LaunchPad to the BoosterPack, it is good practice to program it first to ensure that there are no IO assignment conflicts. The LaunchPad software example is stored in the CapTIvate Design Center workspace in the BOOSTXL-CAPKEYPAD project directory. Within the BOOSTXL-CAPKEYPAD project directory, there is a sub folder named *hostmcu\_demo\_src*. This contains the LaunchPad example projects. For this demo, the host project is *MSP-EXP430F5529LP\_KeypadHostDemo\_QVGA*. If you are using the default installation directories, this location would be as follows:

    *C:/Users/USERNAME/CapTIvateDesignCenter\_X\_XX\_XX\_XX/CapTIvateDesignCenterWorkspace/BOOSTXL-CAPKEYPAD/hostmcu\_demo\_src/MSP-EXP430F5529LP\_KeypadHostDemo\_QVGA*

Import this example project into Code Composer Studio or IAR Embedded Workbench. Then, compile and build the project. Connect the MSP-EXP430F5529LP to the host computer with USB cable, and download the demo project to the LaunchPad. For instructions on how to import a project into CCS or IAR, view the `loading and running generated projects <ch_designcenter.html#loading-and-running-generated-projects>`__ guide in the CapTIvate Design Center chapter.

Step 2: Assemble Hardware
^^^^^^^^^^^^^^^^^^^^^^^^^

Next, disconnect the LaunchPad from the USB cable in order to remove power. Then, connect the LaunchPad to the top of the BOOSTXL-CAPKEYPAD to create a 2-board stack. This uses headers J1-J4 on the BOOSTXL-CAPKEYPAD, as well as J1-J4 on the LaunchPad. Once the keypad and LaunchPad are connected, attach the QVGA LCD BoosterPack on top of the LaunchPad, creating a 3-board stack. The assembled stack is shown below.

.. figure:: images/evm_boostxl_capkeypad/Top_LP_Stackup_LCD.png
   :alt: BOOSTXL-CAPKEYPAD w/ MSP-EXP430F5529LP and BOOSTXL-K350QVG-S1 - Perspective View

   BOOSTXL-CAPKEYPAD w/ MSP-EXP430F5529LP and BOOSTXL-K350QVG-S1 - Perspective View

.. figure:: images/evm_boostxl_capkeypad/Side_LP_Stackup.png
   :alt: BOOSTXL-CAPKEYPAD w/ MSP-EXP430F5529LP and BOOSTXL-K350QVG-S1 - Side View

   BOOSTXL-CAPKEYPAD w/ MSP-EXP430F5529LP and BOOSTXL-K350QVG-S1 - Side View

Step 3: Power Up and Test
^^^^^^^^^^^^^^^^^^^^^^^^^

Reconnect power to the LaunchPad by reconnecting the USB cable. Then, touch any of the buttons on the BOOSTXL-CAPKEYPAD to see the keystrokes logged onto the LCD!

**DONE!** This concludes the BOOSTXL-CAPKEYPAD + MSP-EXP430F5529LP + QVGA LCD demo. Feel free to build your own code on top of the examples!

Troubleshooting
^^^^^^^^^^^^^^^

If the BoosterPack is not responsive after providing power, it may not have the default BOOSTXL-CAPKEYPAD-Demo software programmed on it. This can happen if it was reprogrammed with a different application at some point. If you experience this issue, ensure that the correct demo software is programmed to the BOOSTXL-CAPKEYPAD. Programming the BOOSTXL-CAPKEYPAD requires the use of a CAPTIVATE-PGMR module.

Out-of-Box Experience with MSP-EXP430F5529LP as a USB Keyboard
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example demonstrates how to mate the `BOOSTXL-CAPKEYPAD <http://www.ti.com/tool/boostxl-capkeypad>`__ to an `MSP-EXP430F5529LP LaunchPad <http://www.ti.com/tool/msp-exp430f5529lp>`__ in order to implement a 12-key numeric keypad with USB HID connectivity. The final completed BOOSTXL-CAPKEYPAD + MSP-ESP430F5529LP stack will enumerate on a host computer as a USB keyboard. Then, you can use the BOOSTXL-CAPKEYPAD to enter numbers into any running application on your host computer that takes keystrokes.

**Required Tools**

-  The latest `CapTIvate Design Center <http://www.ti.com/tool/MSPCAPTDSNCTR>`__ PC GUI Tool must be installed on a host PC, Mac, or Linux machine
-  A `BOOSTXL-CAPKEYPAD <http://www.ti.com/tool/boostxl-capkeypad>`__ programmed with the BOOSTXL-CAPKEYPAD-Demo firmware example
-  A `MSP-EXP430F5529LP LaunchPad <http://www.ti.com/tool/msp-exp430f5529lp>`__
-  A micro-USB cable is required to connect the MSP-EXP430F5529LP to the host computer

**Assumptions**

-  This guide assumes that CapTIvate Design Center is already installed on the host PC. For installation instructions, see the `CapTIvate Design Center <ch_designcenter.html>`__ chapter.

Step 1: Program LaunchPad
^^^^^^^^^^^^^^^^^^^^^^^^^

Before connecting the LaunchPad to the BoosterPack, it is good practice to program it first to ensure that there are no IO assignment conflicts. The LaunchPad software example is stored in the CapTIvate Design Center workspace in the BOOSTXL-CAPKEYPAD project directory. Within the BOOSTXL-CAPKEYPAD project directory, there is a sub folder named *hostmcu\_demo\_src*. This contains the LaunchPad example projects. For this demo, the host project is *MSP-EXP430F5529LP\_KeypadHostDemo\_USBNumPad*. If you are using the default installation directories, this location would be as follows:

    *C:/Users/USERNAME/CapTIvateDesignCenter\_X\_XX\_XX\_XX/CapTIvateDesignCenterWorkspace/BOOSTXL-CAPKEYPAD/hostmcu\_demo\_src/MSP-EXP430F5529LP\_KeypadHostDemo\_USBNumPad*

Import this example project into Code Composer Studio or IAR Embedded Workbench. Then, compile and build the project. Connect the MSP-EXP430F5529LP to the host computer with USB cable, and download the demo project to the LaunchPad. For instructions on how to import a project into CCS or IAR, view the `loading and running generated projects <ch_designcenter.html#loading-and-running-generated-projects>`__ guide in the CapTIvate Design Center chapter.

Step 2: Assemble Hardware
^^^^^^^^^^^^^^^^^^^^^^^^^

Next, disconnect the LaunchPad from the USB cable in order to remove power. Then, connect the LaunchPad to the top of the BOOSTXL-CAPKEYPAD to create a 2-board stack. This uses headers J1-J4 on the BOOSTXL-CAPKEYPAD, as well as J1-J4 on the LaunchPad.

Step 3: Power Up and Test
^^^^^^^^^^^^^^^^^^^^^^^^^

Reconnect power to the LaunchPad by reconnecting the USB cable. Then, touch any of the buttons on the BOOSTXL-CAPKEYPAD to see the keystrokes logged on a running computer. To prevent corruption of any open documents, it's a good idea to open up a blank text editor such as Notepad before running this demo. That way, test keystrokes from the BoosterPack go into Notepad and not into any other open files!

**Key Mapping** The number keys map directly to the numeric equivalent keystrokes on the host computer. The check button maps as a return keystroke, and the 'x' button maps as a backspace keystroke.

**DONE!** This concludes the BOOSTXL-CAPKEYPAD + MSP-EXP430F5529LP USB HID Keyboard demo. Feel free to build your own code on top of the example!

Troubleshooting
^^^^^^^^^^^^^^^

If the system is not responsive after providing power, it may not have the default BOOSTXL-CAPKEYPAD-Demo software programmed on it. This can happen if it was reprogrammed with a different application at some point. If you experience this issue, ensure that the correct demo software is programmed to the BOOSTXL-CAPKEYPAD. Programming the BOOSTXL-CAPKEYPAD requires the use of a CAPTIVATE-PGMR module.

Hardware
--------

The BOOSTXL-CAPKEYPAD hardware contains many connection options to enable various LaunchPad use-cases and CapTIvate evaluation use-cases. This section describes hardware configuration.

Mechanical Design
~~~~~~~~~~~~~~~~~

The BOOSTXL-CAPKEYPAD consists of a 4-layer, 1.6mm thick FR4 printed circuit board with a 3mm acrylic overlay material bonded to the PCB using 3M 467MP adhesive. The 3mm overlay represents a typical product overlay thickness. LED illumination is provided from the bottom side of the board through LED through holes in the PCB. Graphics are applied in between the PCB and the acrylic overlay.

Connection Headers
~~~~~~~~~~~~~~~~~~

The BOOSTXL-CAPKEYPAD has connection points for interfacing to a LaunchPad, a CAPTIVATE-PGMR module, and prototype sensors.

LaunchPad Interface (BoosterPack Header)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The BOOSTXL-CAPKEYPAD features 40-pin BoosterPack standard headers (J1-J4). These headers are top-side only, meaning that the BOOSTXL-CAPKEYPAD is intended to be used at the bottom of a LaunchPad stack. This allows LCD displays on LaunchPads to be visible while using the keypad. The BoosterPack header pinout is shown below.

.. figure:: images/evm_boostxl_capkeypad/BPHeader.png
   :alt: BoosterPack Pinout

   BoosterPack Pinout

CAPTIVATE-PGMR Interface
^^^^^^^^^^^^^^^^^^^^^^^^

The BOOSTXL-CAPKEYPAD may be connected to a CAPTIVATE-PGMR by attaching the CAPTIVATE-PGMR module to header J5 at the top of the board.

.. figure:: images/evm_boostxl_capkeypad/J5.png
   :alt: CAPTIVATE-PGMR Header

   CAPTIVATE-PGMR Header

Prototyping Interface
^^^^^^^^^^^^^^^^^^^^^

The keypad's TX lines are connected to the MCU through jumper block J10.

.. figure:: images/evm_boostxl_capkeypad/jumpers_proto_default.png
   :alt: Header J10

   Header J10

To add an off-board sensor for prototyping purposes, remove any of the three TX jumpers in header J10. Then, connect a prototype sensor to the MCU-side (highlighted below).

.. figure:: images/evm_boostxl_capkeypad/jumpers_proto_removed.png
   :alt: Header J10 - Jumpers Removed

   Header J10 - Jumpers Removed

Configuration Jumpers
~~~~~~~~~~~~~~~~~~~~~

The BOOSTXL-CAPKEYPAD has several configuration jumpers. The default locations are shown below.

.. figure:: images/evm_boostxl_capkeypad/jumpers_default.png
   :alt: J6, J7, J8, J9 Default Position

   J6, J7, J8, J9 Default Position

Moving jumpers from their default locations can enable the alternate use-cases introduced below.

RX/TX Jumpers
^^^^^^^^^^^^^

The RX/TX jumpers allow the UART RX and TX signals from the MSP430FR2522 CapTIvate MCU to be routed to either the HID Bridge communications channel on the CAPTIVATE-PGMR or the back channel serial COM port on the CAPTIVATE-PGMR. The default setting is HID Bridge, which allows the CapTIvate Design Center to be used for sensor status visualization. Alternately, jumpers J6 (RX) and J7 (TX) can be set to the COM port position to stream data to a host PC virtual COM port.

.. figure:: images/evm_boostxl_capkeypad/jumpers_backchannel.png
   :alt: J6, J7 COM Port Position

   J6, J7 COM Port Position

It is also possible to remove the J6 and J7 jumpers altogether, and wire the UART center pins out to a different board.

V+ Supply
^^^^^^^^^

When powering the BOOSTXL-CAPKEYPAD from a CAPTIVATE-PGMR module via header J5, it is possible to use either a clean LDO-regulated supply or the EnergyTrace supply for measuring supply current from Code Composer Studio. The default position is the LDO-regulated supply. To use the EnergyTrace supply, move jumper J8 to the 'ET' position. This jumper has no effect when a LaunchPad is connected instead of a CAPTIVATE-PGMR module. In that case, the LaunchPad supplies V+ directly via pin 1 of J1 (the BoosterPack supply point).

.. figure:: images/evm_boostxl_capkeypad/jumpers_et.png
   :alt: J8 EnergyTrace Supply Position

   J8 EnergyTrace Supply Position

IRQ Pin Location
^^^^^^^^^^^^^^^^

The I2C slave interface IRQ pin may be connected to one of two locations in the BoosterPack header. The default location is IRQA (BoosterPack pin 12). By moving jumper J9 to IRQB, it is possible to bring the IRQ signal out on BoosterPack pin 27. This may be required if another BoosterPack requires pin 12.

.. figure:: images/evm_boostxl_capkeypad/jumpers_irq.png
   :alt: J9 IRQB Position

   J9 IRQB Position

Software Examples
-----------------

This section describes the software examples that are available for the BOOSTXL-CAPKEYPAD. In the case of this BoosterPack, these software examples run on the MSP430FR2522 device that exists on the BOOSTXL-CAPKEYPAD itself. This is different from other BoosterPacks, where the software examples are for a host LaunchPad MCU only. Several host LaunchPad software examples are also provided for use with the BOOSTXL-CAPKEYPAD-Demo project. See the `Getting Started <ch_evm_boostxl_capkeypad.html#getting-started>`__ section for more information on the available host LaunchPad demonstrations.

Running an Example Project
~~~~~~~~~~~~~~~~~~~~~~~~~~

To run an example project, it is necessary to do the following:

1. If it is not already connected, connect a CAPTIVATE-PGMR module to the BOOSTXL-CAPKEYPAD.
2. Import, build, and program the specific example that you are using onto the MSP430FR2522 target MCU on the BOOSTXL-CAPKEYPAD module. Follow these steps to `load and run generated firmware projects <ch_designcenter.html#loading-and-running-generated-projects>`__. `Example project locations <ch_evm_boostxl_capkeypad.html#example-project-locations>`__ are described below. The BOOSTXL-CAPKEYPAD module ships pre-programmed for the BOOSTXL-CAPKEYPAD-Demo software example.
3. Start the CapTIvate Design Center using the icon that was installed on your desktop.
4. Click *File* -> *Project Open* from the menu bar and select the desired project directory. `Click here for help with CapTIvate™ Design Center <ch_designcenter.html#menu-descriptions>`__. The project's `main window <ch_designcenter.html#introduction>`__ is the design canvas and is pre-populated with the microcontroller and selected sensors matching the hardware for this demo.
5. `Enable Communications <ch_designcenter.html#enable-target-communications-in-the-design-center>`__ in the CapTIvate™ Design Center to begin the demonstration.
6. View the data for different sensors when you approach and touch the panel. Note: If the MCU is in wake-on-proximity mode, there may appear to be no activity. Bring your hand near or touch the board to activate the MCU.

Example Project Locations
~~~~~~~~~~~~~~~~~~~~~~~~~

During the CapTIvate™ Design Center installation process, example CapTIvate Design Center projects and BOOSTXL-CAPKEYPAD MSP430FR2522 firmware projects are placed in the user's home directory under "CaptivateDesignCenter/CaptivateDesignCenterWorkspace". On Windows 7, this would be:

*C:/Users/USERNAME/CapTIvateDesignCenter\_X\_XX\_XX\_XX/CapTIvateDesignCenterWorkspace/*

BOOSTXL-CAPKEYPAD Out-of-Box Software Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The BOOSTXL-CAPKEYPAD project is the out-of-box demonstration software project. This is the software that comes pre-programmed from TI on the BOOSTXL-CAPKEYPAD. It is also the software that enables the LED backlighting features and I2C slave host processor interface.

Overview
^^^^^^^^

The CapTIvate Design Center project canvas for this example is shown below.

.. figure:: images/evm_boostxl_capkeypad/project_canvas_basic.png
   :alt: BOOSTXL-CAPKEYPAD Design Canvas

   BOOSTXL-CAPKEYPAD Design Canvas

This software example enables the following key out-of-box functionality:

-  A 12-key numeric keypad sensor
-  A proximity and guard sensor
-  An I2C slave interface to a host processor using hardware I2C with the eUSCI\_B0 module
-  An I2C master interface to the LP3943 LED driver using a software I2C approach
-  Bi-directional UART communication with the CapTIvate Design Center using the CapTIvate communications library

To begin working with this panel, go through the steps for `running an example project <ch_evm_boostxl_capkeypad.html#running-an-example-project>`__ and open the BOOSTXL-CAPKEYPAD project.

Capacitive Touch Sensor Configuration
'''''''''''''''''''''''''''''''''''''

The sensor configuration for the out-of-box experience described here. The MSP430FR2522 target MCU has 8 touch sensing IOs. 5 are used as RX's, and the remaining 3 are used as TX's. The keypad sensor is implemented as a 4 RX x 3 TX mutual capacitance matrix. The proximity and guard channel utilizes a dedicated RX channel, but it re-purposes the three TX channels from the keypad electrodes and merges them to act as one large TX when in proximity/guard mode. The TX timing is shown in the figure below.

.. figure:: images/evm_boostxl_capkeypad/demo_timing_tx.png
   :alt: BOOSTXL-CAPKEYPAD Demo TX Electrode Timing

   BOOSTXL-CAPKEYPAD Demo TX Electrode Timing

Software Flow
'''''''''''''

The BOOSTXL-CAPKEYPAD demo software operates in one of three states:

1. Active mode

   -  CapTIvate is periodically scanning all 12 keys and the prox/guard sensor at a 14ms (~70 Hz) rate
   -  Backlight LEDs are active
   -  If UART is enabled, sensor and element packets are sent out via the UART port
   -  When a new sample is available, the IRQ line is pulled low to indicate to a host LaunchPad that data is available

2. Wake-on-proximity mode

   -  CapTIvate is periodically scanning just the prox/guard sensor using the wake-on-prox state machine in HW with the CPU off at a 100ms (10 Hz) rate
   -  Backlight LEDs are off
   -  If UART is enabled, packets may be received but no packets are being sent
   -  The IRQ pin stays high and does not signal the host LaunchPad

3. Shutdown mode

   -  CapTIvate is shut down and no sensors are updated
   -  Backlight LEDs are off
   -  The IRQ pin stays high and does not signal the host LaunchPad
   -  All MCU clocks are off, and MCU is in LPM4 waiting for a wakeup request from a host processor over I2C

The current operating state is determined by the 3 control bits in the system control word (managed by the host LaunchPad over I2C), as well as the current status of the keypad. The BOOSTXL-CAPKEYPAD will power up in active mode, scanning all electrodes, with LED backlighting on. If no touch is detected within 300 samples (4-5 seconds typical) then wake-on-proximity mode will be entered. If a proximity event is detected, then the system will revert back to active mode automatically. Shutdown mode is only entered or existed if a host MCU manipulates the shutdown bit in the system control word.

**Initialization**

When the BOOSTXL-CAPKEYPAD powers up, the MSP430FR2522 initializes the following items:

1. Board Init

   -  Set 1 FRAM wait state
   -  16 MHz MCLK, sourced from the DCO
   -  2 MHz SMCLK, sourced from the DCO
   -  32 kHz ACLK, sourced from REFO
   -  Re-map eUSCI\_A and eUSCI\_B to alternate locations
   -  Configure ports (hardware UART, hardware I2C slave, software I2C)
   -  Enable interrupts

2. Host Interface

   -  Enable the hardware I2C interface (eUSCI\_B0) in slave mode to communicate with a host LaunchPad
   -  I2C slave address is 0x0B

3. LED Control

   -  Start the software I2C driver for communication with the LP3943 LED driver.
   -  Turn off all LEDs to start

4. Keypad

   -  Start CapTIvate
   -  Calibrate the keypad and prox/guard sensor
   -  Start the periodic interval timer which controls the sensor refresh rate

**The application main routine is shown below.**

.. code:: c

    //*****************************************************************************
    // Includes
    //*****************************************************************************

    #include "board.h"
    #include "system.h"
    #include "host_interface.h"
    #include "boostxl-capkeypad.h"

    //*****************************************************************************
    // Global Variables
    //*****************************************************************************

    //! \brief System_topLevel is the top level system control and status
    //! structure.  It contains the control and status words for the
    //! BOOSTXL-CAPKEYPAD.
    //! For information on the fields in this structure, see system.h.
    //!
    volatile System_controlAndStatus System_topLevel;

    //! \brief If a shutdown was requested, lock the applicaiton in LPM4 with
    //! the keypad powered down until the shutdown request is cleared.  After the
    //! shutdown request is cleared,the keypad is re-initialized and the shutdown
    //! function will exit.
    static inline void shutdownHandler(void);

    //*****************************************************************************
    // Function Implementations
    //*****************************************************************************

    void main(void)
    {
        // Initialize all of the needed submodules.
        // The watchdog timer is disabled before CINIT.
        Board_init();
        HostInterface_init();
        LEDControl_init();
        BXLCapKeypad_init();

        // Set default top level system status
        g_uiApp.state = eUIActive;
        System_topLevel.statusWord = SYSTEM__STAT_ACTIVE;
        System_topLevel.lastStatusWord = SYSTEM__STAT_ACTIVE;
        System_topLevel.controlWord =\
                SYSTEM__CTRL_WOP_ENABLE |\
                SYSTEM__CTRL_UART_ENABLE;

        // This is the background execution loop.
        // BXLCapKeypad_run checks to see if it is time to update
        // the keypad status.  If it is, an update will be performed.
        // This function also handles entering and exiting a wake-on-prox state.
        // BXLCapKeypad_updateCapTIvateComm checks to see if there is any incoming
        // data from the CapTIvate Design Center via the UART interface that needs
        // to be handled.
        // BXLCapKeypad_sleep is a safe sleep function that ensures no CapTIvate
        // flags are pending when a low power sleep mode is entered.
        while(1)
        {
            shutdownHandler();
            BXLCapKeypad_run();
            BXLCapKeypad_updateCapTIvateComm();
            BXLCapKeypad_sleep();
        }
    }

    void shutdownHandler(void)
    {
        __bic_SR_register(GIE);
        if (System_topLevel.controlWord & SYSTEM__CTRL_SHUTDOWN)
        {
            BXLCapKeypad_stop();
            do
            {
                __bis_SR_register(LPM4_bits | GIE);
                __bic_SR_register(GIE);
            } while(System_topLevel.controlWord & SYSTEM__CTRL_SHUTDOWN);
            BXLCapKeypad_init();
        }
        __bis_SR_register(GIE);
    }

BOOSTXL-CAPKEYPAD-EMC Noise Immunity Software Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The BOOSTXL-CAPKEYPAD-EMC software example implements a noise-tolerant 12-key numeric keypad by configuring the CapTIvate software library to utilize its noise immunity features. When running this software example, the BOOSTXL-CAPKEYPAD can pass an IEC 61000-4-6 conducted noise immunity test at stress level 2 (3Vrms) with noise coupled directly into the DC power supply.

Overview
^^^^^^^^

The CapTIvate Design Center project canvas for this example is shown below.

.. figure:: images/evm_boostxl_capkeypad/emc_canvas.png
   :alt: BOOSTXL-CAPKEYPAD-EMC Design Canvas

   BOOSTXL-CAPKEYPAD-EMC Design Canvas

This example is configured with the following settings:

-  A 20ms active mode scan period (50 Hz).
-  A 4 MHz conversion frequency for all 12 keys
-  A total measurement time AND post-processing time of approximately 15ms
-  Frequency hopping with outlier removal enabled
-  2x oversampling enabled
-  2x touch and proximity debounce-in threshold
-  Count filter beta = 2 for AC noise attenuation
-  CapTIvate automatic power down is disabled. This uses more power, but allows for faster scanning of electrodes because the CapTIvate LDO does not need to start up for each conversion window as it is always on.

The keypad consists of a 4-RX, 3-TX mutual capacitance matrix. Two buttons are measured at a time (in parallel), thus a total of 6 measurement slots are needed. For each measurement slot, the electrodes are measured at 4 different conversion frequencies 2 different times, for a total of 8 conversions per measurement slot. Thus, the actual number of conversion measurement slots that run per refresh is 48. This can be seen in the logic capture below.

.. figure:: images/evm_boostxl_capkeypad/emc_demo_timing_wide.png
   :alt: BOOSTXL-CAPKEYPAD-EMC Timing - Wide Capture

   BOOSTXL-CAPKEYPAD-EMC Timing - Wide Capture

.. figure:: images/evm_boostxl_capkeypad/emc_demo_timing_zoom.png
   :alt: BOOSTXL-CAPKEYPAD-EMC Timing - Zoom Capture

   BOOSTXL-CAPKEYPAD-EMC Timing - Zoom Capture

As can be seen in the figures above, the total conversion and post-processing time for all 12 keys in the keypad is 15-16ms. Thus, as scanning window of 20ms is selected to leave 4ms-5ms of reserve time for handing deviations in measurement time due to temperature shifts and touch events.

To begin working with this panel, go through the steps for `running an example project <ch_evm_boostxl_capkeypad.html#running-an-example-project>`__ and open the BOOSTXL-CAPKEYPAD-EMC project.

Noise immunity test results are shown in the `resources section <ch_evm_boostxl_capkeypad.html#conducted-noise-immunity>`__.

Notes
^^^^^

-  The EMC demo does not enable LED backlighting to conserve code space on the MSP430FR2522.
-  The `CAPTIVATE-ISO <ch_evm.html#captivate-iso-communications-isolation-pcb>`__ isolation module may be utilized with the `CAPTIVATE-PGMR <ch_evm.html#captivate-pgmr-programmer-pcb-overview>`__ to view sensor data during a noise test.

BOOSTXL-CAPKEYPAD-Prototyping Software Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The BOOSTXL-CAPKEYPAD-Prototyping software example provides a way to "wire in" prototype sensors that were created externally. This enables copper-tape prototyping for up to 3 electrodes.

Overview
^^^^^^^^

| The CapTIvate Design Center project canvas for this example is shown below.
| |BOOSTXL-CAPKEYPAD-Prototyping Design Canvas|

To connect a prototype sensor, connect a jumper wire to one of the three CAPx.y pins in J10, as described in the `hardware section <ch_evm_boostxl_capkeypad.html#prototyping-interface>`__.

This example is configured with the following settings:

-  A 33ms active mode scan period (30 Hz).
-  A 1 MHz conversion frequency for all 3 sensors
-  A total measurement time of approximately 1.6ms for all 3 sensors

To begin working with this panel, go through the steps for `running an example project <ch_evm_boostxl_capkeypad.html#running-an-example-project>`__ and open the BOOSTXL-CAPKEYPAD-Prototyping project.

Notes
^^^^^

-  Once you connect a prototype sensor, you may need to re-calibrate the sensor. To do this from the CapTIvate Design Center, open the sensor customizer by double-clicking it. Then, open the *Conversion Control* tab. At the bottom of the tab, select the *Force\_Recalibration* button at the bottom of the tab (shown below). Performing a re-calibration will re-tune the CapTIvate analog settings for the sensor you have added. For details on calibration, see the `calibration <ch_library.html#calibration>`__ section of the software library chapter.

   .. figure:: images/evm_boostxl_capkeypad/recal_btn.png
      :alt: BOOSTXL-CAPKEYPAD-Prototyping Design Canvas

      BOOSTXL-CAPKEYPAD-Prototyping Design Canvas

-  When using wires to connect an external electrode, it is important to be aware that the wires themselves are touch sensitive and form a portion of the sensing electrode. You may see different performance depending on how the electrode wires are positioned.

Resources
---------

This section contains resource tools to aid in development with the BOOSTXL-CAPKEYPAD.

BOOSTXL-CAPKEYPAD-Demo I2C Slave Register Map Specification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The BOOSTXL-CAPKEYPAD-Demo firmware that is pre-programmed on the BOOSTXL-CAPKEYPAD from the factory provides an I2C slave interface composed of an SDA (data) pin, SCL (clock) pin, and IRQ (interrupt) pin. All three pins are open-drain type signals at V+ logic level (3.3V typical). The purpose of this I2C interface is enabling low power communication with a host LaunchPad MCU. At power-up, the BOOSTXL-CAPKEYPAD-Demo example provides a simple register-based I2C interface that enables a host processor to read the current status of the keypad. It also provides some control to the LaunchPad to be able to manipulate the configuration of the keypad to optimize for response time or low power. The accessible registers are described below.

I2C Slave Address
^^^^^^^^^^^^^^^^^

The I2C bus slave address for the BOOSTXL-CAPKEYPAD is **0x0B**. This can be adjusted in software if needed.

I2C Register File
^^^^^^^^^^^^^^^^^

+--------------------+----------------------------------+----------------------------------------------------------------------------------------+
| Register Address   | Name                             | Description                                                                            |
+====================+==================================+========================================================================================+
| 0x00               | Control Word, lower 8 bits       | Contains bits for configuring the operational state of the keypad.                     |
+--------------------+----------------------------------+----------------------------------------------------------------------------------------+
| 0x01               | Control Word, upper 8 bits       | The upper 8 bits of the control word are reserved and not used.                        |
+--------------------+----------------------------------+----------------------------------------------------------------------------------------+
| 0x02               | Status Word, lower 8 bits        | Contains the current top level status flags, and current touch status for keys 1-4     |
+--------------------+----------------------------------+----------------------------------------------------------------------------------------+
| 0x03               | Status Word, upper 8 bits        | Contains the current touch status for keys 5-Cancel                                    |
+--------------------+----------------------------------+----------------------------------------------------------------------------------------+
| 0x04               | Last Status Word, lower 8 bits   | Contains the previous top level status flags, and previous touch status for keys 1-4   |
+--------------------+----------------------------------+----------------------------------------------------------------------------------------+
| 0x05               | Last Status Word, upper 8 bits   | Contains the previous touch status for keys 5-Cancel                                   |
+--------------------+----------------------------------+----------------------------------------------------------------------------------------+

I2C Register Description: 0x00, Control Word Lower 8 Bits
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

+----------------+---------+---------+---------+---------+---------+---------------+-----------------------+------------+
| Bit:           | BIT7    | BIT6    | BIT5    | BIT4    | BIT3    | BIT2          | BIT1                  | BIT0       |
+================+=========+=========+=========+=========+=========+===============+=======================+============+
| Description:   | Rsvd.   | Rsvd.   | Rsvd.   | Rsvd.   | Rsvd.   | UART Enable   | Wake-on-Prox Enable   | Shutdown   |
+----------------+---------+---------+---------+---------+---------+---------------+-----------------------+------------+
| Reset:         | 0       | 0       | 0       | 0       | 0       | 1             | 1                     | 0          |
+----------------+---------+---------+---------+---------+---------+---------------+-----------------------+------------+
| RW:            | R       | R       | R       | R       | R       | RW            | RW                    | RW         |
+----------------+---------+---------+---------+---------+---------+---------------+-----------------------+------------+

**BIT0 - Shutdown**

The shutdown bit resets to 0 at power-up. Setting the shutdown bit places the BOOSTXL-CAPKEYPAD into its lowest power state. In shutdown mode, the capacitive touch keypad is not updated and the LED backlighting is disabled. The only way to wake up the keypad is to clear the shutdown bit or reset the keypad.

**BIT1 - Wake-on-Prox Enable**

The wake-on-proximity enable bit resets to 1 at power-up. When set, the BOOSTXL-CAPKEYPAD will enter a wake-on-proximity mode after a period of inactivity. When no touches have been detected for several seconds, the LED backlighting will fade to off and the CapTIvate keypad will only measure the proximity sensor. In this mode, no IRQ requests are sent to the host processor while the proximity sensor is being scanned. If a proximity detection occurs, the keypad will wake up and transition to active mode, reporting all samples to the host MCU via the IRQ pin. If this bit is cleared, the BOOSTXL-CAPKEYPAD will remain in active mode all of the time. This means that the LED backlighting will remain active, and after every new touch sample is acquired the host will be notified via the IRQ pin.

**BIT2 - UART Enable**

The UART enable bit resets to 1 at power-up. When set, the BOOSTXL-CAPKEYPAD transmits sensor and element packets via the UART interface when in active mode. The UART interface is located in the 20-pin CAPTIVATE-PGMR header at the top of the BoosterPack. This interface enables the CapTIvate Design Center to view real time sensor data from the BOOSTXL-CAPKEYPAD when a CAPTIVATE-PGMR module is attached between the BOOSTXL-CAPKEYPAD and a host computer. Clearing BIT2 disables this UART interface, and allows the BOOSTXL-CAPKEYPAD to run in a lower power state because the UART baud rate clock is not required. Thus, if a host LaunchPad wants to communicate with the BOOSTXL-CAPKEYPAD, but use of CapTIvate Design Center is not needed, the UART enable bit may be cleared to conserve power.

I2C Register Description: 0x01, Control Word Upper 8 Bits
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

+----------------+---------+---------+---------+---------+---------+---------+---------+---------+
| Bit:           | BIT7    | BIT6    | BIT5    | BIT4    | BIT3    | BIT2    | BIT1    | BIT0    |
+================+=========+=========+=========+=========+=========+=========+=========+=========+
| Description:   | Rsvd.   | Rsvd.   | Rsvd.   | Rsvd.   | Rsvd.   | Rsvd.   | Rsvd.   | Rsvd.   |
+----------------+---------+---------+---------+---------+---------+---------+---------+---------+
| Reset:         | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |
+----------------+---------+---------+---------+---------+---------+---------+---------+---------+
| RW:            | R       | R       | R       | R       | R       | R       | R       | R       |
+----------------+---------+---------+---------+---------+---------+---------+---------+---------+

Register 0x01 is reserved control word space and is not used.

I2C Register Description: 0x02, Status Word Lower 8 Bits
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

+----------------+---------+---------+---------+---------+---------+---------+--------+----------+
| Bit:           | BIT7    | BIT6    | BIT5    | BIT4    | BIT3    | BIT2    | BIT1   | BIT0     |
+================+=========+=========+=========+=========+=========+=========+========+==========+
| Description:   | Key 4   | Key 3   | Key 2   | Key 1   | Touch   | Guard   | Prox   | Active   |
+----------------+---------+---------+---------+---------+---------+---------+--------+----------+
| Reset:         | 0       | 0       | 0       | 0       | 0       | 0       | 0      | 1        |
+----------------+---------+---------+---------+---------+---------+---------+--------+----------+
| RW:            | R       | R       | R       | R       | R       | R       | R      | R        |
+----------------+---------+---------+---------+---------+---------+---------+--------+----------+

**BIT0 - Active**

This bit indicates the current user interface state. '1' corresponds to ACTIVE mode. In ACTIVE mode, the BOOSTXL-CAPKEYPAD is scanning all electrodes, reporting new samples to the host via the IRQ pin, and LED backlighting is enabled. '0' corresponds to Wake-on-Prox mode. In Wake-on-Prox mode, the BOOSTXL-CAPKEYPAD is only scanning the proximity sensor, IRQ signals to the host are deactivated, and LED backlighting is disabled. The BOOSTXL-CAPKEYPAD will automatically transition between ACTIVE and Wake-on-Prox states when the Wake-on-Prox enable bit is set in the control word register.

**BIT1 - Prox**

This bit indicates whether proximity is detected near the BOOSTXL-CAPKEYPAD. A value of '1' = true, and '0' = false.

**BIT2 - Guard**

This bit indicates whether the guard channel masking function is activated. A value of '1' = true, and '0' = false.

**BIT3 - Touch**

This bit indicates whether a touch is currently detected on any key (global touch detect). A value of '1' = true, and '0' = false.

**BIT4 - Key 1 Touch**

This bit indicates whether a touch is currently detected on key 1. A value of '1' = true, and '0' = false.

**BIT5 - Key 2 Touch**

This bit indicates whether a touch is currently detected on key 2. A value of '1' = true, and '0' = false.

**BIT6 - Key 3 Touch**

This bit indicates whether a touch is currently detected on key 3. A value of '1' = true, and '0' = false.

**BIT7 - Key 4 Touch**

This bit indicates whether a touch is currently detected on key 4. A value of '1' = true, and '0' = false.

I2C Register Description: 0x03, Status Word Upper 8 Bits
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

+----------------+--------------+---------+-------------+---------+---------+---------+---------+---------+
| Bit:           | BIT7         | BIT6    | BIT5        | BIT4    | BIT3    | BIT2    | BIT1    | BIT0    |
+================+==============+=========+=============+=========+=========+=========+=========+=========+
| Description:   | Cancel Key   | Key 0   | Enter Key   | Key 9   | Key 8   | Key 7   | Key 6   | Key 5   |
+----------------+--------------+---------+-------------+---------+---------+---------+---------+---------+
| Reset:         | 0            | 0       | 0           | 0       | 0       | 0       | 0       | 0       |
+----------------+--------------+---------+-------------+---------+---------+---------+---------+---------+
| RW:            | R            | R       | R           | R       | R       | R       | R       | R       |
+----------------+--------------+---------+-------------+---------+---------+---------+---------+---------+

**BIT0 - Key 5 Touch**

This bit indicates whether a touch is currently detected on key 5. A value of '1' = true, and '0' = false.

**BIT1 - Key 6 Touch**

This bit indicates whether a touch is currently detected on key 6. A value of '1' = true, and '0' = false.

**BIT2 - Key 7 Touch**

This bit indicates whether a touch is currently detected on key 7. A value of '1' = true, and '0' = false.

**BIT3 - Key 8 Touch**

This bit indicates whether a touch is currently detected on key 8. A value of '1' = true, and '0' = false.

**BIT4 - Key 9 Touch**

This bit indicates whether a touch is currently detected on key 9. A value of '1' = true, and '0' = false.

**BIT5 - Enter Key Touch**

This bit indicates whether a touch is currently detected on the enter key. A value of '1' = true, and '0' = false.

**BIT6 - Key 0 Touch**

This bit indicates whether a touch is currently detected on key 0. A value of '1' = true, and '0' = false.

**BIT0 - Cancel (X) Key Touch**

This bit indicates whether a touch is currently detected on the cancel (X) key. A value of '1' = true, and '0' = false.

I2C Register Description: 0x04, Last Status Word Lower 8 Bits
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

+----------------+---------+---------+---------+---------+---------+---------+--------+----------+
| Bit:           | BIT7    | BIT6    | BIT5    | BIT4    | BIT3    | BIT2    | BIT1   | BIT0     |
+================+=========+=========+=========+=========+=========+=========+========+==========+
| Description:   | Key 4   | Key 3   | Key 2   | Key 1   | Touch   | Guard   | Prox   | Active   |
+----------------+---------+---------+---------+---------+---------+---------+--------+----------+
| Reset:         | 0       | 0       | 0       | 0       | 0       | 0       | 0      | 1        |
+----------------+---------+---------+---------+---------+---------+---------+--------+----------+
| RW:            | R       | R       | R       | R       | R       | R       | R      | R        |
+----------------+---------+---------+---------+---------+---------+---------+--------+----------+

The 'last status word' registers (0x04 and 0x05) provide the same information as the current status word (0x02 and 0x03), but the data is for the previous sample. This gives a mechanism for determining whether a touch is newly detected or released (by performing an XOR of the current and previous values).

**BIT0 - Active**

This bit indicates the current user interface state in the previous sample. '1' corresponds to ACTIVE mode. '0' corresponds to Wake-on-Prox mode.

**BIT1 - Prox**

This bit indicates whether proximity was detected near the BOOSTXL-CAPKEYPAD during the last sample. A value of '1' = true, and '0' = false.

**BIT2 - Guard**

This bit indicates whether the guard channel masking function was activated during the last sample. A value of '1' = true, and '0' = false.

**BIT3 - Touch**

This bit indicates whether a touch was detected on any key (global touch detect) during the last sample. A value of '1' = true, and '0' = false.

**BIT4 - Key 1 Touch**

This bit indicates whether a touch was detected on key 1 during the last sample. A value of '1' = true, and '0' = false.

**BIT5 - Key 2 Touch**

This bit indicates whether a touch was detected on key 2 during the last sample. A value of '1' = true, and '0' = false.

**BIT6 - Key 3 Touch**

This bit indicates whether a touch was detected on key 3 during the last sample. A value of '1' = true, and '0' = false.

**BIT7 - Key 4 Touch**

This bit indicates whether a touch was detected on key 4 during the last sample. A value of '1' = true, and '0' = false.

I2C Register Description: 0x03, Status Word Upper 8 Bits
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

+----------------+--------------+---------+-------------+---------+---------+---------+---------+---------+
| Bit:           | BIT7         | BIT6    | BIT5        | BIT4    | BIT3    | BIT2    | BIT1    | BIT0    |
+================+==============+=========+=============+=========+=========+=========+=========+=========+
| Description:   | Cancel Key   | Key 0   | Enter Key   | Key 9   | Key 8   | Key 7   | Key 6   | Key 5   |
+----------------+--------------+---------+-------------+---------+---------+---------+---------+---------+
| Reset:         | 0            | 0       | 0           | 0       | 0       | 0       | 0       | 0       |
+----------------+--------------+---------+-------------+---------+---------+---------+---------+---------+
| RW:            | R            | R       | R           | R       | R       | R       | R       | R       |
+----------------+--------------+---------+-------------+---------+---------+---------+---------+---------+

**BIT0 - Key 5 Touch**

This bit indicates whether a touch was detected on key 5 during the last sample. A value of '1' = true, and '0' = false.

**BIT1 - Key 6 Touch**

This bit indicates whether a touch was detected on key 6 during the last sample. A value of '1' = true, and '0' = false.

**BIT2 - Key 7 Touch**

This bit indicates whether a touch was detected on key 7 during the last sample. A value of '1' = true, and '0' = false.

**BIT3 - Key 8 Touch**

This bit indicates whether a touch was detected on key 8 during the last sample. A value of '1' = true, and '0' = false.

**BIT4 - Key 9 Touch**

This bit indicates whether a touch was detected on key 9 during the last sample. A value of '1' = true, and '0' = false.

**BIT5 - Enter Key Touch**

This bit indicates whether a touch was detected on the enter key during the last sample. A value of '1' = true, and '0' = false.

**BIT6 - Key 0 Touch**

This bit indicates whether a touch was detected on key 0 during the last sample. A value of '1' = true, and '0' = false.

**BIT0 - Cancel (X) Key Touch**

This bit indicates whether a touch was detected on the cancel (X) key during the last sample. A value of '1' = true, and '0' = false.

BOOSTXL-CAPKEYPAD-Demo I2C Transaction Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Below are sample I2C transactions between the BOOSTXL-CAPKEYPAD running the BOOSTXL-CAPKEYPAD-Demo software (the I2C bus slave) and a host LaunchPad MCU (the I2C bus master).

Writing To The Control Word
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Below is an example of performing an I2C write transaction to set the lower control word of the BOOSTXL-CAPKEYPAD to a value of 0x02. The control word resides at address 0x00. The BOOSTXL-CAPKEYPAD I2C address is 0x11. Thus, to perform a bus write, the master sets up a write to 0x11, writes the register (0x00), and writes the value (0x02).

.. figure:: images/evm_boostxl_capkeypad/I2C_Ctrl_Write.png
   :alt: I2C Write Transaction

   I2C Write Transaction

In this example, writing 0x02 to the lower control word has the effect of clearing the shutdown bit, enabling wake-on-prox, and disabling the UART communication.

.. figure:: images/evm_boostxl_capkeypad/I2C_Ctrl_Write_Script.png
   :alt: I2C Write Decoding

   I2C Write Decoding

Reading The Status Words
^^^^^^^^^^^^^^^^^^^^^^^^

Below is an example of performing an I2C read transaction to obtain the current and last status words of the BOOSTXL-CAPKEYPAD. The I2C bus master, in this case, waits for the IRQ high-to-low transition before reading. The IRQ pin indicates that a new sample is now available. That sample will be valid until the IRQ pin transitions back high, indicating that the next sample is being measured.

.. figure:: images/evm_boostxl_capkeypad/I2C_Status_Read.png
   :alt: I2C Read Transaction

   I2C Read Transaction

To read the status words, the bus master performs an I2C write to slave address 0x11 and writes the address of the register it wishes to read (0x02). Then, it sends a re-start condition back to slave address 0x11, and reads out 4 bytes (0x02, 0x03, 0x04, and 0x05).

.. figure:: images/evm_boostxl_capkeypad/I2C_Status_Read_Script.png
   :alt: I2C Read Decoding

   I2C Read Decoding

In this example, the current status word lower byte (0x02) and the previous status word lower byte (0x04) both have just one bit set- the active bit. This bit indicates that the BOOSTXL-CAPKEYPAD is in its active scanning mode, testing all 12 buttons, with backlighting on.

Power Consumption
~~~~~~~~~~~~~~~~~

The power consumption of the BOOSTXL-CAPKEYPAD depends on two factors: the operating configuration (set by the control word) and the status of the user interface (wake-on-proximity vs. active). Below is a list of typical average currents in the various operating modes.

+-----------------------------------------+----------------------+---------------------+------------------+----------------+-------------------+
| Description                             | CTRL\_UART\_ENABLE   | CTRL\_WOP\_ENABLE   | CTRL\_SHUTDOWN   | STAT\_ACTIVE   | I-avg (Typical)   |
+=========================================+======================+=====================+==================+================+===================+
| Active with 3 touches, UART enabled     | TRUE                 | TRUE                | FALSE            | TRUE           | 26.2 mA           |
+-----------------------------------------+----------------------+---------------------+------------------+----------------+-------------------+
| Active with 2 touches, UART enabled     | TRUE                 | TRUE                | FALSE            | TRUE           | 23.2 mA           |
+-----------------------------------------+----------------------+---------------------+------------------+----------------+-------------------+
| Active with 1 touch, UART enabled       | TRUE                 | TRUE                | FALSE            | TRUE           | 20.2 mA           |
+-----------------------------------------+----------------------+---------------------+------------------+----------------+-------------------+
| Active with no touches, UART enabled    | TRUE                 | TRUE                | FALSE            | TRUE           | 13.5 mA           |
+-----------------------------------------+----------------------+---------------------+------------------+----------------+-------------------+
| Wake-on-prox, UART enabled              | TRUE                 | TRUE                | FALSE            | FALSE          | 360 uA            |
+-----------------------------------------+----------------------+---------------------+------------------+----------------+-------------------+
| Active with no touches, UART disabled   | FALSE                | TRUE                | FALSE            | TRUE           | 13.2 mA           |
+-----------------------------------------+----------------------+---------------------+------------------+----------------+-------------------+
| WOP, UART disabled                      | FALSE                | TRUE                | FALSE            | FALSE          | 8 uA              |
+-----------------------------------------+----------------------+---------------------+------------------+----------------+-------------------+
| Shutdown                                | X                    | X                   | TRUE             | X              | 1uA               |
+-----------------------------------------+----------------------+---------------------+------------------+----------------+-------------------+

By default, the BOOSTXL-CAPKEYPAD out-of-box example powers up with the following control word settings:

**Default Out-of-Box Init in main.c**

.. code:: c

    System_topLevel.controlWord =\
                SYSTEM__CTRL_WOP_ENABLE |\
                SYSTEM__CTRL_UART_ENABLE;

**Default Out-of-Box Settings**

+--------------------------------+-----------+
| Parameter                      | Setting   |
+================================+===========+
| SYSTEM\_\_CTRL\_SHUTDOWN       | FALSE     |
+--------------------------------+-----------+
| SYSTEM\_\_CTRL\_WOP\_ENABLE    | TRUE      |
+--------------------------------+-----------+
| SYSTEM\_\_CTRL\_UART\_ENABLE   | TRUE      |
+--------------------------------+-----------+

**NOTE**

The BOOSTXL-CAPKEYPAD powers up with UART enabled. This allows for communication between the BOOSTXL-CAPKEYPAD and a host computer running CapTIvate Design Center. In order for the UART to be functional, the MSP430FR2522 must sleep in low power mode 0 (LPM0) so that the baud rate clock is functional. This adds approximately 350uA to the average power consumption. For applications where the BOOSTXL-CAPKEYPAD is used only with a LaunchPad, and not the CapTIvate Design Center, the UART can be disabled by clearing the SYSTEM\_\_CTRL\_UART\_ENABLE bit. This will allow LPM4 to be used in wake-on-proximity mode, dropping the average current to less than 10uA in wake-on-proximity mode. The UART interface can be disabled via the I2C interface from a host processor- it is not necessary to re-program the MCU.

The current profile in wake-on-proximity mode with the UART interface disabled can be seen below.

.. figure:: images/evm_boostxl_capkeypad/nSHUTDOWN_WOP_nUART__WOP.png
   :alt: BOOSTXL-CAPKEYPAD Current Profile in WOP Mode with UART Disabled

   BOOSTXL-CAPKEYPAD Current Profile in WOP Mode with UART Disabled

Conducted Noise Immunity
~~~~~~~~~~~~~~~~~~~~~~~~

When running the BOOSTXL-CAPKEYPAD-EMC demo software, the BOOSTXL-CAPKEYPAD is capable of tolerating 3Vrms conducted noise coupled directly into its DC power supply. The plot below shows the results of a conducted noise immunity test in which the noise frequency was swept from 300kHz to 80 MHz while a continuous touch was applied to the electrode under test. The post-processed data, raw data, and measured noise level is shown. Note that while individual frequencies in the raw data are affected by conducted noise currents, the overall post-processed result rejects the noise-affected frequency to maintain correct operation.

.. figure:: images/evm_boostxl_capkeypad/emc_cni_test_sweep.png
   :alt: Conducted Noise Immunity Test Result, F-Sweep

   Conducted Noise Immunity Test Result, F-Sweep

The plot below shows two consecutive touches on the electrode under test while in the presence of constant conducted noise at 4 MHz. In the BOOSTXL-CAPKEYPAD-EMC software demonstration, the base charge transfer frequency is 4 MHz. The plot shows the clearly corrupted raw data at the base conversion frequency, but the 3 alternate frequencies are unaffected. It is this principle that enables reliable touch detection in the presence of conducted noise.

.. figure:: images/evm_boostxl_capkeypad/emc_cni_test_dwell_4M.png
   :alt: Conducted Noise Immunity Test Result, Dwell at 4MHz Noise Frequency

   Conducted Noise Immunity Test Result, Dwell at 4MHz Noise Frequency

Schematics
----------

.. figure:: images/evm_boostxl_capkeypad/schematic.png
   :alt: BOOSTXL-CAPKEYPAD Schematic

   BOOSTXL-CAPKEYPAD Schematic

Layout
------

.. figure:: images/evm_boostxl_capkeypad/layout.png
   :alt: BOOSTXL-CAPKEYPAD Layout

   BOOSTXL-CAPKEYPAD Layout

.. |BOOSTXL-CAPKEYPAD-Prototyping Design Canvas| image:: images/evm_boostxl_capkeypad/proto_canvas.png

